{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/images/755823897-58ac5c840cc9d_articlex.png","path":"images/755823897-58ac5c840cc9d_articlex.png","modified":0,"renderable":0},{"_id":"source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":0},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"5b505432e6c3e0c27203523adeff8487a47abe4c","modified":1487572434181},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1487572434229},{"_id":"themes/next/.gitignore","hash":"de5b9b9e5b313b4a86e805b02f334d35c87bfe56","modified":1487572434235},{"_id":"themes/next/.javascript_ignore","hash":"74b54cf920cbbf4038a68e54b7138af8b8f45588","modified":1487572434240},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1487572434227},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1487572434238},{"_id":"themes/next/README.md","hash":"06aaf1241e9e1619956c86d8b1397a643840a9d1","modified":1487572434247},{"_id":"themes/next/_config.yml","hash":"cc73a9c1d1dfe0edbaab4745896b3f563d6b111f","modified":1487572434250},{"_id":"source/favicon.ico","hash":"cc5d26a909ca3051b7a4d87b8ce8a3a3f4f3bee5","modified":1487572434219},{"_id":"themes/next/bower.json","hash":"bd70cf5988bbfc8cbcf13adae659151a55466524","modified":1487572434253},{"_id":"themes/next/gulpfile.coffee","hash":"e549561461642051d195550ec49d793e44ee22a0","modified":1487572434255},{"_id":"themes/next/README.en.md","hash":"f947d9a552da869f0dbef140ceeeb7b040b0f4a4","modified":1487572434244},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1487572434242},{"_id":"source/_posts/JavaScript异步编程.md","hash":"084185718d8003a65e658da684075ad63ed14a41","modified":1487572434184},{"_id":"source/_posts/LinkedList.md","hash":"acd8f61461e2ac3c2e464f8d9f748eee5f512c01","modified":1487573642164},{"_id":"source/_posts/LHS-RHS.md","hash":"31ac8cd7a34e1a63995b789140907ea8469a7b47","modified":1487572434187},{"_id":"source/_posts/Reproduced1.md","hash":"34922044acfaf5bb9d979abe29d5352bf1be57f3","modified":1487817014712},{"_id":"themes/next/package.json","hash":"48e2352f8e41f2b6bbf55254d10f3192ee206d5a","modified":1487572434626},{"_id":"source/_posts/hexo放到子目录并通过二级域名访问.md","hash":"ad21a7342b681107724c29a78ed0a0a61942a08e","modified":1487572434195},{"_id":"source/_posts/npm插件开发之旅.md","hash":"254514efff24b5f79237be6063898f44a380c39c","modified":1487572434199},{"_id":"source/_posts/translation-1.md","hash":"e05469a385e826fa5f72a6d05467262a07d530e9","modified":1487819349909},{"_id":"source/about/index.md","hash":"614cb8094a3d08450adac1d6cef78bf94c8c63c7","modified":1487572434214},{"_id":"source/_posts/工具集.md","hash":"78082599be1997bb640f5bc988fce880f9a386db","modified":1487572434207},{"_id":"source/_posts/video标签的属性和方法总结.md","hash":"368392c0c7c5f73bcc9ef5861d4b904dc86343e2","modified":1487572434204},{"_id":"source/_posts/高程笔记.md","hash":"0d1e06dcbc36742be733a9c3ce28b738c1ecffb8","modified":1487572434212},{"_id":"source/images/755823897-58ac5c840cc9d_articlex.png","hash":"b5f0d4d644c4b36234a46c8444d5a9163452d17c","modified":1487730393705},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"4312fb37fa2b8663006be3c4fe01125ec01171c1","modified":1487572434231},{"_id":"source/categories/index.md","hash":"177a90d79b9ade953b8cfa3c68121eef563b5eeb","modified":1487572434216},{"_id":"themes/next/l.git/HEAD","hash":"509e0f78e789c5517a73f9884e9c4d0c89abf07b","modified":1487572434257},{"_id":"themes/next/l.git/config","hash":"d81776f6683d5bcd4ba85f751461fb850311ab17","modified":1487572434259},{"_id":"themes/next/l.git/description","hash":"88d76a8724b84a5bbcc3bea08650bc679a0b3da6","modified":1487572434261},{"_id":"themes/next/l.git/index","hash":"7b571a0882ec6405132b59b002749040b166587a","modified":1487572434292},{"_id":"themes/next/l.git/packed-refs","hash":"c82250ecda745808922e64925335e65b85630c27","modified":1487572434357},{"_id":"source/tags/index.md","hash":"bd15d2c719a89bdadec910e5b590870d31526c13","modified":1487572434225},{"_id":"source/reading/index.md","hash":"91b1a3b3fb559a5681a03528a7d70dd0574e7dbe","modified":1487650281855},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"2692e36cc35b1594530981e7727771f601720a43","modified":1487572434233},{"_id":"themes/next/languages/fr-FR.yml","hash":"91cf55b9d75879e72c8008d2659fe2ea993a4cca","modified":1487572434371},{"_id":"themes/next/languages/de.yml","hash":"db6a9d669f4b6282cda6c0a2d4e03d3e308a4846","modified":1487572434364},{"_id":"themes/next/languages/default.yml","hash":"fe00529a94bb2550194a31d178f5810b45014ab6","modified":1487572434366},{"_id":"themes/next/languages/en.yml","hash":"d02acdce503c86fbb01920ad22d31ec56fc285f1","modified":1487572434369},{"_id":"themes/next/languages/id.yml","hash":"d8b9dc017da0be7f71fda1cacd8064cbc38963b9","modified":1487572434373},{"_id":"themes/next/languages/ko.yml","hash":"c59676f2af80c3c594c34c4a0fcbf65fd8864ff3","modified":1487572434378},{"_id":"themes/next/languages/pt-BR.yml","hash":"4b91f96b07e05705b28964df7460466c9b522e2c","modified":1487572434381},{"_id":"themes/next/languages/ja.yml","hash":"bc89436a2a015ef72f43f265e56e37d94e73c0cd","modified":1487572434376},{"_id":"themes/next/languages/ru.yml","hash":"402e676252ab1fc4522257a578738cb9536eb077","modified":1487572434385},{"_id":"themes/next/languages/pt.yml","hash":"f364905121a816c9797acce07c0a4f248965b29a","modified":1487572434383},{"_id":"themes/next/layout/_layout.swig","hash":"24de463d28bacbf2a28c34fecf082980f7f33a12","modified":1487572434399},{"_id":"themes/next/layout/archive.swig","hash":"b867a08f6b43de8b5d700c84b943df55917407ae","modified":1487572434610},{"_id":"themes/next/languages/zh-Hans.yml","hash":"41727610ee844a903c755c4e31f0a8f90615899d","modified":1487572434387},{"_id":"themes/next/layout/category.swig","hash":"58cf08388901f7549b1fca95548b2c79173aa840","modified":1487572434613},{"_id":"themes/next/layout/index.swig","hash":"e5b52e04296203262a400e8e36ae12426d31fd5b","modified":1487572434615},{"_id":"themes/next/layout/post.swig","hash":"b8334c479840b7724638eec71971cbd8512ae58d","modified":1487572434619},{"_id":"themes/next/layout/page.swig","hash":"2a13804aa186f6062738d136e430870c53789bf4","modified":1487572434617},{"_id":"themes/next/layout/tag.swig","hash":"6f764ea3ab11eeb7c530df45528d449b14f5dc62","modified":1487572434623},{"_id":"themes/next/scripts/merge-configs.js","hash":"f8cde6953939802f92da5b7a2458c6c539e9be69","modified":1487572434630},{"_id":"themes/next/layout/schedule.swig","hash":"595013860078799d455af4965b3a7c5c4fd3923c","modified":1487572434621},{"_id":"themes/next/languages/zh-hk.yml","hash":"a59f3f3114f5eb4d170a76da4359307e8f5159a7","modified":1487572434390},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1487572435936},{"_id":"themes/next/languages/zh-tw.yml","hash":"18da1324d2212faca9a6e5e6ce98b419c86d4b0c","modified":1487572434392},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1487572435513},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1487572435942},{"_id":"source/images/avatar.png","hash":"c48b6f2d4a652ade896afaf3fdbe357ed35307f2","modified":1487572434220},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1487572435949},{"_id":"themes/next/l.git/hooks/applypatch-msg.sample","hash":"61f0ed9af9a16dbba9b834edfb657f07aa10125d","modified":1487572434263},{"_id":"themes/next/l.git/hooks/commit-msg.sample","hash":"e44c3d173580f6b4d8ee7f9b963d252af9902703","modified":1487572434266},{"_id":"themes/next/l.git/hooks/pre-applypatch.sample","hash":"7863e8a9fef55740491ab4429a13081a20a1dad9","modified":1487572434270},{"_id":"themes/next/l.git/hooks/pre-commit.sample","hash":"da4e689ea46d093a0a4585046fca844e243b22b0","modified":1487572434273},{"_id":"themes/next/l.git/hooks/post-update.sample","hash":"6c00d034115de8f56eba4ded1eba7ffc73b332f6","modified":1487572434268},{"_id":"themes/next/l.git/hooks/pre-push.sample","hash":"ac10c067e42e887ed93052dbece70922812546f3","modified":1487572434276},{"_id":"themes/next/l.git/hooks/pre-receive.sample","hash":"bfff8781c853c3d554371cc50e63ec70eb377711","modified":1487572434282},{"_id":"themes/next/l.git/hooks/pre-rebase.sample","hash":"38c5fea16bac7be194361a885c678d8b08787d3b","modified":1487572434280},{"_id":"themes/next/l.git/hooks/prepare-commit-msg.sample","hash":"bbc936f9c3920673a901aae46a8b99afb1400a56","modified":1487572434285},{"_id":"themes/next/l.git/info/exclude","hash":"0214ce0925395605f10f65300bc1e4871dd9441e","modified":1487572434294},{"_id":"themes/next/l.git/logs/HEAD","hash":"b77e8ddc5ccb49f36d1d3e8b3e396f8066e3cb04","modified":1487572434296},{"_id":"themes/next/l.git/hooks/update.sample","hash":"df9f68bdcd0e7c6cee8cdce7b17f8ff7e625847b","modified":1487572434289},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1487572434397},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1487572434397},{"_id":"themes/next/layout/_macro/reward.swig","hash":"b6cb171f0ed227b82b8f7601814af2df93f3a09a","modified":1487572434410},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"6d40652784585d263c37b8a3723e43e04b926ca7","modified":1487572434402},{"_id":"themes/next/layout/_macro/post.swig","hash":"216907a1348317114ccb90fecc752b8b7255b15b","modified":1487572434407},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"a42851e17d8961e5cae8b588d95a4a5456964972","modified":1487572434413},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"c5cc0070ca7c9a8dbd4b09e0398db536c3cdbe8a","modified":1487572434416},{"_id":"themes/next/layout/_partials/comments.swig","hash":"09da002fbeb0fe2ac3f180ecf77bce568ea989ca","modified":1487572434418},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1487572434421},{"_id":"themes/next/layout/_partials/footer.swig","hash":"683616f4a80796051e2346d80acf838a589450b0","modified":1487572434423},{"_id":"themes/next/layout/_partials/head.swig","hash":"740684ef2b6e56183529387882042612e904bc8d","modified":1487572434428},{"_id":"themes/next/layout/_partials/header.swig","hash":"8985089c950d6df0efab9cd549a6b9ee50708ee2","modified":1487572434434},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1487572434440},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"dfbb6e9692333166aa78231ad12b2a40c153cbcb","modified":1487572434437},{"_id":"themes/next/layout/_partials/search.swig","hash":"952b7b8d9ce2c81d4002a9dc2331f1e710f99616","modified":1487572434442},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1487572434484},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1487572434481},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1487572434487},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"e9beddda9758d8739c41fc8c67b2e72fc29c1244","modified":1487572434606},{"_id":"themes/next/scripts/tags/button.js","hash":"aaf71be6b483fca7a65cd6296c2cf1c2271c26a6","modified":1487572434633},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1487572434636},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1487572434639},{"_id":"themes/next/scripts/tags/note.js","hash":"7dc14db08f2c74f8f1952534b424f220f5c000c6","modified":1487572434652},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1487572434649},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1487572435517},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"16505f61f19ba65f629dfd033f14ee9abcf18756","modified":1487572435516},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1487572435519},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1487572435513},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1487572435525},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1487572435528},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1487572435523},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1487572435531},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1487572435534},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1487572435535},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1487572435535},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1487572435534},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1487572435533},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1487572435536},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1487572434490},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1487572434490},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1487572435443},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1487572435443},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1487572435450},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1487572435502},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1487572435510},{"_id":"themes/next/l.git/refs/heads/master","hash":"72e93da1fdfc8c5a35dc17cbe3a2c25547c8ea67","modified":1487572434360},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1487572434394},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1487572435535},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"bb2c3a926bb7f8fea54d424882b25d93dfde7ae6","modified":1487572434396},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1487572434430},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1487572434432},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"efa7efcbb575381b508f9aa0e0c53140eef72a7b","modified":1487572434445},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1487572434450},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1487572434455},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1487572434452},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1487572434468},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1487572434470},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"12684840de632eb16e53ffa863166306a756fd4f","modified":1487572434476},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1487572434490},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1487572434492},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"188423f7df0eb8c99a03cb6741384415651c4665","modified":1487572434495},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"4f9efb15c9aaa016ac78d9f8aa2caefea87869df","modified":1487572434536},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"e495aed8fb36bf8015ddbd64366270a7debad2b0","modified":1487572434570},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"f592adff22628b271ec9657b080cf6b9cc200615","modified":1487572434581},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1487572434587},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1487572434596},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1487572434602},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1487572435443},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"531934ea21ef4dc9f0978512050f54834f0a6cff","modified":1487572435449},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c666e352c3b8e4ad0a16cc757b08f44ef9172182","modified":1487572435506},{"_id":"themes/next/source/css/_variables/base.styl","hash":"8b08a5ce4222aa731b180a12127bd0e52d12ede8","modified":1487572435510},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e55265c8a8a6ae0c3c08e3509de92ee62c3cb5f6","modified":1487572435502},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"a0f23e75a137d8c996c70e2059e0074f1e97a127","modified":1487572435446},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1487572435547},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"4a0da1bed19e65bd7db42421b447061bc1618710","modified":1487572435548},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"84bdc8a4fe127849a5c99bdefe1d0b65ee1a4a0a","modified":1487572435548},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1487572435549},{"_id":"themes/next/source/js/src/post-details.js","hash":"458af3b1bd7783c1950808e66cedfa9fb68bf21f","modified":1487572435550},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1487572435553},{"_id":"themes/next/source/js/src/motion.js","hash":"ff9ea37d05c269e3a140c4ab448af03efc4bcc76","modified":1487572435550},{"_id":"themes/next/source/js/src/utils.js","hash":"e34f83848883732ddd7a34a3e3ed2a293f0f76a7","modified":1487572435552},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1487572435749},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1487572435749},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1487572435551},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1487572435754},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1487572435757},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1487572435770},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1487572435701},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"8868275e8b6340c87a81c69a54ed138d11fb3c3e","modified":1487572435768},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1487572435773},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1487572435775},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1487572435892},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1487572435890},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1487572435773},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1487572435934},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1487572435927},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1487572435920},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1487572435855},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1487572435862},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1487572435864},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1487572435858},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1487572435827},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1487572435872},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1487572435871},{"_id":"themes/next/l.git/logs/refs/heads/master","hash":"b77e8ddc5ccb49f36d1d3e8b3e396f8066e3cb04","modified":1487572434297},{"_id":"themes/next/l.git/refs/remotes/origin/HEAD","hash":"e72f7364331a01c35feea3858c09e16db1631660","modified":1487572434362},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1487572434501},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1487572434510},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"24105e62d7f26946907fa14cd02589f899bf8122","modified":1487572434513},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1487572434516},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"a79e7e0d809fcf407593dd7ed9e023db21c3cbd6","modified":1487572434520},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"1b6af02fd0ba3f729675cd95429a0cea4aebf358","modified":1487572434525},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1487572434534},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"e4a13e8cd19762ef3aea0e59dfae8b3c1f251f11","modified":1487572434542},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1487572434547},{"_id":"themes/next/layout/_scripts/third-party/comments/gentie.swig","hash":"0f38f053841ef77cdce56a84cfbb4dd4c3329486","modified":1487572434551},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1487572434556},{"_id":"themes/next/layout/_scripts/third-party/comments/youyan.swig","hash":"f40a697fd046415924a142eec1effad70f3cb187","modified":1487572434559},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ad69cbf94eedacc27e756cdb9c7073416db697d0","modified":1487572434654},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1487572434919},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"b7d5cc29586ac796a50d90974ad99d24a5982137","modified":1487572434928},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"22828f5141c0cecb9ef25a110e194cdfa3a36423","modified":1487572434656},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"88559b13ce94311405b170a0506ded91273beceb","modified":1487572435269},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5a35aa0381b0e1d465b952a997194441020446ea","modified":1487572435430},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1487572435393},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1487572435427},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1487572435436},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"b6ee5fefa6046086a76ddbcfafc82482816fa3e0","modified":1487572435433},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"c9218b48c56e52c06af9ce3cc8fbdae737cf16fe","modified":1487572435438},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1487572435440},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1487572435478},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"f23ac53ab901c48859dd29eee6e386b60ff956ba","modified":1487572435480},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1487572435476},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1487572435483},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"34acb45007229b299951ce35d8eef642ea16fbe9","modified":1487572435486},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1487572435481},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"221d3dbc04ff6c211ba9382397c4977e9f493153","modified":1487572435489},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1487572435494},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"51aaa1c627a1f6da72297cdfd44725796c8bea94","modified":1487572435491},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"1be4ef3f97f329e2531bfd2dfdc40c0e46df35c8","modified":1487572435497},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1487572435499},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1487572435452},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1487572435457},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1487572435460},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1487572435455},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1487572435465},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"ce272226a1570f5f7c70243b751a5b0fe1671a88","modified":1487572435463},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1487572435702},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1487572435702},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1487572435703},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1487572435468},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1487572435704},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1487572435705},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1487572435705},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"c2390263a298a2b78c5f941e6827c13f02e1ee85","modified":1487572435551},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1487572435724},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1487572435765},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1487572435734},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1487572435746},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1487572435781},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"a02674d823c7b577d38c3cdb91953993b6e4b3a0","modified":1487572435778},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"3c1d63dd1176c77f9f4cdb1616fbb08c31b9822f","modified":1487572435785},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1487572435880},{"_id":"themes/next/l.git/objects/pack/pack-00f07f1de24eae5e11a6eafe2ba682e19a17d816.idx","hash":"9d5dbc105ad16f3b5a38b696e32be0282b529cf3","modified":1487572434301},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1487572435887},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1487572435852},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1487572435765},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1487572435790},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1487572435804},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1487572435821},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1487572435824},{"_id":"themes/next/l.git/logs/refs/remotes/origin/HEAD","hash":"b77e8ddc5ccb49f36d1d3e8b3e396f8066e3cb04","modified":1487572434297},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1487572434945},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"a29f362919853438046488917925797fde6cea72","modified":1487572434936},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1487572434948},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1487572435119},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1487572435128},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"cd2def16d31feb234be27dcdce2a919f70cc6919","modified":1487572435137},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"852fd77500bda2c1a6651a14aa48d7d6222adc9d","modified":1487572434953},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1487572435218},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"104b5c79cd891506e0beaf938b083685f1da8637","modified":1487572435226},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1487572435252},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1487572435110},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1487572435261},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1487572435234},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1487572435243},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1487572435297},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"0d9a4ae2e4ab418453e0f81b8fb1ad4b856f91d4","modified":1487572435278},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"4866fb9453d7d4c83a1c4e55d74e4afed336eb8b","modified":1487572435306},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"e5845ecff106fd566ea1cd091d5bea6f290f1287","modified":1487572435322},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1487572435314},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"a45f5fce643eec4e1b927165229d560364bcace1","modified":1487572435289},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"74e9989a10fc682388cbd25ff7df0d7d4025fb8c","modified":1487572435330},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"8355b0e9375b3245508efda0e18acd069c2aa767","modified":1487572435337},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1487572435342},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"350469437b20ecfd6f3ca45e400478f8e3f71cfb","modified":1487572435346},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a8955d89ef4b48ba7ac9d6e1c6aa76bc1308065e","modified":1487572435357},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1487572435352},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"7f2bdd6109614d35408ee5ac3335aad4464c69c7","modified":1487572435362},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1487572435366},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1487572435373},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"821991c0890966a512b43e8b1cf9537e738a09a0","modified":1487572435370},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"394888efec32749b353292a59ec7f1b609d6325e","modified":1487572435380},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1487572435376},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"702be9e57dd6ff5fa99642a1f6e3df26215b8805","modified":1487572435386},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1487572435390},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"06b9a99d63b4d57fdbf70b88ab7036fbc47e3f52","modified":1487572435383},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1487572435395},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"3159b55f35c40bd08e55b00148c523760a708c51","modified":1487572435398},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1487572435400},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"8420b4be386469337243336aee694297875bd439","modified":1487572435403},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"c8a05ce90784db9744c22fab22019eb637df1f2f","modified":1487572435405},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"3b1aabbab57b0b1fafa311feb1212f59e78e7928","modified":1487572435408},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1487572435410},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"7f7e9df15148608a9c29326dd880d8e8e8efc0ec","modified":1487572435412},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"cd526e814f9323a79fe835085d64867d34b3715d","modified":1487572435417},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"548b70cec691114cf08cebc5833e5df5d17afa0e","modified":1487572435415},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1487572435419},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"cf900c5026ab36f31118317d0ae32a213e3ec2a9","modified":1487572435484},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"cf900c5026ab36f31118317d0ae32a213e3ec2a9","modified":1487572435473},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"dc944a01dd59f5ed2d44bb22fdb21fc3f455948f","modified":1487572435424},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1487572435471},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"eb4ede7d7446d8a2f2ddeef3b17f497a6ad30756","modified":1487572435422},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1487572435708},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1487572435716},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1487572435818},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1487572435706},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1487572435906},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1487572435715},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1487572435724},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1487572435715},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"964e8dac2cee79c4b49b5bc300675773f6518812","modified":1487572435814},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1487572435700},{"_id":"themes/next/l.git/objects/pack/pack-00f07f1de24eae5e11a6eafe2ba682e19a17d816.pack","hash":"40c8757daa949da2de470b088593680ae25c22d1","modified":1487572434354},{"_id":"public/about/index.html","hash":"e3aa41bc139fae6189e7f93d17ccf18a2fa47a90","modified":1487817069401},{"_id":"public/tags/index.html","hash":"e720d85e82f3ad973860569d0238705edcbfe151","modified":1487817069414},{"_id":"public/categories/index.html","hash":"9428e0b9ae325fbcc338029e2c31dd1fbf4a3f41","modified":1487817069415},{"_id":"public/archives/2016/12/index.html","hash":"5f99a81908a26490c001aa0b55e740cfec2a6776","modified":1487817069549},{"_id":"public/categories/Javascript/index.html","hash":"50db713b01277aae148f6025916be9ad86c9b850","modified":1487817069550},{"_id":"public/categories/node/index.html","hash":"c4b1e92932da9f814cc3cec2495ff853cd07cb5b","modified":1487817069550},{"_id":"public/categories/Translation/index.html","hash":"1d3d823b6af3f482eecfadfd5b42bbf51d282457","modified":1487817069550},{"_id":"public/categories/工具/index.html","hash":"0090c8b5bca7d294a6b65aecf927b525228c2340","modified":1487817069550},{"_id":"public/categories/hexo/index.html","hash":"3bb9f0c627704776010e43b24d83f456bdb2ff80","modified":1487817069551},{"_id":"public/archives/2016/index.html","hash":"e40fe2b61cc377bc0038185a19155c17c44e3da3","modified":1487817069551},{"_id":"public/tags/数据结构和算法/index.html","hash":"9b8478db99aa020d092dc684b53109703b4100b0","modified":1487817069551},{"_id":"public/tags/向下一层/index.html","hash":"4571451d0d09e3ac9177581104055d187cc439b8","modified":1487817069551},{"_id":"public/categories/HTML5/index.html","hash":"443aee43f294fb52d2e63f3dd497a6ddf8078a40","modified":1487817069552},{"_id":"public/tags/异步/index.html","hash":"c2358178fde0fb5f8f3b84a093c6699b3c801fc5","modified":1487817069552},{"_id":"public/tags/hexo/index.html","hash":"afdccbb6b436e1e5b2ac3bd518d6be1dba259640","modified":1487817069552},{"_id":"public/tags/素材资源/index.html","hash":"5eab263fc235af82cf788cbd134e42d0d58118fd","modified":1487817069552},{"_id":"public/tags/npm/index.html","hash":"67352cebbee616c24808d71919e7cb943f6d348d","modified":1487817069552},{"_id":"public/tags/node/index.html","hash":"d771caf7b7e729a75391f65472beffdbdbe10b16","modified":1487817069552},{"_id":"public/tags/在线工具/index.html","hash":"f2b66249c07e9eae5df9d282d80f78b315c23e62","modified":1487817069552},{"_id":"public/tags/Chrome插件/index.html","hash":"a62da134d48cce6db9c6a557ab8c488b601eb944","modified":1487817069552},{"_id":"public/tags/video/index.html","hash":"86eb4110c144a77ce5ae240ce66cb34d7c3af91f","modified":1487817069552},{"_id":"public/tags/HTML5/index.html","hash":"bbbf69d9373acf0353638413cd5497c0ded38a22","modified":1487817069552},{"_id":"public/tags/快乐的coding/index.html","hash":"bb3b3a5c90b197dce2446729d4c8a79c8d50cf20","modified":1487817069552},{"_id":"public/tags/读书/index.html","hash":"78b8533e2133d73b99df90882224b6d93299ede0","modified":1487817069552},{"_id":"public/tags/时间管理/index.html","hash":"cb78d5261ea737a36034f53a2b4335ffe7f777fc","modified":1487817069552},{"_id":"public/reading/index.html","hash":"a338aa7601677eb1aa57312df3616b77a5b2e73b","modified":1487817069552},{"_id":"public/2017/02/translation-1/index.html","hash":"c2614858fed8d5990ebdf61f73c6c50c526a0439","modified":1487819360865},{"_id":"public/2017/02/LinkedList/index.html","hash":"8426e6261d93c246067c28d2e74ca017a6642e0e","modified":1487817069552},{"_id":"public/2017/02/LHS-RHS/index.html","hash":"406031b040ff28c8a5f98ad76f6b823ce66ab09e","modified":1487817069552},{"_id":"public/2017/01/npm插件开发之旅/index.html","hash":"b2a549f6098f301b936065c8f12471fdd8f48cd3","modified":1487817069552},{"_id":"public/2017/01/JavaScript异步编程/index.html","hash":"8f67eb2aed752249e26934caec64ddf6258c0137","modified":1487817069552},{"_id":"public/2017/01/工具集/index.html","hash":"771a82f125c948089b1ca12c710cb2ced4277615","modified":1487817069553},{"_id":"public/2016/12/hexo放到子目录并通过二级域名访问/index.html","hash":"14db21753449d117f7882358d89c8e69ae8eb765","modified":1487817069553},{"_id":"public/archives/index.html","hash":"868cb0b7a394671a574b55cff4a5b9dfb775233b","modified":1487817069553},{"_id":"public/2017/01/video标签的属性和方法总结/index.html","hash":"13fc92ccc1824a7e1c9ac20fc596ee17c49a2ce0","modified":1487817069553},{"_id":"public/2017/01/高程笔记/index.html","hash":"24926594d3a025133354eb0036646803c9e25762","modified":1487817069553},{"_id":"public/archives/2017/index.html","hash":"74c9a0e55401fd396ba671fdc0d8c4ba028a2066","modified":1487817069553},{"_id":"public/archives/2017/02/index.html","hash":"e6f99eb2b09cfacd4cbb10fa50be76b1ae6a41d4","modified":1487817069553},{"_id":"public/categories/JavaScript/index.html","hash":"4ed835225db4d7eb64c83b57f433116221322616","modified":1487817069553},{"_id":"public/archives/2017/01/index.html","hash":"ab93327ec20e22ae6108e149c1b6455ba99a8ba7","modified":1487817069553},{"_id":"public/index.html","hash":"228a370e2fdbeea02fad832f4b01a98f48a6703e","modified":1487817069553},{"_id":"public/tags/JavaScript/index.html","hash":"98d381b684109cb7e1a506151f11d1ea7a66de80","modified":1487817069553},{"_id":"public/categories/转载/index.html","hash":"b1f48b47d01bcfc13a58af18d83ee8a5f91d8c64","modified":1487817069557},{"_id":"public/tags/函数式编程/index.html","hash":"5e4863fc701d36af83d12dee7fd31e63ae5e06f7","modified":1487817069557},{"_id":"public/2017/02/Reproduced1/index.html","hash":"e185ff6a825b605038b3f98cdab703e7de4322ea","modified":1487817069557},{"_id":"public/images/755823897-58ac5c840cc9d_articlex.png","hash":"b5f0d4d644c4b36234a46c8444d5a9163452d17c","modified":1487817069558},{"_id":"source/robots.txt","hash":"43fda7789f103b8403a0db2960c58bec681cf613","modified":1487910229633},{"_id":"public/baidusitemap.xml","hash":"b2f91fbfad9a93c44306d6004661f7b075cb7998","modified":1487910375642},{"_id":"public/sitemap.xml","hash":"0b51a2553e3f9e7c9f984fd2bd9af92833151908","modified":1487910375643},{"_id":"public/robots.txt","hash":"43fda7789f103b8403a0db2960c58bec681cf613","modified":1487910375645}],"Category":[{"name":"JavaScript","_id":"cizhru6p70004osqpqtin258n"},{"name":"Javascript","_id":"cizhru6ph000aosqp8y774p2y"},{"name":"转载","_id":"cizhru6pw000mosqp8a0biqlp"},{"name":"hexo","_id":"cizhru6q0000qosqpjqowskwy"},{"name":"node","_id":"cizhru6q4000wosqpxtkaav7p"},{"name":"Translation","_id":"cizhru6q60010osqp881qf6qg"},{"name":"工具","_id":"cizhru6q70015osqpu31g01sk"},{"name":"HTML5","_id":"cizhru6q90018osqpi91kbjo8"}],"Data":[],"Page":[{"title":"关于","date":"2017-01-11T06:49:13.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2017-01-11 14:49:13\n---\n","updated":"2017-02-20T06:33:54.214Z","path":"about/index.html","comments":1,"layout":"page","_id":"cizhru6p00001osqpwslh7q9k","content":"","excerpt":"","more":""},{"title":"分类","date":"2017-01-11T06:50:14.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2017-01-11 14:50:14\ntype: \"categories\"\n---\n","updated":"2017-02-20T06:33:54.216Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cizhru6p50003osqpx187rwi6","content":"","excerpt":"","more":""},{"title":"标签","date":"2017-01-11T06:52:13.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2017-01-11 14:52:13\ntype: \"tags\"\n---\n","updated":"2017-02-20T06:33:54.225Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cizhru6pc0007osqpanil0795","content":"","excerpt":"","more":""},{"title":"书籍","date":"2017-02-12T10:56:40.000Z","_content":"## 书单 \n\n> 删除线为已读\n\n### JavaScript\n- ~~JavaScript高级程序设计~~\n- ~~图解HTTP~~\n- JavaScript函数式编程\n- JavaScript设计模式与开发实践\n- MVC的JavaScript Web富应用开发\n- 你不知道的JavaScript（上中卷）\n- JavaScript框架设计\n- ~~深入浅出Node.js~~\n\n### 延伸阅读\n- ~~穿越计算机迷雾的迷雾~~\n- 七周七语言\n- 编码\n\n\n## 源码阅读计划\n> 挑选的重要指标是短小 - -\n\n- underscore.js\n- zepto\n- backbone","source":"reading/index.md","raw":"---\ntitle: 书籍\ndate: 2017-02-12 18:56:40\n---\n## 书单 \n\n> 删除线为已读\n\n### JavaScript\n- ~~JavaScript高级程序设计~~\n- ~~图解HTTP~~\n- JavaScript函数式编程\n- JavaScript设计模式与开发实践\n- MVC的JavaScript Web富应用开发\n- 你不知道的JavaScript（上中卷）\n- JavaScript框架设计\n- ~~深入浅出Node.js~~\n\n### 延伸阅读\n- ~~穿越计算机迷雾的迷雾~~\n- 七周七语言\n- 编码\n\n\n## 源码阅读计划\n> 挑选的重要指标是短小 - -\n\n- underscore.js\n- zepto\n- backbone","updated":"2017-02-21T04:11:21.855Z","path":"reading/index.html","comments":1,"layout":"page","_id":"cizhru6qr0023osqp968zdxee","content":"<h2 id=\"书单\"><a href=\"#书单\" class=\"headerlink\" title=\"书单\"></a>书单</h2><blockquote>\n<p>删除线为已读</p>\n</blockquote>\n<h3 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h3><ul>\n<li><del>JavaScript高级程序设计</del></li>\n<li><del>图解HTTP</del></li>\n<li>JavaScript函数式编程</li>\n<li>JavaScript设计模式与开发实践</li>\n<li>MVC的JavaScript Web富应用开发</li>\n<li>你不知道的JavaScript（上中卷）</li>\n<li>JavaScript框架设计</li>\n<li><del>深入浅出Node.js</del></li>\n</ul>\n<h3 id=\"延伸阅读\"><a href=\"#延伸阅读\" class=\"headerlink\" title=\"延伸阅读\"></a>延伸阅读</h3><ul>\n<li><del>穿越计算机迷雾的迷雾</del></li>\n<li>七周七语言</li>\n<li>编码</li>\n</ul>\n<h2 id=\"源码阅读计划\"><a href=\"#源码阅读计划\" class=\"headerlink\" title=\"源码阅读计划\"></a>源码阅读计划</h2><blockquote>\n<p>挑选的重要指标是短小 - -</p>\n</blockquote>\n<ul>\n<li>underscore.js</li>\n<li>zepto</li>\n<li>backbone</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"书单\"><a href=\"#书单\" class=\"headerlink\" title=\"书单\"></a>书单</h2><blockquote>\n<p>删除线为已读</p>\n</blockquote>\n<h3 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h3><ul>\n<li><del>JavaScript高级程序设计</del></li>\n<li><del>图解HTTP</del></li>\n<li>JavaScript函数式编程</li>\n<li>JavaScript设计模式与开发实践</li>\n<li>MVC的JavaScript Web富应用开发</li>\n<li>你不知道的JavaScript（上中卷）</li>\n<li>JavaScript框架设计</li>\n<li><del>深入浅出Node.js</del></li>\n</ul>\n<h3 id=\"延伸阅读\"><a href=\"#延伸阅读\" class=\"headerlink\" title=\"延伸阅读\"></a>延伸阅读</h3><ul>\n<li><del>穿越计算机迷雾的迷雾</del></li>\n<li>七周七语言</li>\n<li>编码</li>\n</ul>\n<h2 id=\"源码阅读计划\"><a href=\"#源码阅读计划\" class=\"headerlink\" title=\"源码阅读计划\"></a>源码阅读计划</h2><blockquote>\n<p>挑选的重要指标是短小 - -</p>\n</blockquote>\n<ul>\n<li>underscore.js</li>\n<li>zepto</li>\n<li>backbone</li>\n</ul>\n"}],"Post":[{"title":"JavaScript异步编程","date":"2017-01-22T05:44:10.000Z","_content":"\n原来对于JavaScript**异步**、**阻塞**、**单线程**只是了解，最近学习算法，想实现排序可视化，才发现自己对这方便内容真的是一知半解。\n\n今天好好查了一下资料，放个阮一峰的链接，但是他没说全，结合本文，可以更好的理解，浏览器中异步的实现。\n> [Javascript异步编程的4种方法](http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html)\n\n### JavaScript是单线程的\n\n\"单线程\"，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。\n\n<!-- more -->\n\n### 浏览器是多线程的\n浏览器是多线程的，诸如js引擎线程，定时器线程，HTTP请求线程，事件触发线程，js单线程是指只有一条js引擎线程来执行js，所以说无论某个时间js只能干一件事情。\n\n### 浏览器定时器\n当调用定时器的时候，浏览器会分配定时器线程来做这件事，什么事？就是在指定时间后将指定函数插入到任务队列的末尾！\n\n当js线程完成手上正在执行的任务后，就会将任务队列排在首位的任务读取并执行，如此往复。\n\n这也是为什么有些时候使用setTimeout但却不能在指定时间执行指定函数的原因，因为它前面还有其他任务在排队或者说js引擎线程当前的任务还没执行完毕，那就只能等着了。\n\n所以所谓的异步都是浏览器实现的。\n\n### 更多异步实现\n\n知道了上面的基础知识，再去看下面的内容，就觉得不那么神秘了。\n\n>> [Javascript异步编程的4种方法](http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html)","source":"_posts/JavaScript异步编程.md","raw":"---\ntitle: JavaScript异步编程\ndate: 2017-01-22 13:44:10\ncategories:\n- JavaScript\ntags: \n- 异步\n- JavaScript\n---\n\n原来对于JavaScript**异步**、**阻塞**、**单线程**只是了解，最近学习算法，想实现排序可视化，才发现自己对这方便内容真的是一知半解。\n\n今天好好查了一下资料，放个阮一峰的链接，但是他没说全，结合本文，可以更好的理解，浏览器中异步的实现。\n> [Javascript异步编程的4种方法](http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html)\n\n### JavaScript是单线程的\n\n\"单线程\"，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。\n\n<!-- more -->\n\n### 浏览器是多线程的\n浏览器是多线程的，诸如js引擎线程，定时器线程，HTTP请求线程，事件触发线程，js单线程是指只有一条js引擎线程来执行js，所以说无论某个时间js只能干一件事情。\n\n### 浏览器定时器\n当调用定时器的时候，浏览器会分配定时器线程来做这件事，什么事？就是在指定时间后将指定函数插入到任务队列的末尾！\n\n当js线程完成手上正在执行的任务后，就会将任务队列排在首位的任务读取并执行，如此往复。\n\n这也是为什么有些时候使用setTimeout但却不能在指定时间执行指定函数的原因，因为它前面还有其他任务在排队或者说js引擎线程当前的任务还没执行完毕，那就只能等着了。\n\n所以所谓的异步都是浏览器实现的。\n\n### 更多异步实现\n\n知道了上面的基础知识，再去看下面的内容，就觉得不那么神秘了。\n\n>> [Javascript异步编程的4种方法](http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html)","slug":"JavaScript异步编程","published":1,"updated":"2017-02-20T06:33:54.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizhru6op0000osqptkdot037","content":"<p>原来对于JavaScript<strong>异步</strong>、<strong>阻塞</strong>、<strong>单线程</strong>只是了解，最近学习算法，想实现排序可视化，才发现自己对这方便内容真的是一知半解。</p>\n<p>今天好好查了一下资料，放个阮一峰的链接，但是他没说全，结合本文，可以更好的理解，浏览器中异步的实现。</p>\n<blockquote>\n<p><a href=\"http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html\" target=\"_blank\" rel=\"external\">Javascript异步编程的4种方法</a></p>\n</blockquote>\n<h3 id=\"JavaScript是单线程的\"><a href=\"#JavaScript是单线程的\" class=\"headerlink\" title=\"JavaScript是单线程的\"></a>JavaScript是单线程的</h3><p>“单线程”，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。</p>\n<a id=\"more\"></a>\n<h3 id=\"浏览器是多线程的\"><a href=\"#浏览器是多线程的\" class=\"headerlink\" title=\"浏览器是多线程的\"></a>浏览器是多线程的</h3><p>浏览器是多线程的，诸如js引擎线程，定时器线程，HTTP请求线程，事件触发线程，js单线程是指只有一条js引擎线程来执行js，所以说无论某个时间js只能干一件事情。</p>\n<h3 id=\"浏览器定时器\"><a href=\"#浏览器定时器\" class=\"headerlink\" title=\"浏览器定时器\"></a>浏览器定时器</h3><p>当调用定时器的时候，浏览器会分配定时器线程来做这件事，什么事？就是在指定时间后将指定函数插入到任务队列的末尾！</p>\n<p>当js线程完成手上正在执行的任务后，就会将任务队列排在首位的任务读取并执行，如此往复。</p>\n<p>这也是为什么有些时候使用setTimeout但却不能在指定时间执行指定函数的原因，因为它前面还有其他任务在排队或者说js引擎线程当前的任务还没执行完毕，那就只能等着了。</p>\n<p>所以所谓的异步都是浏览器实现的。</p>\n<h3 id=\"更多异步实现\"><a href=\"#更多异步实现\" class=\"headerlink\" title=\"更多异步实现\"></a>更多异步实现</h3><p>知道了上面的基础知识，再去看下面的内容，就觉得不那么神秘了。</p>\n<blockquote>\n<blockquote>\n<p><a href=\"http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html\" target=\"_blank\" rel=\"external\">Javascript异步编程的4种方法</a></p>\n</blockquote>\n</blockquote>\n","excerpt":"<p>原来对于JavaScript<strong>异步</strong>、<strong>阻塞</strong>、<strong>单线程</strong>只是了解，最近学习算法，想实现排序可视化，才发现自己对这方便内容真的是一知半解。</p>\n<p>今天好好查了一下资料，放个阮一峰的链接，但是他没说全，结合本文，可以更好的理解，浏览器中异步的实现。</p>\n<blockquote>\n<p><a href=\"http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html\">Javascript异步编程的4种方法</a></p>\n</blockquote>\n<h3 id=\"JavaScript是单线程的\"><a href=\"#JavaScript是单线程的\" class=\"headerlink\" title=\"JavaScript是单线程的\"></a>JavaScript是单线程的</h3><p>“单线程”，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。</p>","more":"<h3 id=\"浏览器是多线程的\"><a href=\"#浏览器是多线程的\" class=\"headerlink\" title=\"浏览器是多线程的\"></a>浏览器是多线程的</h3><p>浏览器是多线程的，诸如js引擎线程，定时器线程，HTTP请求线程，事件触发线程，js单线程是指只有一条js引擎线程来执行js，所以说无论某个时间js只能干一件事情。</p>\n<h3 id=\"浏览器定时器\"><a href=\"#浏览器定时器\" class=\"headerlink\" title=\"浏览器定时器\"></a>浏览器定时器</h3><p>当调用定时器的时候，浏览器会分配定时器线程来做这件事，什么事？就是在指定时间后将指定函数插入到任务队列的末尾！</p>\n<p>当js线程完成手上正在执行的任务后，就会将任务队列排在首位的任务读取并执行，如此往复。</p>\n<p>这也是为什么有些时候使用setTimeout但却不能在指定时间执行指定函数的原因，因为它前面还有其他任务在排队或者说js引擎线程当前的任务还没执行完毕，那就只能等着了。</p>\n<p>所以所谓的异步都是浏览器实现的。</p>\n<h3 id=\"更多异步实现\"><a href=\"#更多异步实现\" class=\"headerlink\" title=\"更多异步实现\"></a>更多异步实现</h3><p>知道了上面的基础知识，再去看下面的内容，就觉得不那么神秘了。</p>\n<blockquote>\n<blockquote>\n<p><a href=\"http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html\">Javascript异步编程的4种方法</a></p>\n</blockquote>\n</blockquote>"},{"title":"Javascript链表结构的实践","date":"2017-02-20T06:50:12.000Z","_content":"\n\n首先创建一个链表\n```js\n function LinkedList() {\n            let Node = function (ele) {\n                this.ele = ele\n                this.next = null\n            },\n                length = 0, head = null;\n            this.append = function (ele) {\n                var node = new Node(ele), //{1}         \n                    current; //{2} \n                if (head === null) { //列表中第一个节点 //{3}         \n                    head = node;\n                } else {\n                    current = head; //{4} \n                    //循环列表，直到找到最后一项         \n                    while (current.next) {\n                        current = current.next;\n                    }\n                    //找到最后一项，将其next赋为node，建立链接         \n                    current.next = node; //{5}     \n                }\n                length++; //更新列表的长度 //{6} \n            };\n           this.print = function () {\n            var current = head, //{1}         \n                string = '';    //{2} \n\n            while (current) {   //{3}         \n                string += current.ele; //{4}         \n                current = current.next;   //{5}     \n            }\n            return string;                //{6} \n        };\n    }\n    let LinkedList1= new LinkedList();\n    [1,2,3,4,5,6].forEach(function (value) {\n        LinkedList1.append(value)\n    })\n    console.log(LinkedList1.print()); //123456\n```\n<!-- more -->\n\n**问题是链表每一个项存在哪个函数的作用域？如果是append这个函数的作用域，print查找的时候非父级作用域的变量可以读取吗？**\n\n我是这样理解的\n\n**head只保存了链表头，就是第一个项的引用，然后读取当前项的next引用，寻找下一个项，问题是项是在append中创建的，也没有返回，print为什么可以读取append中的项？**\n\n\n然后我打断点\n\n```js\nClosure (LinkedList)\nNode:(ele)\nhead:Node\n        ele:1\n        next:Node\n                ele:2\n                next:Node\n                        ele:3\n                        next:Node\n                                ele:4\n                                next:Node   \n                                        ele:5\n                                        next:Node\n                                                ele:6\n                                                next:null\n                                                __proto__:Object\n                                        __proto__:Object\n                                __proto__:Object\n                        __proto__:Object\n                __proto__:Object\n        __proto__:Object\nlength:5\n\n\n```\n\n可以看出，所有项的引用都是在head变量中的\n\n我们在append的else中的最后一句执行了current.next = node;，这就相当于\n```js\nvar a = {name:'PPP'};\nfunction b(){\n  a.age = 23;\n}\nb()//{name:'PPP',age:23}\n```\n\n类似于这样，并没有返回a，但是a添加了属性同理，我们修改head中一层一层的next指向，因为head是外层作用域的私有变量，所以可以在print中直接获取到\n\nhead是一个头，他的内部保存的引用，或者引用的引用都是head的一部分，这就是一个多层引用，head中保留了所有项的引用\n\n不知道理解的还有没有偏差，想到了再更新\n\n","source":"_posts/LinkedList.md","raw":"---\ntitle: 'Javascript链表结构的实践'\ndate: 2017-02-20 14:50:12\ncategories:\n- Javascript\ntags: \n- JavaScript\n- 数据结构和算法\n---\n\n\n首先创建一个链表\n```js\n function LinkedList() {\n            let Node = function (ele) {\n                this.ele = ele\n                this.next = null\n            },\n                length = 0, head = null;\n            this.append = function (ele) {\n                var node = new Node(ele), //{1}         \n                    current; //{2} \n                if (head === null) { //列表中第一个节点 //{3}         \n                    head = node;\n                } else {\n                    current = head; //{4} \n                    //循环列表，直到找到最后一项         \n                    while (current.next) {\n                        current = current.next;\n                    }\n                    //找到最后一项，将其next赋为node，建立链接         \n                    current.next = node; //{5}     \n                }\n                length++; //更新列表的长度 //{6} \n            };\n           this.print = function () {\n            var current = head, //{1}         \n                string = '';    //{2} \n\n            while (current) {   //{3}         \n                string += current.ele; //{4}         \n                current = current.next;   //{5}     \n            }\n            return string;                //{6} \n        };\n    }\n    let LinkedList1= new LinkedList();\n    [1,2,3,4,5,6].forEach(function (value) {\n        LinkedList1.append(value)\n    })\n    console.log(LinkedList1.print()); //123456\n```\n<!-- more -->\n\n**问题是链表每一个项存在哪个函数的作用域？如果是append这个函数的作用域，print查找的时候非父级作用域的变量可以读取吗？**\n\n我是这样理解的\n\n**head只保存了链表头，就是第一个项的引用，然后读取当前项的next引用，寻找下一个项，问题是项是在append中创建的，也没有返回，print为什么可以读取append中的项？**\n\n\n然后我打断点\n\n```js\nClosure (LinkedList)\nNode:(ele)\nhead:Node\n        ele:1\n        next:Node\n                ele:2\n                next:Node\n                        ele:3\n                        next:Node\n                                ele:4\n                                next:Node   \n                                        ele:5\n                                        next:Node\n                                                ele:6\n                                                next:null\n                                                __proto__:Object\n                                        __proto__:Object\n                                __proto__:Object\n                        __proto__:Object\n                __proto__:Object\n        __proto__:Object\nlength:5\n\n\n```\n\n可以看出，所有项的引用都是在head变量中的\n\n我们在append的else中的最后一句执行了current.next = node;，这就相当于\n```js\nvar a = {name:'PPP'};\nfunction b(){\n  a.age = 23;\n}\nb()//{name:'PPP',age:23}\n```\n\n类似于这样，并没有返回a，但是a添加了属性同理，我们修改head中一层一层的next指向，因为head是外层作用域的私有变量，所以可以在print中直接获取到\n\nhead是一个头，他的内部保存的引用，或者引用的引用都是head的一部分，这就是一个多层引用，head中保留了所有项的引用\n\n不知道理解的还有没有偏差，想到了再更新\n\n","slug":"LinkedList","published":1,"updated":"2017-02-20T06:54:02.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizhru6p20002osqp9fumjz2l","content":"<p>首先创建一个链表<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LinkedList</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">           <span class=\"keyword\">let</span> Node = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ele</span>) </span>&#123;</div><div class=\"line\">               <span class=\"keyword\">this</span>.ele = ele</div><div class=\"line\">               <span class=\"keyword\">this</span>.next = <span class=\"literal\">null</span></div><div class=\"line\">           &#125;,</div><div class=\"line\">               length = <span class=\"number\">0</span>, head = <span class=\"literal\">null</span>;</div><div class=\"line\">           <span class=\"keyword\">this</span>.append = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ele</span>) </span>&#123;</div><div class=\"line\">               <span class=\"keyword\">var</span> node = <span class=\"keyword\">new</span> Node(ele), <span class=\"comment\">//&#123;1&#125;         </span></div><div class=\"line\">                   current; <span class=\"comment\">//&#123;2&#125; </span></div><div class=\"line\">               <span class=\"keyword\">if</span> (head === <span class=\"literal\">null</span>) &#123; <span class=\"comment\">//列表中第一个节点 //&#123;3&#125;         </span></div><div class=\"line\">                   head = node;</div><div class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                   current = head; <span class=\"comment\">//&#123;4&#125; </span></div><div class=\"line\">                   <span class=\"comment\">//循环列表，直到找到最后一项         </span></div><div class=\"line\">                   <span class=\"keyword\">while</span> (current.next) &#123;</div><div class=\"line\">                       current = current.next;</div><div class=\"line\">                   &#125;</div><div class=\"line\">                   <span class=\"comment\">//找到最后一项，将其next赋为node，建立链接         </span></div><div class=\"line\">                   current.next = node; <span class=\"comment\">//&#123;5&#125;     </span></div><div class=\"line\">               &#125;</div><div class=\"line\">               length++; <span class=\"comment\">//更新列表的长度 //&#123;6&#125; </span></div><div class=\"line\">           &#125;;</div><div class=\"line\">          <span class=\"keyword\">this</span>.print = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">           <span class=\"keyword\">var</span> current = head, <span class=\"comment\">//&#123;1&#125;         </span></div><div class=\"line\">               string = <span class=\"string\">''</span>;    <span class=\"comment\">//&#123;2&#125; </span></div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">while</span> (current) &#123;   <span class=\"comment\">//&#123;3&#125;         </span></div><div class=\"line\">               string += current.ele; <span class=\"comment\">//&#123;4&#125;         </span></div><div class=\"line\">               current = current.next;   <span class=\"comment\">//&#123;5&#125;     </span></div><div class=\"line\">           &#125;</div><div class=\"line\">           <span class=\"keyword\">return</span> string;                <span class=\"comment\">//&#123;6&#125; </span></div><div class=\"line\">       &#125;;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">let</span> LinkedList1= <span class=\"keyword\">new</span> LinkedList();</div><div class=\"line\">   [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>].forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">       LinkedList1.append(value)</div><div class=\"line\">   &#125;)</div><div class=\"line\">   <span class=\"built_in\">console</span>.log(LinkedList1.print()); <span class=\"comment\">//123456</span></div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p><strong>问题是链表每一个项存在哪个函数的作用域？如果是append这个函数的作用域，print查找的时候非父级作用域的变量可以读取吗？</strong></p>\n<p>我是这样理解的</p>\n<p><strong>head只保存了链表头，就是第一个项的引用，然后读取当前项的next引用，寻找下一个项，问题是项是在append中创建的，也没有返回，print为什么可以读取append中的项？</strong></p>\n<p>然后我打断点</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">Closure (LinkedList)</div><div class=\"line\">Node:(ele)</div><div class=\"line\">head:Node</div><div class=\"line\">        ele:<span class=\"number\">1</span></div><div class=\"line\">        next:Node</div><div class=\"line\">                ele:<span class=\"number\">2</span></div><div class=\"line\">                next:Node</div><div class=\"line\">                        ele:<span class=\"number\">3</span></div><div class=\"line\">                        next:Node</div><div class=\"line\">                                ele:<span class=\"number\">4</span></div><div class=\"line\">                                next:Node   </div><div class=\"line\">                                        ele:<span class=\"number\">5</span></div><div class=\"line\">                                        next:Node</div><div class=\"line\">                                                ele:<span class=\"number\">6</span></div><div class=\"line\">                                                next:<span class=\"literal\">null</span></div><div class=\"line\">                                                __proto__:<span class=\"built_in\">Object</span></div><div class=\"line\">                                        __proto__:<span class=\"built_in\">Object</span></div><div class=\"line\">                                __proto__:<span class=\"built_in\">Object</span></div><div class=\"line\">                        __proto__:<span class=\"built_in\">Object</span></div><div class=\"line\">                __proto__:<span class=\"built_in\">Object</span></div><div class=\"line\">        __proto__:<span class=\"built_in\">Object</span></div><div class=\"line\">length:<span class=\"number\">5</span></div></pre></td></tr></table></figure>\n<p>可以看出，所有项的引用都是在head变量中的</p>\n<p>我们在append的else中的最后一句执行了current.next = node;，这就相当于<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = &#123;<span class=\"attr\">name</span>:<span class=\"string\">'PPP'</span>&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  a.age = <span class=\"number\">23</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">b()<span class=\"comment\">//&#123;name:'PPP',age:23&#125;</span></div></pre></td></tr></table></figure></p>\n<p>类似于这样，并没有返回a，但是a添加了属性同理，我们修改head中一层一层的next指向，因为head是外层作用域的私有变量，所以可以在print中直接获取到</p>\n<p>head是一个头，他的内部保存的引用，或者引用的引用都是head的一部分，这就是一个多层引用，head中保留了所有项的引用</p>\n<p>不知道理解的还有没有偏差，想到了再更新</p>\n","excerpt":"<p>首先创建一个链表<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LinkedList</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">           <span class=\"keyword\">let</span> Node = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ele</span>) </span>&#123;</div><div class=\"line\">               <span class=\"keyword\">this</span>.ele = ele</div><div class=\"line\">               <span class=\"keyword\">this</span>.next = <span class=\"literal\">null</span></div><div class=\"line\">           &#125;,</div><div class=\"line\">               length = <span class=\"number\">0</span>, head = <span class=\"literal\">null</span>;</div><div class=\"line\">           <span class=\"keyword\">this</span>.append = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ele</span>) </span>&#123;</div><div class=\"line\">               <span class=\"keyword\">var</span> node = <span class=\"keyword\">new</span> Node(ele), <span class=\"comment\">//&#123;1&#125;         </span></div><div class=\"line\">                   current; <span class=\"comment\">//&#123;2&#125; </span></div><div class=\"line\">               <span class=\"keyword\">if</span> (head === <span class=\"literal\">null</span>) &#123; <span class=\"comment\">//列表中第一个节点 //&#123;3&#125;         </span></div><div class=\"line\">                   head = node;</div><div class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                   current = head; <span class=\"comment\">//&#123;4&#125; </span></div><div class=\"line\">                   <span class=\"comment\">//循环列表，直到找到最后一项         </span></div><div class=\"line\">                   <span class=\"keyword\">while</span> (current.next) &#123;</div><div class=\"line\">                       current = current.next;</div><div class=\"line\">                   &#125;</div><div class=\"line\">                   <span class=\"comment\">//找到最后一项，将其next赋为node，建立链接         </span></div><div class=\"line\">                   current.next = node; <span class=\"comment\">//&#123;5&#125;     </span></div><div class=\"line\">               &#125;</div><div class=\"line\">               length++; <span class=\"comment\">//更新列表的长度 //&#123;6&#125; </span></div><div class=\"line\">           &#125;;</div><div class=\"line\">          <span class=\"keyword\">this</span>.print = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">           <span class=\"keyword\">var</span> current = head, <span class=\"comment\">//&#123;1&#125;         </span></div><div class=\"line\">               string = <span class=\"string\">''</span>;    <span class=\"comment\">//&#123;2&#125; </span></div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">while</span> (current) &#123;   <span class=\"comment\">//&#123;3&#125;         </span></div><div class=\"line\">               string += current.ele; <span class=\"comment\">//&#123;4&#125;         </span></div><div class=\"line\">               current = current.next;   <span class=\"comment\">//&#123;5&#125;     </span></div><div class=\"line\">           &#125;</div><div class=\"line\">           <span class=\"keyword\">return</span> string;                <span class=\"comment\">//&#123;6&#125; </span></div><div class=\"line\">       &#125;;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">let</span> LinkedList1= <span class=\"keyword\">new</span> LinkedList();</div><div class=\"line\">   [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>].forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">       LinkedList1.append(value)</div><div class=\"line\">   &#125;)</div><div class=\"line\">   <span class=\"built_in\">console</span>.log(LinkedList1.print()); <span class=\"comment\">//123456</span></div></pre></td></tr></table></figure></p>","more":"<p><strong>问题是链表每一个项存在哪个函数的作用域？如果是append这个函数的作用域，print查找的时候非父级作用域的变量可以读取吗？</strong></p>\n<p>我是这样理解的</p>\n<p><strong>head只保存了链表头，就是第一个项的引用，然后读取当前项的next引用，寻找下一个项，问题是项是在append中创建的，也没有返回，print为什么可以读取append中的项？</strong></p>\n<p>然后我打断点</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">Closure (LinkedList)</div><div class=\"line\">Node:(ele)</div><div class=\"line\">head:Node</div><div class=\"line\">        ele:<span class=\"number\">1</span></div><div class=\"line\">        next:Node</div><div class=\"line\">                ele:<span class=\"number\">2</span></div><div class=\"line\">                next:Node</div><div class=\"line\">                        ele:<span class=\"number\">3</span></div><div class=\"line\">                        next:Node</div><div class=\"line\">                                ele:<span class=\"number\">4</span></div><div class=\"line\">                                next:Node   </div><div class=\"line\">                                        ele:<span class=\"number\">5</span></div><div class=\"line\">                                        next:Node</div><div class=\"line\">                                                ele:<span class=\"number\">6</span></div><div class=\"line\">                                                next:<span class=\"literal\">null</span></div><div class=\"line\">                                                __proto__:<span class=\"built_in\">Object</span></div><div class=\"line\">                                        __proto__:<span class=\"built_in\">Object</span></div><div class=\"line\">                                __proto__:<span class=\"built_in\">Object</span></div><div class=\"line\">                        __proto__:<span class=\"built_in\">Object</span></div><div class=\"line\">                __proto__:<span class=\"built_in\">Object</span></div><div class=\"line\">        __proto__:<span class=\"built_in\">Object</span></div><div class=\"line\">length:<span class=\"number\">5</span></div></pre></td></tr></table></figure>\n<p>可以看出，所有项的引用都是在head变量中的</p>\n<p>我们在append的else中的最后一句执行了current.next = node;，这就相当于<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = &#123;<span class=\"attr\">name</span>:<span class=\"string\">'PPP'</span>&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  a.age = <span class=\"number\">23</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">b()<span class=\"comment\">//&#123;name:'PPP',age:23&#125;</span></div></pre></td></tr></table></figure></p>\n<p>类似于这样，并没有返回a，但是a添加了属性同理，我们修改head中一层一层的next指向，因为head是外层作用域的私有变量，所以可以在print中直接获取到</p>\n<p>head是一个头，他的内部保存的引用，或者引用的引用都是head的一部分，这就是一个多层引用，head中保留了所有项的引用</p>\n<p>不知道理解的还有没有偏差，想到了再更新</p>"},{"title":"LHS/RHS查询——向下一层系列（一）","date":"2017-02-13T08:15:07.000Z","_content":"> 这是向下一层系列第一篇，向下旨在敦促自己向底层靠近，多问why。\n> \n> 由于经验还很少，不对的地方，感谢指正\n\n本人非科班出身，所以刚接触编程的时候会有很多常识性问题，比如\n```js\n\nvar imageArr=[],newData=[];\n\nimageArr=imageArr+newData;\n\n```\n现在看着很正常，但当时想为什么左侧的`imageArr`是赋值，右面是取值，出现在一个表达式是怎么运算的呢。\n\n这里就是JavaScript中的LHS和RHS查询的区别。\n<!-- more -->\n\n**简单来说，赋值运算的左侧会执行LHS查询，右侧则执行RHS查询。**\n\n- LHS是寻找一个容器（地址），用来存放数值。\n- RHS是寻找一个源值，即 “取得某某的值” 。\n\n更重要的是，在很多地方，赋值运算并不是显式的，例如形参\n\n```js\nfunction test(par){\n    alert(par)\n}\n\ntest(22)\n\n```\n最后调用`test()`并传参时，会先进行一次LHS查询，声明一个变量为par，并把22赋值给par；\n`alert(par)`时执行一次RHS查询。\n\n其实在调用`test()`时也是一次RHS查询\n","source":"_posts/LHS-RHS.md","raw":"---\ntitle: 'LHS/RHS查询——向下一层系列（一）'\ndate: 2017-02-13 16:15:07\ncategories:\n- JavaScript\ntags: \n- 向下一层\n- JavaScript\n---\n> 这是向下一层系列第一篇，向下旨在敦促自己向底层靠近，多问why。\n> \n> 由于经验还很少，不对的地方，感谢指正\n\n本人非科班出身，所以刚接触编程的时候会有很多常识性问题，比如\n```js\n\nvar imageArr=[],newData=[];\n\nimageArr=imageArr+newData;\n\n```\n现在看着很正常，但当时想为什么左侧的`imageArr`是赋值，右面是取值，出现在一个表达式是怎么运算的呢。\n\n这里就是JavaScript中的LHS和RHS查询的区别。\n<!-- more -->\n\n**简单来说，赋值运算的左侧会执行LHS查询，右侧则执行RHS查询。**\n\n- LHS是寻找一个容器（地址），用来存放数值。\n- RHS是寻找一个源值，即 “取得某某的值” 。\n\n更重要的是，在很多地方，赋值运算并不是显式的，例如形参\n\n```js\nfunction test(par){\n    alert(par)\n}\n\ntest(22)\n\n```\n最后调用`test()`并传参时，会先进行一次LHS查询，声明一个变量为par，并把22赋值给par；\n`alert(par)`时执行一次RHS查询。\n\n其实在调用`test()`时也是一次RHS查询\n","slug":"LHS-RHS","published":1,"updated":"2017-02-20T06:33:54.187Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizhru6pb0006osqp1h54jj53","content":"<blockquote>\n<p>这是向下一层系列第一篇，向下旨在敦促自己向底层靠近，多问why。</p>\n<p>由于经验还很少，不对的地方，感谢指正</p>\n</blockquote>\n<p>本人非科班出身，所以刚接触编程的时候会有很多常识性问题，比如<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> imageArr=[],newData=[];</div><div class=\"line\"></div><div class=\"line\">imageArr=imageArr+newData;</div></pre></td></tr></table></figure></p>\n<p>现在看着很正常，但当时想为什么左侧的<code>imageArr</code>是赋值，右面是取值，出现在一个表达式是怎么运算的呢。</p>\n<p>这里就是JavaScript中的LHS和RHS查询的区别。<br><a id=\"more\"></a></p>\n<p><strong>简单来说，赋值运算的左侧会执行LHS查询，右侧则执行RHS查询。</strong></p>\n<ul>\n<li>LHS是寻找一个容器（地址），用来存放数值。</li>\n<li>RHS是寻找一个源值，即 “取得某某的值” 。</li>\n</ul>\n<p>更重要的是，在很多地方，赋值运算并不是显式的，例如形参</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">par</span>)</span>&#123;</div><div class=\"line\">    alert(par)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">test(<span class=\"number\">22</span>)</div></pre></td></tr></table></figure>\n<p>最后调用<code>test()</code>并传参时，会先进行一次LHS查询，声明一个变量为par，并把22赋值给par；<br><code>alert(par)</code>时执行一次RHS查询。</p>\n<p>其实在调用<code>test()</code>时也是一次RHS查询</p>\n","excerpt":"<blockquote>\n<p>这是向下一层系列第一篇，向下旨在敦促自己向底层靠近，多问why。</p>\n<p>由于经验还很少，不对的地方，感谢指正</p>\n</blockquote>\n<p>本人非科班出身，所以刚接触编程的时候会有很多常识性问题，比如<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> imageArr=[],newData=[];</div><div class=\"line\"></div><div class=\"line\">imageArr=imageArr+newData;</div></pre></td></tr></table></figure></p>\n<p>现在看着很正常，但当时想为什么左侧的<code>imageArr</code>是赋值，右面是取值，出现在一个表达式是怎么运算的呢。</p>\n<p>这里就是JavaScript中的LHS和RHS查询的区别。<br>","more":"</p>\n<p><strong>简单来说，赋值运算的左侧会执行LHS查询，右侧则执行RHS查询。</strong></p>\n<ul>\n<li>LHS是寻找一个容器（地址），用来存放数值。</li>\n<li>RHS是寻找一个源值，即 “取得某某的值” 。</li>\n</ul>\n<p>更重要的是，在很多地方，赋值运算并不是显式的，例如形参</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">par</span>)</span>&#123;</div><div class=\"line\">    alert(par)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">test(<span class=\"number\">22</span>)</div></pre></td></tr></table></figure>\n<p>最后调用<code>test()</code>并传参时，会先进行一次LHS查询，声明一个变量为par，并把22赋值给par；<br><code>alert(par)</code>时执行一次RHS查询。</p>\n<p>其实在调用<code>test()</code>时也是一次RHS查询</p>"},{"title":"函数式编程入门(阮一峰) -- 转载（一）","date":"2017-02-23T01:38:50.000Z","_content":"看了两遍，很多以前晦涩的地方都明朗了一点，但是更多的还是不懂。转来以后精读。\n\n> [原文链接-函数式编程入门](http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html)\n\n以下为正文\n\n---------------------------------\n\n你可能听说过函数式编程（Functional programming），甚至已经使用了一段时间。\n\n但是，你能说清楚，它到底是什么吗？\n\n网上搜索一下，你会轻松找到好多答案。\n\n<!-- more -->\n\n> - 与面向对象编程（Object-oriented programming）和过程式编程（Procedural programming）并列的编程范式。\n> \n> - 最主要的特征是，函数是第一等公民。\n> \n> - 强调将计算过程分解成可复用的函数，典型例子就是map方法和reduce方法组合而成 MapReduce 算法。\n> \n> - 只有纯的、没有副作用的函数，才是合格的函数。\n\n上面这些说法都对，但还不够，都没有回答下面这个更深层的问题。\n\n\n> - 为什么要这样做？\n\n\n这就是，本文要解答的问题。我会通过最简单的语言，帮你理解函数式编程，并且学会它那些基本写法。\n\n需要声明的是，我不是专家，而是一个初学者，最近两年才真正开始学习函数式编程。一直苦于看不懂各种资料，立志要写一篇清晰易懂的教程。下面的内容肯定不够严密，甚至可能包含错误，但是我发现，像下面这样解释，初学者最容易懂。\n\n另外，本文比较长，阅读时请保持耐心。结尾还有 Udacity 的《前端工程师认证课程》的推广，非常感谢他们对本文的赞助。\n\n## 一、范畴论\n\n函数式编程的起源，是一门叫做范畴论（Category Theory）的数学分支。\n\n理解函数式编程的关键，就是理解范畴论。它是一门很复杂的数学，认为世界上所有的概念体系，都可以抽象成一个个的\"范畴\"（category）。\n\n### 1.1 范畴的概念\n什么是范畴呢？\n\n维基百科的一句话定义如下。\n\n\n> \"范畴就是使用箭头连接的物体。\"（In mathematics, a category is an algebraic structure that comprises \"objects\" that are linked by \"arrows\". ）\n\n\n也就是说，彼此之间存在某种关系的概念、事物、对象等等，都构成\"范畴\"。随便什么东西，只要能找出它们之间的关系，就能定义一个\"范畴\"。\n\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017022210.jpg)\n\n上图中，各个点与它们之间的箭头，就构成一个范畴。\n\n箭头表示范畴成员之间的关系，正式的名称叫做\"态射\"（morphism）。范畴论认为，同一个范畴的所有成员，就是不同状态的\"变形\"（transformation）。通过\"态射\"，一个成员可以变形成另一个成员。\n\n### 1.2 数学模型\n既然\"范畴\"是满足某种变形关系的所有对象，就可以总结出它的数学模型。\n\n\n> - 所有成员是一个集合\n> \n> - 变形关系是函数\n\n也就是说，范畴论是集合论更上层的抽象，简单的理解就是\"集合 + 函数\"。\n\n理论上通过函数，就可以从范畴的一个成员，算出其他所有成员。\n\n### 1.3 范畴与容器\n我们可以把\"范畴\"想象成是一个容器，里面包含两样东西。\n\n\n> - 值（value）\n>\n> - 值的变形关系，也就是函数。\n\n下面我们使用代码，定义一个简单的范畴。\n\n```js\n class Category { \n    constructor(val) {\n     this.val = val; \n } \n    addOne(x) { \n        return x + 1; \n    } \n} \n ```\n上面代码中，`Category`是一个类，也是一个容器，里面包含一个值（`this.val`）和一种变形关系（`addOne`）。你可能已经看出来了，这里的范畴，就是所有彼此之间相差1的数字。\n\n注意，本文后面的部分，凡是提到\"容器\"的地方，全部都是指\"范畴\"。\n\n### 1.4 范畴论与函数式编程的关系\n范畴论使用函数，表达范畴之间的关系。\n\n伴随着范畴论的发展，就发展出一整套函数的运算方法。这套方法起初只用于数学运算，后来有人将它在计算机上实现了，就变成了今天的\"函数式编程\"。\n\n**本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。**\n\n所以，你明白了吗，为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。\n\n总之，在函数式编程中，函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用。\n\n## 二、函数的合成与柯里化\n\n函数式编程有两个最基本的运算：合成和柯里化。\n\n### 2.1 函数的合成\n如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做\"函数的合成\"（compose）。\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017022204.png)\n\n上图中，`X`和`Y`之间的变形关系是函数`f`，`Y`和`Z`之间的变形关系是函数`g`，那么`X`和`Z`之间的关系，就是`g`和`f`的合成函数`g·f`。\n\n下面是合成两个函数的简单代码。\n\n```js\n const compose = function (f, g) { \n    return function (x) {\n        return f(g(x)); \n    }; \n} \n ```\n函数的合成还必须满足结合律。\n\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017022209.png)\n\n```js\n compose(f, compose(g, h)) \n // 等同于 \n compose(compose(f, g), h) \n // 等同于 \n compose(f, g, h) \n ```\n \n合成也是函数必须是纯的一个原因。因为一个不纯的函数，怎么跟其他函数合成？怎么保证各种合成以后，它会达到预期的行为？\n\n前面说过，函数就像数据的管道（pipe）。那么，函数合成就是将这些管道连了起来，让数据一口气从多个管道中穿过。\n\n### 2.2 柯里化\n`f(x)`和`g(x)`合成为`f(g(x))`，有一个隐藏的前提，就是`f`和`g`都只能接受一个参数。如果可以接受多个参数，比如`f(x, y)`和`g(a, b, c)`，函数合成就非常麻烦。\n\n这时就需要函数柯里化了。所谓\"柯里化\"，就是把一个多参数的函数，转化为单参数函数。\n\n```js\n\n // 柯里化之前 \n function add(x, y) { \n    return x + y; \n} \n\n add(1, 2) // 3 \n \n // 柯里化之后 \n function addX(y) {\n    return function (x) { \n        return x + y; \n    }; \n} \n\naddX(2)(1) // 3 \n ```\n \n有了柯里化以后，我们就能做到，所有函数只接受一个参数。后文的内容除非另有说明，都默认函数只有一个参数，就是所要处理的那个值。\n\n## 三、函子\n\n函数不仅可以用于同一个范畴之中值的转换，还可以用于将一个范畴转成另一个范畴。这就涉及到了函子（Functor）。\n\n### 3.1 函子的概念\n函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。\n\n它首先是一种范畴，也就是说，是一个容器，包含了值和变形关系。**比较特殊的是，它的变形关系可以依次作用于每一个值，将当前容器变形成另一个容器。**\n\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017022203.png)\n\n上图中，左侧的圆圈就是一个函子，表示人名的范畴。外部传入函数f，会转成右边表示早餐的范畴。\n\n下面是一张更一般的图。\n\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017022211.jpg)\n\n上图中，函数`f`完成值的转换（`a`到`b`），将它传入函子，就可以实现范畴的转换（`Fa`到`Fb`）。\n\n3.2 函子的代码实现\n任何具有`map`方法的数据结构，都可以当作函子的实现。\n\n```js\n class Functor { \n    constructor(val) { \n        this.val = val; \n    } \n    map(f) { \n        return new Functor(f(this.val));\n    } \n} \n ```\n上面代码中，`Functor`是一个函子，它的`map`方法接受函数f作为参数，然后返回一个新的函子，里面包含的值是被f处理过的（`f(this.val)`）。\n\n一般约定，函子的标志就是容器具有`map`方法。该方法将容器里面的每一个值，映射到另一个容器。\n\n下面是一些用法的示例。\n\n```js\n (new Functor(2)).map(function (two) { \n     return two + 2; \n }); \n// Functor(4) \n\n(new Functor('flamethrowers')).map(function(s) { \n    return s.toUpperCase(); \n}); // Functor('FLAMETHROWERS') \n\n(new Functor('bombs')).map(_.concat(' away')).map(_.prop('length'));\n// Functor(10) \n ```\n上面的例子说明，函数式编程里面的运算，都是通过函子完成，即运算不直接针对值，而是针对这个值的容器----函子。函子本身具有对外接口（`map`方法），各种函数就是运算符，通过接口接入容器，引发容器里面的值的变形。\n\n因此，**学习函数式编程，实际上就是学习函子的各种运算**。由于可以把运算方法封装在函子里面，所以又衍生出各种不同类型的函子，有多少种运算，就有多少种函子。函数式编程就变成了运用不同的函子，解决实际问题。\n\n## 四、of 方法\n\n你可能注意到了，上面生成新的函子的时候，用了`new`命令。这实在太不像函数式编程了，因为`new`命令是面向对象编程的标志。\n\n函数式编程一般约定，函子有一个`of`方法，用来生成新的容器。\n\n下面就用`of`方法替换掉`new`。\n\n```js\n\n Functor.of = function(val) { \n    return new Functor(val); \n}; \n```\n然后，前面的例子就可以改成下面这样。\n\n```js\n\n Functor.of(2).map(function (two) { \n     return two + 2; \n }); \n// Functor(4) \n ```\n这就更像函数式编程了。\n\n## 五、Maybe 函子\n\n函子接受各种函数，处理容器内部的值。这里就有一个问题，容器内部的值可能是一个空值（比如`null`），而外部函数未必有处理空值的机制，如果传入空值，很可能就会出错。\n\n```js\n\n Functor.of(null).map(function (s) { \n     return s.toUpperCase(); \n }); \n// TypeError \n ```\n上面代码中，函子里面的值是`null`，结果小写变成大写的时候就出错了。\n\nMaybe 函子就是为了解决这一类问题而设计的。简单说，它的`map`方法里面设置了空值检查。\n\n```js\n\n class Maybe extends Functor { \n    map(f) { \n        return this.val ? Maybe.of(f(this.val)) : Maybe.of(null); \n    } \n} \n ```\n有了 Maybe 函子，处理空值就不会出错了。\n\n```js\n\n Maybe.of(null).map(function (s) {\n     return s.toUpperCase(); \n }); \n// Maybe(null) \n ```\n## 六、Either 函子\n\n条件运算`if...else`是最常见的运算之一，函数式编程里面，使用 Either 函子表达。\n\nEither 函子内部有两个值：左值（`Left`）和右值（`Right`）。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。\n\n```js\n\n class Either extends Functor { \n    constructor(left, right) { \n        this.left = left; \n        this.right = right; \n    }\n    \n    map(f) { \n        return this.right ? \n            Either.of(this.left, f(this.right)) : \n            Either.of(f(this.left), this.right); \n    } \n} \n\nEither.of = function (left, right) { \n    return new Either(left, right); \n}; \n```\n下面是用法。\n\n```js\n\n var addOne = function (x) { \n    return x + 1;\n}; \n\nEither.of(5, 6).map(addOne); \n// Either(5, 7); \n\nEither.of(1, null).map(addOne); \n// Either(2, null); \n```\n上面代码中，如果右值有值，就使用右值，否则使用左值。通过这种方式，Either 函子表达了条件运算。\n\nEither 函子的常见用途是提供默认值。下面是一个例子。\n\n```js\n\n Either \n .of({address: 'xxx'}, currentUser.address) \n .map(updateField); \n```\n上面代码中，如果用户没有提供地址，Either 函子就会使用左值的默认地址。\n\nEither 函子的另一个用途是代替`try...catch`，使用左值表示错误。\n\n```js\n\n function parseJSON(json) { \n    try { \n        return Either.of(null, JSON.parse(json)); \n    } catch (e: Error) { \n        return Either.of(e, null); \n    } \n} \n```\n上面代码中，左值为空，就表示没有出错，否则左值会包含一个错误对象`e`。一般来说，所有可能出错的运算，都可以返回一个 Either 函子。\n\n七、ap 函子\n\n函子里面包含的值，完全可能是函数。我们可以想象这样一种情况，一个函子的值是数值，另一个函子的值是函数。\n\n```js\n\n function addTwo(x) { \n    return x + 2; \n} \n\nconst A = Functor.of(2); \nconst B = Functor.of(addTwo) \n```\n上面代码中，函子`A`内部的值是`2`，函子`B`内部的值是函数`addTwo`。\n\n有时，我们想让函子`B`内部的函数，可以使用函子`A`内部的值进行运算。这时就需要用到 ap 函子。\n\nap 是 applicative（应用）的缩写。凡是部署了`ap`方法的函子，就是 ap 函子。\n\n```js\n\n class Ap extends Functor { \n    ap(F) { return Ap.of(this.val(F.val)); \n    } \n} \n```\n注意，`ap`方法的参数不是函数，而是另一个函子。\n\n因此，前面例子可以写成下面的形式。\n\n```js\n\n Ap.of(addTwo).ap(Function.of(2)) \n // Ap(4) \n```\nap 函子的意义在于，对于那些多参数的函数，就可以从多个容器之中取值，实现函子的链式操作。\n\n```js\n\n function add(x) { \n    return function (y) { \n        return x + y; }; \n} \n\nAp.of(add).ap(Maybe.of(2)).ap(Maybe.of(3)); \n// Ap(5) \n```\n上面代码中，函数`add`是柯里化以后的形式，一共需要两个参数。通过 ap 函子，我们就可以实现从两个容器之中取值。它还有另外一种写法。\n\n```js\n\n Ap.of(add(2)).ap(Maybe.of(3)); \n```\n## 八、Monad 函子\n\n函子是一个容器，可以包含任何值。函子之中再包含一个函子，也是完全合法的。但是，这样就会出现多层嵌套的函子。\n\n```js\n\nMaybe.of(\n  Maybe.of(\n    Maybe.of({name: 'Mulburry', number: 8402})\n  )\n)\n```\n上面这个函子，一共有三个`Maybe`嵌套。如果要取出内部的值，就要连续取三次`this.val`。这当然很不方便，因此就出现了 Monad 函子。\n\n**Monad 函子的作用是，总是返回一个单层的函子**。它有一个`flatMap`方法，与`map`方法作用相同，唯一的区别是如果生成了一个嵌套函子，它会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。\n\n```js\n\nclass Monad extends Functor {\n  join() {\n    return this.val;\n  }\n  flatMap(f) {\n    return this.map(f).join();\n  }\n}\n```\n上面代码中，如果函数`f`返回的是一个函子，那么`this.map(f)`就会生成一个嵌套的函子。所以，`join`方法保证了`flatMap`方法总是返回一个单层的函子。这意味着嵌套的函子会被铺平（flatten）。\n\n## 九、IO 操作\n\nMonad 函子的重要应用，就是实现 I/O （输入输出）操作。\n\nI/O 是不纯的操作，普通的函数式编程没法做，这时就需要把 IO 操作写成`Monad`函子，通过它来完成。\n\n```js\n\nvar fs = require('fs');\n\nvar readFile = function(filename) {\n  return new IO(function() {\n    return fs.readFileSync(filename, 'utf-8');\n  });\n};\n\nvar print = function(x) {\n  return new IO(function() {\n    console.log(x);\n    return x;\n  });\n}\n```\n\n上面代码中，读取文件和打印本身都是不纯的操作，但是`readFile`和`print`却是纯函数，因为它们总是返回 IO 函子。\n\n如果 IO 函子是一个`Monad`，具有`flatMap`方法，那么我们就可以像下面这样调用这两个函数。\n\n```js\n\n readFile('./user.txt') \n .flatMap(print) \n```\n这就是神奇的地方，上面的代码完成了不纯的操作，但是因为`flatMap`返回的还是一个 IO 函子，所以这个表达式是纯的。我们通过一个纯的表达式，完成带有副作用的操作，这就是 Monad 的作用。\n\n由于返回还是 IO 函子，所以可以实现链式操作。因此，在大多数库里面，`flatMap`方法被改名成`chain`。\n\n```js\n\nvar tail = function(x) {\n  return new IO(function() {\n    return x[x.length - 1];\n  });\n}\n\nreadFile('./user.txt')\n.flatMap(tail)\n.flatMap(print)\n\n// 等同于\nreadFile('./user.txt')\n.chain(tail)\n.chain(print)\n\n```\n\n上面代码读取了文件`user.txt`，然后选取最后一行输出。\n\n## 十、参考链接\n- [JS 函数式编程指南](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/)\n- [Taking Things Out of Context: Functors in JavaScript](http://mattfield.github.io/javascript/2013/07/28/taking-things-out-of-context-functors-in-javascript/)\n- [Functor.js](https://gist.github.com/buzzdecafe/5721205)\n- [Maybe, Either & Try Functors in ES6](https://gist.github.com/rjchatfield/54393388f80f55fcc81a)\n- [Why Category Theory Matters](http://rs.io/why-category-theory-matters/)","source":"_posts/Reproduced1.md","raw":"---\ntitle: 函数式编程入门(阮一峰) -- 转载（一）\ndate: 2017-02-23 09:38:50\ncategories:\n- 转载\ntags: \n- JavaScript\n- 函数式编程\n---\n看了两遍，很多以前晦涩的地方都明朗了一点，但是更多的还是不懂。转来以后精读。\n\n> [原文链接-函数式编程入门](http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html)\n\n以下为正文\n\n---------------------------------\n\n你可能听说过函数式编程（Functional programming），甚至已经使用了一段时间。\n\n但是，你能说清楚，它到底是什么吗？\n\n网上搜索一下，你会轻松找到好多答案。\n\n<!-- more -->\n\n> - 与面向对象编程（Object-oriented programming）和过程式编程（Procedural programming）并列的编程范式。\n> \n> - 最主要的特征是，函数是第一等公民。\n> \n> - 强调将计算过程分解成可复用的函数，典型例子就是map方法和reduce方法组合而成 MapReduce 算法。\n> \n> - 只有纯的、没有副作用的函数，才是合格的函数。\n\n上面这些说法都对，但还不够，都没有回答下面这个更深层的问题。\n\n\n> - 为什么要这样做？\n\n\n这就是，本文要解答的问题。我会通过最简单的语言，帮你理解函数式编程，并且学会它那些基本写法。\n\n需要声明的是，我不是专家，而是一个初学者，最近两年才真正开始学习函数式编程。一直苦于看不懂各种资料，立志要写一篇清晰易懂的教程。下面的内容肯定不够严密，甚至可能包含错误，但是我发现，像下面这样解释，初学者最容易懂。\n\n另外，本文比较长，阅读时请保持耐心。结尾还有 Udacity 的《前端工程师认证课程》的推广，非常感谢他们对本文的赞助。\n\n## 一、范畴论\n\n函数式编程的起源，是一门叫做范畴论（Category Theory）的数学分支。\n\n理解函数式编程的关键，就是理解范畴论。它是一门很复杂的数学，认为世界上所有的概念体系，都可以抽象成一个个的\"范畴\"（category）。\n\n### 1.1 范畴的概念\n什么是范畴呢？\n\n维基百科的一句话定义如下。\n\n\n> \"范畴就是使用箭头连接的物体。\"（In mathematics, a category is an algebraic structure that comprises \"objects\" that are linked by \"arrows\". ）\n\n\n也就是说，彼此之间存在某种关系的概念、事物、对象等等，都构成\"范畴\"。随便什么东西，只要能找出它们之间的关系，就能定义一个\"范畴\"。\n\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017022210.jpg)\n\n上图中，各个点与它们之间的箭头，就构成一个范畴。\n\n箭头表示范畴成员之间的关系，正式的名称叫做\"态射\"（morphism）。范畴论认为，同一个范畴的所有成员，就是不同状态的\"变形\"（transformation）。通过\"态射\"，一个成员可以变形成另一个成员。\n\n### 1.2 数学模型\n既然\"范畴\"是满足某种变形关系的所有对象，就可以总结出它的数学模型。\n\n\n> - 所有成员是一个集合\n> \n> - 变形关系是函数\n\n也就是说，范畴论是集合论更上层的抽象，简单的理解就是\"集合 + 函数\"。\n\n理论上通过函数，就可以从范畴的一个成员，算出其他所有成员。\n\n### 1.3 范畴与容器\n我们可以把\"范畴\"想象成是一个容器，里面包含两样东西。\n\n\n> - 值（value）\n>\n> - 值的变形关系，也就是函数。\n\n下面我们使用代码，定义一个简单的范畴。\n\n```js\n class Category { \n    constructor(val) {\n     this.val = val; \n } \n    addOne(x) { \n        return x + 1; \n    } \n} \n ```\n上面代码中，`Category`是一个类，也是一个容器，里面包含一个值（`this.val`）和一种变形关系（`addOne`）。你可能已经看出来了，这里的范畴，就是所有彼此之间相差1的数字。\n\n注意，本文后面的部分，凡是提到\"容器\"的地方，全部都是指\"范畴\"。\n\n### 1.4 范畴论与函数式编程的关系\n范畴论使用函数，表达范畴之间的关系。\n\n伴随着范畴论的发展，就发展出一整套函数的运算方法。这套方法起初只用于数学运算，后来有人将它在计算机上实现了，就变成了今天的\"函数式编程\"。\n\n**本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。**\n\n所以，你明白了吗，为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。\n\n总之，在函数式编程中，函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用。\n\n## 二、函数的合成与柯里化\n\n函数式编程有两个最基本的运算：合成和柯里化。\n\n### 2.1 函数的合成\n如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做\"函数的合成\"（compose）。\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017022204.png)\n\n上图中，`X`和`Y`之间的变形关系是函数`f`，`Y`和`Z`之间的变形关系是函数`g`，那么`X`和`Z`之间的关系，就是`g`和`f`的合成函数`g·f`。\n\n下面是合成两个函数的简单代码。\n\n```js\n const compose = function (f, g) { \n    return function (x) {\n        return f(g(x)); \n    }; \n} \n ```\n函数的合成还必须满足结合律。\n\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017022209.png)\n\n```js\n compose(f, compose(g, h)) \n // 等同于 \n compose(compose(f, g), h) \n // 等同于 \n compose(f, g, h) \n ```\n \n合成也是函数必须是纯的一个原因。因为一个不纯的函数，怎么跟其他函数合成？怎么保证各种合成以后，它会达到预期的行为？\n\n前面说过，函数就像数据的管道（pipe）。那么，函数合成就是将这些管道连了起来，让数据一口气从多个管道中穿过。\n\n### 2.2 柯里化\n`f(x)`和`g(x)`合成为`f(g(x))`，有一个隐藏的前提，就是`f`和`g`都只能接受一个参数。如果可以接受多个参数，比如`f(x, y)`和`g(a, b, c)`，函数合成就非常麻烦。\n\n这时就需要函数柯里化了。所谓\"柯里化\"，就是把一个多参数的函数，转化为单参数函数。\n\n```js\n\n // 柯里化之前 \n function add(x, y) { \n    return x + y; \n} \n\n add(1, 2) // 3 \n \n // 柯里化之后 \n function addX(y) {\n    return function (x) { \n        return x + y; \n    }; \n} \n\naddX(2)(1) // 3 \n ```\n \n有了柯里化以后，我们就能做到，所有函数只接受一个参数。后文的内容除非另有说明，都默认函数只有一个参数，就是所要处理的那个值。\n\n## 三、函子\n\n函数不仅可以用于同一个范畴之中值的转换，还可以用于将一个范畴转成另一个范畴。这就涉及到了函子（Functor）。\n\n### 3.1 函子的概念\n函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。\n\n它首先是一种范畴，也就是说，是一个容器，包含了值和变形关系。**比较特殊的是，它的变形关系可以依次作用于每一个值，将当前容器变形成另一个容器。**\n\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017022203.png)\n\n上图中，左侧的圆圈就是一个函子，表示人名的范畴。外部传入函数f，会转成右边表示早餐的范畴。\n\n下面是一张更一般的图。\n\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017022211.jpg)\n\n上图中，函数`f`完成值的转换（`a`到`b`），将它传入函子，就可以实现范畴的转换（`Fa`到`Fb`）。\n\n3.2 函子的代码实现\n任何具有`map`方法的数据结构，都可以当作函子的实现。\n\n```js\n class Functor { \n    constructor(val) { \n        this.val = val; \n    } \n    map(f) { \n        return new Functor(f(this.val));\n    } \n} \n ```\n上面代码中，`Functor`是一个函子，它的`map`方法接受函数f作为参数，然后返回一个新的函子，里面包含的值是被f处理过的（`f(this.val)`）。\n\n一般约定，函子的标志就是容器具有`map`方法。该方法将容器里面的每一个值，映射到另一个容器。\n\n下面是一些用法的示例。\n\n```js\n (new Functor(2)).map(function (two) { \n     return two + 2; \n }); \n// Functor(4) \n\n(new Functor('flamethrowers')).map(function(s) { \n    return s.toUpperCase(); \n}); // Functor('FLAMETHROWERS') \n\n(new Functor('bombs')).map(_.concat(' away')).map(_.prop('length'));\n// Functor(10) \n ```\n上面的例子说明，函数式编程里面的运算，都是通过函子完成，即运算不直接针对值，而是针对这个值的容器----函子。函子本身具有对外接口（`map`方法），各种函数就是运算符，通过接口接入容器，引发容器里面的值的变形。\n\n因此，**学习函数式编程，实际上就是学习函子的各种运算**。由于可以把运算方法封装在函子里面，所以又衍生出各种不同类型的函子，有多少种运算，就有多少种函子。函数式编程就变成了运用不同的函子，解决实际问题。\n\n## 四、of 方法\n\n你可能注意到了，上面生成新的函子的时候，用了`new`命令。这实在太不像函数式编程了，因为`new`命令是面向对象编程的标志。\n\n函数式编程一般约定，函子有一个`of`方法，用来生成新的容器。\n\n下面就用`of`方法替换掉`new`。\n\n```js\n\n Functor.of = function(val) { \n    return new Functor(val); \n}; \n```\n然后，前面的例子就可以改成下面这样。\n\n```js\n\n Functor.of(2).map(function (two) { \n     return two + 2; \n }); \n// Functor(4) \n ```\n这就更像函数式编程了。\n\n## 五、Maybe 函子\n\n函子接受各种函数，处理容器内部的值。这里就有一个问题，容器内部的值可能是一个空值（比如`null`），而外部函数未必有处理空值的机制，如果传入空值，很可能就会出错。\n\n```js\n\n Functor.of(null).map(function (s) { \n     return s.toUpperCase(); \n }); \n// TypeError \n ```\n上面代码中，函子里面的值是`null`，结果小写变成大写的时候就出错了。\n\nMaybe 函子就是为了解决这一类问题而设计的。简单说，它的`map`方法里面设置了空值检查。\n\n```js\n\n class Maybe extends Functor { \n    map(f) { \n        return this.val ? Maybe.of(f(this.val)) : Maybe.of(null); \n    } \n} \n ```\n有了 Maybe 函子，处理空值就不会出错了。\n\n```js\n\n Maybe.of(null).map(function (s) {\n     return s.toUpperCase(); \n }); \n// Maybe(null) \n ```\n## 六、Either 函子\n\n条件运算`if...else`是最常见的运算之一，函数式编程里面，使用 Either 函子表达。\n\nEither 函子内部有两个值：左值（`Left`）和右值（`Right`）。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。\n\n```js\n\n class Either extends Functor { \n    constructor(left, right) { \n        this.left = left; \n        this.right = right; \n    }\n    \n    map(f) { \n        return this.right ? \n            Either.of(this.left, f(this.right)) : \n            Either.of(f(this.left), this.right); \n    } \n} \n\nEither.of = function (left, right) { \n    return new Either(left, right); \n}; \n```\n下面是用法。\n\n```js\n\n var addOne = function (x) { \n    return x + 1;\n}; \n\nEither.of(5, 6).map(addOne); \n// Either(5, 7); \n\nEither.of(1, null).map(addOne); \n// Either(2, null); \n```\n上面代码中，如果右值有值，就使用右值，否则使用左值。通过这种方式，Either 函子表达了条件运算。\n\nEither 函子的常见用途是提供默认值。下面是一个例子。\n\n```js\n\n Either \n .of({address: 'xxx'}, currentUser.address) \n .map(updateField); \n```\n上面代码中，如果用户没有提供地址，Either 函子就会使用左值的默认地址。\n\nEither 函子的另一个用途是代替`try...catch`，使用左值表示错误。\n\n```js\n\n function parseJSON(json) { \n    try { \n        return Either.of(null, JSON.parse(json)); \n    } catch (e: Error) { \n        return Either.of(e, null); \n    } \n} \n```\n上面代码中，左值为空，就表示没有出错，否则左值会包含一个错误对象`e`。一般来说，所有可能出错的运算，都可以返回一个 Either 函子。\n\n七、ap 函子\n\n函子里面包含的值，完全可能是函数。我们可以想象这样一种情况，一个函子的值是数值，另一个函子的值是函数。\n\n```js\n\n function addTwo(x) { \n    return x + 2; \n} \n\nconst A = Functor.of(2); \nconst B = Functor.of(addTwo) \n```\n上面代码中，函子`A`内部的值是`2`，函子`B`内部的值是函数`addTwo`。\n\n有时，我们想让函子`B`内部的函数，可以使用函子`A`内部的值进行运算。这时就需要用到 ap 函子。\n\nap 是 applicative（应用）的缩写。凡是部署了`ap`方法的函子，就是 ap 函子。\n\n```js\n\n class Ap extends Functor { \n    ap(F) { return Ap.of(this.val(F.val)); \n    } \n} \n```\n注意，`ap`方法的参数不是函数，而是另一个函子。\n\n因此，前面例子可以写成下面的形式。\n\n```js\n\n Ap.of(addTwo).ap(Function.of(2)) \n // Ap(4) \n```\nap 函子的意义在于，对于那些多参数的函数，就可以从多个容器之中取值，实现函子的链式操作。\n\n```js\n\n function add(x) { \n    return function (y) { \n        return x + y; }; \n} \n\nAp.of(add).ap(Maybe.of(2)).ap(Maybe.of(3)); \n// Ap(5) \n```\n上面代码中，函数`add`是柯里化以后的形式，一共需要两个参数。通过 ap 函子，我们就可以实现从两个容器之中取值。它还有另外一种写法。\n\n```js\n\n Ap.of(add(2)).ap(Maybe.of(3)); \n```\n## 八、Monad 函子\n\n函子是一个容器，可以包含任何值。函子之中再包含一个函子，也是完全合法的。但是，这样就会出现多层嵌套的函子。\n\n```js\n\nMaybe.of(\n  Maybe.of(\n    Maybe.of({name: 'Mulburry', number: 8402})\n  )\n)\n```\n上面这个函子，一共有三个`Maybe`嵌套。如果要取出内部的值，就要连续取三次`this.val`。这当然很不方便，因此就出现了 Monad 函子。\n\n**Monad 函子的作用是，总是返回一个单层的函子**。它有一个`flatMap`方法，与`map`方法作用相同，唯一的区别是如果生成了一个嵌套函子，它会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。\n\n```js\n\nclass Monad extends Functor {\n  join() {\n    return this.val;\n  }\n  flatMap(f) {\n    return this.map(f).join();\n  }\n}\n```\n上面代码中，如果函数`f`返回的是一个函子，那么`this.map(f)`就会生成一个嵌套的函子。所以，`join`方法保证了`flatMap`方法总是返回一个单层的函子。这意味着嵌套的函子会被铺平（flatten）。\n\n## 九、IO 操作\n\nMonad 函子的重要应用，就是实现 I/O （输入输出）操作。\n\nI/O 是不纯的操作，普通的函数式编程没法做，这时就需要把 IO 操作写成`Monad`函子，通过它来完成。\n\n```js\n\nvar fs = require('fs');\n\nvar readFile = function(filename) {\n  return new IO(function() {\n    return fs.readFileSync(filename, 'utf-8');\n  });\n};\n\nvar print = function(x) {\n  return new IO(function() {\n    console.log(x);\n    return x;\n  });\n}\n```\n\n上面代码中，读取文件和打印本身都是不纯的操作，但是`readFile`和`print`却是纯函数，因为它们总是返回 IO 函子。\n\n如果 IO 函子是一个`Monad`，具有`flatMap`方法，那么我们就可以像下面这样调用这两个函数。\n\n```js\n\n readFile('./user.txt') \n .flatMap(print) \n```\n这就是神奇的地方，上面的代码完成了不纯的操作，但是因为`flatMap`返回的还是一个 IO 函子，所以这个表达式是纯的。我们通过一个纯的表达式，完成带有副作用的操作，这就是 Monad 的作用。\n\n由于返回还是 IO 函子，所以可以实现链式操作。因此，在大多数库里面，`flatMap`方法被改名成`chain`。\n\n```js\n\nvar tail = function(x) {\n  return new IO(function() {\n    return x[x.length - 1];\n  });\n}\n\nreadFile('./user.txt')\n.flatMap(tail)\n.flatMap(print)\n\n// 等同于\nreadFile('./user.txt')\n.chain(tail)\n.chain(print)\n\n```\n\n上面代码读取了文件`user.txt`，然后选取最后一行输出。\n\n## 十、参考链接\n- [JS 函数式编程指南](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/)\n- [Taking Things Out of Context: Functors in JavaScript](http://mattfield.github.io/javascript/2013/07/28/taking-things-out-of-context-functors-in-javascript/)\n- [Functor.js](https://gist.github.com/buzzdecafe/5721205)\n- [Maybe, Either & Try Functors in ES6](https://gist.github.com/rjchatfield/54393388f80f55fcc81a)\n- [Why Category Theory Matters](http://rs.io/why-category-theory-matters/)","slug":"Reproduced1","published":1,"updated":"2017-02-23T02:30:14.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizhru6pd0008osqp30brg7yd","content":"<p>看了两遍，很多以前晦涩的地方都明朗了一点，但是更多的还是不懂。转来以后精读。</p>\n<blockquote>\n<p><a href=\"http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html\" target=\"_blank\" rel=\"external\">原文链接-函数式编程入门</a></p>\n</blockquote>\n<p>以下为正文</p>\n<hr>\n<p>你可能听说过函数式编程（Functional programming），甚至已经使用了一段时间。</p>\n<p>但是，你能说清楚，它到底是什么吗？</p>\n<p>网上搜索一下，你会轻松找到好多答案。</p>\n<a id=\"more\"></a>\n<blockquote>\n<ul>\n<li><p>与面向对象编程（Object-oriented programming）和过程式编程（Procedural programming）并列的编程范式。</p>\n</li>\n<li><p>最主要的特征是，函数是第一等公民。</p>\n</li>\n<li><p>强调将计算过程分解成可复用的函数，典型例子就是map方法和reduce方法组合而成 MapReduce 算法。</p>\n</li>\n<li><p>只有纯的、没有副作用的函数，才是合格的函数。</p>\n</li>\n</ul>\n</blockquote>\n<p>上面这些说法都对，但还不够，都没有回答下面这个更深层的问题。</p>\n<blockquote>\n<ul>\n<li>为什么要这样做？</li>\n</ul>\n</blockquote>\n<p>这就是，本文要解答的问题。我会通过最简单的语言，帮你理解函数式编程，并且学会它那些基本写法。</p>\n<p>需要声明的是，我不是专家，而是一个初学者，最近两年才真正开始学习函数式编程。一直苦于看不懂各种资料，立志要写一篇清晰易懂的教程。下面的内容肯定不够严密，甚至可能包含错误，但是我发现，像下面这样解释，初学者最容易懂。</p>\n<p>另外，本文比较长，阅读时请保持耐心。结尾还有 Udacity 的《前端工程师认证课程》的推广，非常感谢他们对本文的赞助。</p>\n<h2 id=\"一、范畴论\"><a href=\"#一、范畴论\" class=\"headerlink\" title=\"一、范畴论\"></a>一、范畴论</h2><p>函数式编程的起源，是一门叫做范畴论（Category Theory）的数学分支。</p>\n<p>理解函数式编程的关键，就是理解范畴论。它是一门很复杂的数学，认为世界上所有的概念体系，都可以抽象成一个个的”范畴”（category）。</p>\n<h3 id=\"1-1-范畴的概念\"><a href=\"#1-1-范畴的概念\" class=\"headerlink\" title=\"1.1 范畴的概念\"></a>1.1 范畴的概念</h3><p>什么是范畴呢？</p>\n<p>维基百科的一句话定义如下。</p>\n<blockquote>\n<p>“范畴就是使用箭头连接的物体。”（In mathematics, a category is an algebraic structure that comprises “objects” that are linked by “arrows”. ）</p>\n</blockquote>\n<p>也就是说，彼此之间存在某种关系的概念、事物、对象等等，都构成”范畴”。随便什么东西，只要能找出它们之间的关系，就能定义一个”范畴”。</p>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017022210.jpg\" alt=\"\"></p>\n<p>上图中，各个点与它们之间的箭头，就构成一个范畴。</p>\n<p>箭头表示范畴成员之间的关系，正式的名称叫做”态射”（morphism）。范畴论认为，同一个范畴的所有成员，就是不同状态的”变形”（transformation）。通过”态射”，一个成员可以变形成另一个成员。</p>\n<h3 id=\"1-2-数学模型\"><a href=\"#1-2-数学模型\" class=\"headerlink\" title=\"1.2 数学模型\"></a>1.2 数学模型</h3><p>既然”范畴”是满足某种变形关系的所有对象，就可以总结出它的数学模型。</p>\n<blockquote>\n<ul>\n<li><p>所有成员是一个集合</p>\n</li>\n<li><p>变形关系是函数</p>\n</li>\n</ul>\n</blockquote>\n<p>也就是说，范畴论是集合论更上层的抽象，简单的理解就是”集合 + 函数”。</p>\n<p>理论上通过函数，就可以从范畴的一个成员，算出其他所有成员。</p>\n<h3 id=\"1-3-范畴与容器\"><a href=\"#1-3-范畴与容器\" class=\"headerlink\" title=\"1.3 范畴与容器\"></a>1.3 范畴与容器</h3><p>我们可以把”范畴”想象成是一个容器，里面包含两样东西。</p>\n<blockquote>\n<ul>\n<li><p>值（value）</p>\n</li>\n<li><p>值的变形关系，也就是函数。</p>\n</li>\n</ul>\n</blockquote>\n<p>下面我们使用代码，定义一个简单的范畴。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Category</span> </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">constructor</span>(val) &#123;</div><div class=\"line\">     <span class=\"keyword\">this</span>.val = val; </div><div class=\"line\"> &#125; </div><div class=\"line\">    addOne(x) &#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> x + <span class=\"number\">1</span>; </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>Category</code>是一个类，也是一个容器，里面包含一个值（<code>this.val</code>）和一种变形关系（<code>addOne</code>）。你可能已经看出来了，这里的范畴，就是所有彼此之间相差1的数字。</p>\n<p>注意，本文后面的部分，凡是提到”容器”的地方，全部都是指”范畴”。</p>\n<h3 id=\"1-4-范畴论与函数式编程的关系\"><a href=\"#1-4-范畴论与函数式编程的关系\" class=\"headerlink\" title=\"1.4 范畴论与函数式编程的关系\"></a>1.4 范畴论与函数式编程的关系</h3><p>范畴论使用函数，表达范畴之间的关系。</p>\n<p>伴随着范畴论的发展，就发展出一整套函数的运算方法。这套方法起初只用于数学运算，后来有人将它在计算机上实现了，就变成了今天的”函数式编程”。</p>\n<p><strong>本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。</strong></p>\n<p>所以，你明白了吗，为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。</p>\n<p>总之，在函数式编程中，函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用。</p>\n<h2 id=\"二、函数的合成与柯里化\"><a href=\"#二、函数的合成与柯里化\" class=\"headerlink\" title=\"二、函数的合成与柯里化\"></a>二、函数的合成与柯里化</h2><p>函数式编程有两个最基本的运算：合成和柯里化。</p>\n<h3 id=\"2-1-函数的合成\"><a href=\"#2-1-函数的合成\" class=\"headerlink\" title=\"2.1 函数的合成\"></a>2.1 函数的合成</h3><p>如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做”函数的合成”（compose）。<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017022204.png\" alt=\"\"></p>\n<p>上图中，<code>X</code>和<code>Y</code>之间的变形关系是函数<code>f</code>，<code>Y</code>和<code>Z</code>之间的变形关系是函数<code>g</code>，那么<code>X</code>和<code>Z</code>之间的关系，就是<code>g</code>和<code>f</code>的合成函数<code>g·f</code>。</p>\n<p>下面是合成两个函数的简单代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">f, g</span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> f(g(x)); </div><div class=\"line\">    &#125;; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>函数的合成还必须满足结合律。</p>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017022209.png\" alt=\"\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">compose(f, compose(g, h)) </div><div class=\"line\"><span class=\"comment\">// 等同于 </span></div><div class=\"line\">compose(compose(f, g), h) </div><div class=\"line\"><span class=\"comment\">// 等同于 </span></div><div class=\"line\">compose(f, g, h)</div></pre></td></tr></table></figure>\n<p>合成也是函数必须是纯的一个原因。因为一个不纯的函数，怎么跟其他函数合成？怎么保证各种合成以后，它会达到预期的行为？</p>\n<p>前面说过，函数就像数据的管道（pipe）。那么，函数合成就是将这些管道连了起来，让数据一口气从多个管道中穿过。</p>\n<h3 id=\"2-2-柯里化\"><a href=\"#2-2-柯里化\" class=\"headerlink\" title=\"2.2 柯里化\"></a>2.2 柯里化</h3><p><code>f(x)</code>和<code>g(x)</code>合成为<code>f(g(x))</code>，有一个隐藏的前提，就是<code>f</code>和<code>g</code>都只能接受一个参数。如果可以接受多个参数，比如<code>f(x, y)</code>和<code>g(a, b, c)</code>，函数合成就非常麻烦。</p>\n<p>这时就需要函数柯里化了。所谓”柯里化”，就是把一个多参数的函数，转化为单参数函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">// 柯里化之前 </span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x, y</span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">return</span> x + y; </div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"> add(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 3 </span></div><div class=\"line\"> </div><div class=\"line\"> <span class=\"comment\">// 柯里化之后 </span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addX</span>(<span class=\"params\">y</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> x + y; </div><div class=\"line\">    &#125;; </div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\">addX(<span class=\"number\">2</span>)(<span class=\"number\">1</span>) <span class=\"comment\">// 3</span></div></pre></td></tr></table></figure>\n<p>有了柯里化以后，我们就能做到，所有函数只接受一个参数。后文的内容除非另有说明，都默认函数只有一个参数，就是所要处理的那个值。</p>\n<h2 id=\"三、函子\"><a href=\"#三、函子\" class=\"headerlink\" title=\"三、函子\"></a>三、函子</h2><p>函数不仅可以用于同一个范畴之中值的转换，还可以用于将一个范畴转成另一个范畴。这就涉及到了函子（Functor）。</p>\n<h3 id=\"3-1-函子的概念\"><a href=\"#3-1-函子的概念\" class=\"headerlink\" title=\"3.1 函子的概念\"></a>3.1 函子的概念</h3><p>函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。</p>\n<p>它首先是一种范畴，也就是说，是一个容器，包含了值和变形关系。<strong>比较特殊的是，它的变形关系可以依次作用于每一个值，将当前容器变形成另一个容器。</strong></p>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017022203.png\" alt=\"\"></p>\n<p>上图中，左侧的圆圈就是一个函子，表示人名的范畴。外部传入函数f，会转成右边表示早餐的范畴。</p>\n<p>下面是一张更一般的图。</p>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017022211.jpg\" alt=\"\"></p>\n<p>上图中，函数<code>f</code>完成值的转换（<code>a</code>到<code>b</code>），将它传入函子，就可以实现范畴的转换（<code>Fa</code>到<code>Fb</code>）。</p>\n<p>3.2 函子的代码实现<br>任何具有<code>map</code>方法的数据结构，都可以当作函子的实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Functor</span> </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">constructor</span>(val) &#123; </div><div class=\"line\">        <span class=\"keyword\">this</span>.val = val; </div><div class=\"line\">    &#125; </div><div class=\"line\">    map(f) &#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Functor(f(<span class=\"keyword\">this</span>.val));</div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>Functor</code>是一个函子，它的<code>map</code>方法接受函数f作为参数，然后返回一个新的函子，里面包含的值是被f处理过的（<code>f(this.val)</code>）。</p>\n<p>一般约定，函子的标志就是容器具有<code>map</code>方法。该方法将容器里面的每一个值，映射到另一个容器。</p>\n<p>下面是一些用法的示例。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> (<span class=\"keyword\">new</span> Functor(<span class=\"number\">2</span>)).map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">two</span>) </span>&#123; </div><div class=\"line\">     <span class=\"keyword\">return</span> two + <span class=\"number\">2</span>; </div><div class=\"line\"> &#125;); </div><div class=\"line\"><span class=\"comment\">// Functor(4) </span></div><div class=\"line\"></div><div class=\"line\">(<span class=\"keyword\">new</span> Functor(<span class=\"string\">'flamethrowers'</span>)).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">return</span> s.toUpperCase(); </div><div class=\"line\">&#125;); <span class=\"comment\">// Functor('FLAMETHROWERS') </span></div><div class=\"line\"></div><div class=\"line\">(<span class=\"keyword\">new</span> Functor(<span class=\"string\">'bombs'</span>)).map(_.concat(<span class=\"string\">' away'</span>)).map(_.prop(<span class=\"string\">'length'</span>));</div><div class=\"line\"><span class=\"comment\">// Functor(10)</span></div></pre></td></tr></table></figure>\n<p>上面的例子说明，函数式编程里面的运算，都是通过函子完成，即运算不直接针对值，而是针对这个值的容器—-函子。函子本身具有对外接口（<code>map</code>方法），各种函数就是运算符，通过接口接入容器，引发容器里面的值的变形。</p>\n<p>因此，<strong>学习函数式编程，实际上就是学习函子的各种运算</strong>。由于可以把运算方法封装在函子里面，所以又衍生出各种不同类型的函子，有多少种运算，就有多少种函子。函数式编程就变成了运用不同的函子，解决实际问题。</p>\n<h2 id=\"四、of-方法\"><a href=\"#四、of-方法\" class=\"headerlink\" title=\"四、of 方法\"></a>四、of 方法</h2><p>你可能注意到了，上面生成新的函子的时候，用了<code>new</code>命令。这实在太不像函数式编程了，因为<code>new</code>命令是面向对象编程的标志。</p>\n<p>函数式编程一般约定，函子有一个<code>of</code>方法，用来生成新的容器。</p>\n<p>下面就用<code>of</code>方法替换掉<code>new</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> Functor.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Functor(val); </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>然后，前面的例子就可以改成下面这样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> Functor.of(<span class=\"number\">2</span>).map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">two</span>) </span>&#123; </div><div class=\"line\">     <span class=\"keyword\">return</span> two + <span class=\"number\">2</span>; </div><div class=\"line\"> &#125;); </div><div class=\"line\"><span class=\"comment\">// Functor(4)</span></div></pre></td></tr></table></figure>\n<p>这就更像函数式编程了。</p>\n<h2 id=\"五、Maybe-函子\"><a href=\"#五、Maybe-函子\" class=\"headerlink\" title=\"五、Maybe 函子\"></a>五、Maybe 函子</h2><p>函子接受各种函数，处理容器内部的值。这里就有一个问题，容器内部的值可能是一个空值（比如<code>null</code>），而外部函数未必有处理空值的机制，如果传入空值，很可能就会出错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> Functor.of(<span class=\"literal\">null</span>).map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123; </div><div class=\"line\">     <span class=\"keyword\">return</span> s.toUpperCase(); </div><div class=\"line\"> &#125;); </div><div class=\"line\"><span class=\"comment\">// TypeError</span></div></pre></td></tr></table></figure>\n<p>上面代码中，函子里面的值是<code>null</code>，结果小写变成大写的时候就出错了。</p>\n<p>Maybe 函子就是为了解决这一类问题而设计的。简单说，它的<code>map</code>方法里面设置了空值检查。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Maybe</span> <span class=\"keyword\">extends</span> <span class=\"title\">Functor</span> </span>&#123; </div><div class=\"line\">    map(f) &#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.val ? Maybe.of(f(<span class=\"keyword\">this</span>.val)) : Maybe.of(<span class=\"literal\">null</span>); </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>有了 Maybe 函子，处理空值就不会出错了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> Maybe.of(<span class=\"literal\">null</span>).map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">return</span> s.toUpperCase(); </div><div class=\"line\"> &#125;); </div><div class=\"line\"><span class=\"comment\">// Maybe(null)</span></div></pre></td></tr></table></figure>\n<h2 id=\"六、Either-函子\"><a href=\"#六、Either-函子\" class=\"headerlink\" title=\"六、Either 函子\"></a>六、Either 函子</h2><p>条件运算<code>if...else</code>是最常见的运算之一，函数式编程里面，使用 Either 函子表达。</p>\n<p>Either 函子内部有两个值：左值（<code>Left</code>）和右值（<code>Right</code>）。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Either</span> <span class=\"keyword\">extends</span> <span class=\"title\">Functor</span> </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">constructor</span>(left, right) &#123; </div><div class=\"line\">        <span class=\"keyword\">this</span>.left = left; </div><div class=\"line\">        <span class=\"keyword\">this</span>.right = right; </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    map(f) &#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.right ? </div><div class=\"line\">            Either.of(<span class=\"keyword\">this</span>.left, f(<span class=\"keyword\">this</span>.right)) : </div><div class=\"line\">            Either.of(f(<span class=\"keyword\">this</span>.left), <span class=\"keyword\">this</span>.right); </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\">Either.of = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">left, right</span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Either(left, right); </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>下面是用法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">var</span> addOne = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">return</span> x + <span class=\"number\">1</span>;</div><div class=\"line\">&#125;; </div><div class=\"line\"></div><div class=\"line\">Either.of(<span class=\"number\">5</span>, <span class=\"number\">6</span>).map(addOne); </div><div class=\"line\"><span class=\"comment\">// Either(5, 7); </span></div><div class=\"line\"></div><div class=\"line\">Either.of(<span class=\"number\">1</span>, <span class=\"literal\">null</span>).map(addOne); </div><div class=\"line\"><span class=\"comment\">// Either(2, null);</span></div></pre></td></tr></table></figure>\n<p>上面代码中，如果右值有值，就使用右值，否则使用左值。通过这种方式，Either 函子表达了条件运算。</p>\n<p>Either 函子的常见用途是提供默认值。下面是一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Either </div><div class=\"line\">.of(&#123;<span class=\"attr\">address</span>: <span class=\"string\">'xxx'</span>&#125;, currentUser.address) </div><div class=\"line\">.map(updateField);</div></pre></td></tr></table></figure>\n<p>上面代码中，如果用户没有提供地址，Either 函子就会使用左值的默认地址。</p>\n<p>Either 函子的另一个用途是代替<code>try...catch</code>，使用左值表示错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseJSON</span>(<span class=\"params\">json</span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">try</span> &#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> Either.of(<span class=\"literal\">null</span>, <span class=\"built_in\">JSON</span>.parse(json)); </div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: <span class=\"built_in\">Error</span>) &#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> Either.of(e, <span class=\"literal\">null</span>); </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，左值为空，就表示没有出错，否则左值会包含一个错误对象<code>e</code>。一般来说，所有可能出错的运算，都可以返回一个 Either 函子。</p>\n<p>七、ap 函子</p>\n<p>函子里面包含的值，完全可能是函数。我们可以想象这样一种情况，一个函子的值是数值，另一个函子的值是函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTwo</span>(<span class=\"params\">x</span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">return</span> x + <span class=\"number\">2</span>; </div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> A = Functor.of(<span class=\"number\">2</span>); </div><div class=\"line\"><span class=\"keyword\">const</span> B = Functor.of(addTwo)</div></pre></td></tr></table></figure>\n<p>上面代码中，函子<code>A</code>内部的值是<code>2</code>，函子<code>B</code>内部的值是函数<code>addTwo</code>。</p>\n<p>有时，我们想让函子<code>B</code>内部的函数，可以使用函子<code>A</code>内部的值进行运算。这时就需要用到 ap 函子。</p>\n<p>ap 是 applicative（应用）的缩写。凡是部署了<code>ap</code>方法的函子，就是 ap 函子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Ap</span> <span class=\"keyword\">extends</span> <span class=\"title\">Functor</span> </span>&#123; </div><div class=\"line\">    ap(F) &#123; <span class=\"keyword\">return</span> Ap.of(<span class=\"keyword\">this</span>.val(F.val)); </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意，<code>ap</code>方法的参数不是函数，而是另一个函子。</p>\n<p>因此，前面例子可以写成下面的形式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Ap.of(addTwo).ap(<span class=\"built_in\">Function</span>.of(<span class=\"number\">2</span>)) </div><div class=\"line\"><span class=\"comment\">// Ap(4)</span></div></pre></td></tr></table></figure>\n<p>ap 函子的意义在于，对于那些多参数的函数，就可以从多个容器之中取值，实现函子的链式操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x</span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">y</span>) </span>&#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> x + y; &#125;; </div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\">Ap.of(add).ap(Maybe.of(<span class=\"number\">2</span>)).ap(Maybe.of(<span class=\"number\">3</span>)); </div><div class=\"line\"><span class=\"comment\">// Ap(5)</span></div></pre></td></tr></table></figure>\n<p>上面代码中，函数<code>add</code>是柯里化以后的形式，一共需要两个参数。通过 ap 函子，我们就可以实现从两个容器之中取值。它还有另外一种写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Ap.of(add(<span class=\"number\">2</span>)).ap(Maybe.of(<span class=\"number\">3</span>));</div></pre></td></tr></table></figure>\n<h2 id=\"八、Monad-函子\"><a href=\"#八、Monad-函子\" class=\"headerlink\" title=\"八、Monad 函子\"></a>八、Monad 函子</h2><p>函子是一个容器，可以包含任何值。函子之中再包含一个函子，也是完全合法的。但是，这样就会出现多层嵌套的函子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Maybe.of(</div><div class=\"line\">  Maybe.of(</div><div class=\"line\">    Maybe.of(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'Mulburry'</span>, <span class=\"attr\">number</span>: <span class=\"number\">8402</span>&#125;)</div><div class=\"line\">  )</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>上面这个函子，一共有三个<code>Maybe</code>嵌套。如果要取出内部的值，就要连续取三次<code>this.val</code>。这当然很不方便，因此就出现了 Monad 函子。</p>\n<p><strong>Monad 函子的作用是，总是返回一个单层的函子</strong>。它有一个<code>flatMap</code>方法，与<code>map</code>方法作用相同，唯一的区别是如果生成了一个嵌套函子，它会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Monad</span> <span class=\"keyword\">extends</span> <span class=\"title\">Functor</span> </span>&#123;</div><div class=\"line\">  join() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.val;</div><div class=\"line\">  &#125;</div><div class=\"line\">  flatMap(f) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.map(f).join();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，如果函数<code>f</code>返回的是一个函子，那么<code>this.map(f)</code>就会生成一个嵌套的函子。所以，<code>join</code>方法保证了<code>flatMap</code>方法总是返回一个单层的函子。这意味着嵌套的函子会被铺平（flatten）。</p>\n<h2 id=\"九、IO-操作\"><a href=\"#九、IO-操作\" class=\"headerlink\" title=\"九、IO 操作\"></a>九、IO 操作</h2><p>Monad 函子的重要应用，就是实现 I/O （输入输出）操作。</p>\n<p>I/O 是不纯的操作，普通的函数式编程没法做，这时就需要把 IO 操作写成<code>Monad</code>函子，通过它来完成。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> readFile = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">filename</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IO(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> fs.readFileSync(filename, <span class=\"string\">'utf-8'</span>);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> print = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IO(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(x);</div><div class=\"line\">    <span class=\"keyword\">return</span> x;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，读取文件和打印本身都是不纯的操作，但是<code>readFile</code>和<code>print</code>却是纯函数，因为它们总是返回 IO 函子。</p>\n<p>如果 IO 函子是一个<code>Monad</code>，具有<code>flatMap</code>方法，那么我们就可以像下面这样调用这两个函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">readFile(<span class=\"string\">'./user.txt'</span>) </div><div class=\"line\">.flatMap(print)</div></pre></td></tr></table></figure>\n<p>这就是神奇的地方，上面的代码完成了不纯的操作，但是因为<code>flatMap</code>返回的还是一个 IO 函子，所以这个表达式是纯的。我们通过一个纯的表达式，完成带有副作用的操作，这就是 Monad 的作用。</p>\n<p>由于返回还是 IO 函子，所以可以实现链式操作。因此，在大多数库里面，<code>flatMap</code>方法被改名成<code>chain</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> tail = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IO(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x[x.length - <span class=\"number\">1</span>];</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">readFile(<span class=\"string\">'./user.txt'</span>)</div><div class=\"line\">.flatMap(tail)</div><div class=\"line\">.flatMap(print)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\">readFile(<span class=\"string\">'./user.txt'</span>)</div><div class=\"line\">.chain(tail)</div><div class=\"line\">.chain(print)</div></pre></td></tr></table></figure>\n<p>上面代码读取了文件<code>user.txt</code>，然后选取最后一行输出。</p>\n<h2 id=\"十、参考链接\"><a href=\"#十、参考链接\" class=\"headerlink\" title=\"十、参考链接\"></a>十、参考链接</h2><ul>\n<li><a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/\" target=\"_blank\" rel=\"external\">JS 函数式编程指南</a></li>\n<li><a href=\"http://mattfield.github.io/javascript/2013/07/28/taking-things-out-of-context-functors-in-javascript/\" target=\"_blank\" rel=\"external\">Taking Things Out of Context: Functors in JavaScript</a></li>\n<li><a href=\"https://gist.github.com/buzzdecafe/5721205\" target=\"_blank\" rel=\"external\">Functor.js</a></li>\n<li><a href=\"https://gist.github.com/rjchatfield/54393388f80f55fcc81a\" target=\"_blank\" rel=\"external\">Maybe, Either &amp; Try Functors in ES6</a></li>\n<li><a href=\"http://rs.io/why-category-theory-matters/\" target=\"_blank\" rel=\"external\">Why Category Theory Matters</a></li>\n</ul>\n","excerpt":"<p>看了两遍，很多以前晦涩的地方都明朗了一点，但是更多的还是不懂。转来以后精读。</p>\n<blockquote>\n<p><a href=\"http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html\">原文链接-函数式编程入门</a></p>\n</blockquote>\n<p>以下为正文</p>\n<hr>\n<p>你可能听说过函数式编程（Functional programming），甚至已经使用了一段时间。</p>\n<p>但是，你能说清楚，它到底是什么吗？</p>\n<p>网上搜索一下，你会轻松找到好多答案。</p>","more":"<blockquote>\n<ul>\n<li><p>与面向对象编程（Object-oriented programming）和过程式编程（Procedural programming）并列的编程范式。</p>\n</li>\n<li><p>最主要的特征是，函数是第一等公民。</p>\n</li>\n<li><p>强调将计算过程分解成可复用的函数，典型例子就是map方法和reduce方法组合而成 MapReduce 算法。</p>\n</li>\n<li><p>只有纯的、没有副作用的函数，才是合格的函数。</p>\n</li>\n</ul>\n</blockquote>\n<p>上面这些说法都对，但还不够，都没有回答下面这个更深层的问题。</p>\n<blockquote>\n<ul>\n<li>为什么要这样做？</li>\n</ul>\n</blockquote>\n<p>这就是，本文要解答的问题。我会通过最简单的语言，帮你理解函数式编程，并且学会它那些基本写法。</p>\n<p>需要声明的是，我不是专家，而是一个初学者，最近两年才真正开始学习函数式编程。一直苦于看不懂各种资料，立志要写一篇清晰易懂的教程。下面的内容肯定不够严密，甚至可能包含错误，但是我发现，像下面这样解释，初学者最容易懂。</p>\n<p>另外，本文比较长，阅读时请保持耐心。结尾还有 Udacity 的《前端工程师认证课程》的推广，非常感谢他们对本文的赞助。</p>\n<h2 id=\"一、范畴论\"><a href=\"#一、范畴论\" class=\"headerlink\" title=\"一、范畴论\"></a>一、范畴论</h2><p>函数式编程的起源，是一门叫做范畴论（Category Theory）的数学分支。</p>\n<p>理解函数式编程的关键，就是理解范畴论。它是一门很复杂的数学，认为世界上所有的概念体系，都可以抽象成一个个的”范畴”（category）。</p>\n<h3 id=\"1-1-范畴的概念\"><a href=\"#1-1-范畴的概念\" class=\"headerlink\" title=\"1.1 范畴的概念\"></a>1.1 范畴的概念</h3><p>什么是范畴呢？</p>\n<p>维基百科的一句话定义如下。</p>\n<blockquote>\n<p>“范畴就是使用箭头连接的物体。”（In mathematics, a category is an algebraic structure that comprises “objects” that are linked by “arrows”. ）</p>\n</blockquote>\n<p>也就是说，彼此之间存在某种关系的概念、事物、对象等等，都构成”范畴”。随便什么东西，只要能找出它们之间的关系，就能定义一个”范畴”。</p>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017022210.jpg\" alt=\"\"></p>\n<p>上图中，各个点与它们之间的箭头，就构成一个范畴。</p>\n<p>箭头表示范畴成员之间的关系，正式的名称叫做”态射”（morphism）。范畴论认为，同一个范畴的所有成员，就是不同状态的”变形”（transformation）。通过”态射”，一个成员可以变形成另一个成员。</p>\n<h3 id=\"1-2-数学模型\"><a href=\"#1-2-数学模型\" class=\"headerlink\" title=\"1.2 数学模型\"></a>1.2 数学模型</h3><p>既然”范畴”是满足某种变形关系的所有对象，就可以总结出它的数学模型。</p>\n<blockquote>\n<ul>\n<li><p>所有成员是一个集合</p>\n</li>\n<li><p>变形关系是函数</p>\n</li>\n</ul>\n</blockquote>\n<p>也就是说，范畴论是集合论更上层的抽象，简单的理解就是”集合 + 函数”。</p>\n<p>理论上通过函数，就可以从范畴的一个成员，算出其他所有成员。</p>\n<h3 id=\"1-3-范畴与容器\"><a href=\"#1-3-范畴与容器\" class=\"headerlink\" title=\"1.3 范畴与容器\"></a>1.3 范畴与容器</h3><p>我们可以把”范畴”想象成是一个容器，里面包含两样东西。</p>\n<blockquote>\n<ul>\n<li><p>值（value）</p>\n</li>\n<li><p>值的变形关系，也就是函数。</p>\n</li>\n</ul>\n</blockquote>\n<p>下面我们使用代码，定义一个简单的范畴。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Category</span> </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">constructor</span>(val) &#123;</div><div class=\"line\">     <span class=\"keyword\">this</span>.val = val; </div><div class=\"line\"> &#125; </div><div class=\"line\">    addOne(x) &#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> x + <span class=\"number\">1</span>; </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>Category</code>是一个类，也是一个容器，里面包含一个值（<code>this.val</code>）和一种变形关系（<code>addOne</code>）。你可能已经看出来了，这里的范畴，就是所有彼此之间相差1的数字。</p>\n<p>注意，本文后面的部分，凡是提到”容器”的地方，全部都是指”范畴”。</p>\n<h3 id=\"1-4-范畴论与函数式编程的关系\"><a href=\"#1-4-范畴论与函数式编程的关系\" class=\"headerlink\" title=\"1.4 范畴论与函数式编程的关系\"></a>1.4 范畴论与函数式编程的关系</h3><p>范畴论使用函数，表达范畴之间的关系。</p>\n<p>伴随着范畴论的发展，就发展出一整套函数的运算方法。这套方法起初只用于数学运算，后来有人将它在计算机上实现了，就变成了今天的”函数式编程”。</p>\n<p><strong>本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。</strong></p>\n<p>所以，你明白了吗，为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。</p>\n<p>总之，在函数式编程中，函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用。</p>\n<h2 id=\"二、函数的合成与柯里化\"><a href=\"#二、函数的合成与柯里化\" class=\"headerlink\" title=\"二、函数的合成与柯里化\"></a>二、函数的合成与柯里化</h2><p>函数式编程有两个最基本的运算：合成和柯里化。</p>\n<h3 id=\"2-1-函数的合成\"><a href=\"#2-1-函数的合成\" class=\"headerlink\" title=\"2.1 函数的合成\"></a>2.1 函数的合成</h3><p>如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做”函数的合成”（compose）。<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017022204.png\" alt=\"\"></p>\n<p>上图中，<code>X</code>和<code>Y</code>之间的变形关系是函数<code>f</code>，<code>Y</code>和<code>Z</code>之间的变形关系是函数<code>g</code>，那么<code>X</code>和<code>Z</code>之间的关系，就是<code>g</code>和<code>f</code>的合成函数<code>g·f</code>。</p>\n<p>下面是合成两个函数的简单代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">f, g</span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> f(g(x)); </div><div class=\"line\">    &#125;; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>函数的合成还必须满足结合律。</p>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017022209.png\" alt=\"\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">compose(f, compose(g, h)) </div><div class=\"line\"><span class=\"comment\">// 等同于 </span></div><div class=\"line\">compose(compose(f, g), h) </div><div class=\"line\"><span class=\"comment\">// 等同于 </span></div><div class=\"line\">compose(f, g, h)</div></pre></td></tr></table></figure>\n<p>合成也是函数必须是纯的一个原因。因为一个不纯的函数，怎么跟其他函数合成？怎么保证各种合成以后，它会达到预期的行为？</p>\n<p>前面说过，函数就像数据的管道（pipe）。那么，函数合成就是将这些管道连了起来，让数据一口气从多个管道中穿过。</p>\n<h3 id=\"2-2-柯里化\"><a href=\"#2-2-柯里化\" class=\"headerlink\" title=\"2.2 柯里化\"></a>2.2 柯里化</h3><p><code>f(x)</code>和<code>g(x)</code>合成为<code>f(g(x))</code>，有一个隐藏的前提，就是<code>f</code>和<code>g</code>都只能接受一个参数。如果可以接受多个参数，比如<code>f(x, y)</code>和<code>g(a, b, c)</code>，函数合成就非常麻烦。</p>\n<p>这时就需要函数柯里化了。所谓”柯里化”，就是把一个多参数的函数，转化为单参数函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">// 柯里化之前 </span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x, y</span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">return</span> x + y; </div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"> add(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 3 </span></div><div class=\"line\"> </div><div class=\"line\"> <span class=\"comment\">// 柯里化之后 </span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addX</span>(<span class=\"params\">y</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> x + y; </div><div class=\"line\">    &#125;; </div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\">addX(<span class=\"number\">2</span>)(<span class=\"number\">1</span>) <span class=\"comment\">// 3</span></div></pre></td></tr></table></figure>\n<p>有了柯里化以后，我们就能做到，所有函数只接受一个参数。后文的内容除非另有说明，都默认函数只有一个参数，就是所要处理的那个值。</p>\n<h2 id=\"三、函子\"><a href=\"#三、函子\" class=\"headerlink\" title=\"三、函子\"></a>三、函子</h2><p>函数不仅可以用于同一个范畴之中值的转换，还可以用于将一个范畴转成另一个范畴。这就涉及到了函子（Functor）。</p>\n<h3 id=\"3-1-函子的概念\"><a href=\"#3-1-函子的概念\" class=\"headerlink\" title=\"3.1 函子的概念\"></a>3.1 函子的概念</h3><p>函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。</p>\n<p>它首先是一种范畴，也就是说，是一个容器，包含了值和变形关系。<strong>比较特殊的是，它的变形关系可以依次作用于每一个值，将当前容器变形成另一个容器。</strong></p>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017022203.png\" alt=\"\"></p>\n<p>上图中，左侧的圆圈就是一个函子，表示人名的范畴。外部传入函数f，会转成右边表示早餐的范畴。</p>\n<p>下面是一张更一般的图。</p>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017022211.jpg\" alt=\"\"></p>\n<p>上图中，函数<code>f</code>完成值的转换（<code>a</code>到<code>b</code>），将它传入函子，就可以实现范畴的转换（<code>Fa</code>到<code>Fb</code>）。</p>\n<p>3.2 函子的代码实现<br>任何具有<code>map</code>方法的数据结构，都可以当作函子的实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Functor</span> </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">constructor</span>(val) &#123; </div><div class=\"line\">        <span class=\"keyword\">this</span>.val = val; </div><div class=\"line\">    &#125; </div><div class=\"line\">    map(f) &#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Functor(f(<span class=\"keyword\">this</span>.val));</div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>Functor</code>是一个函子，它的<code>map</code>方法接受函数f作为参数，然后返回一个新的函子，里面包含的值是被f处理过的（<code>f(this.val)</code>）。</p>\n<p>一般约定，函子的标志就是容器具有<code>map</code>方法。该方法将容器里面的每一个值，映射到另一个容器。</p>\n<p>下面是一些用法的示例。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> (<span class=\"keyword\">new</span> Functor(<span class=\"number\">2</span>)).map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">two</span>) </span>&#123; </div><div class=\"line\">     <span class=\"keyword\">return</span> two + <span class=\"number\">2</span>; </div><div class=\"line\"> &#125;); </div><div class=\"line\"><span class=\"comment\">// Functor(4) </span></div><div class=\"line\"></div><div class=\"line\">(<span class=\"keyword\">new</span> Functor(<span class=\"string\">'flamethrowers'</span>)).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">return</span> s.toUpperCase(); </div><div class=\"line\">&#125;); <span class=\"comment\">// Functor('FLAMETHROWERS') </span></div><div class=\"line\"></div><div class=\"line\">(<span class=\"keyword\">new</span> Functor(<span class=\"string\">'bombs'</span>)).map(_.concat(<span class=\"string\">' away'</span>)).map(_.prop(<span class=\"string\">'length'</span>));</div><div class=\"line\"><span class=\"comment\">// Functor(10)</span></div></pre></td></tr></table></figure>\n<p>上面的例子说明，函数式编程里面的运算，都是通过函子完成，即运算不直接针对值，而是针对这个值的容器—-函子。函子本身具有对外接口（<code>map</code>方法），各种函数就是运算符，通过接口接入容器，引发容器里面的值的变形。</p>\n<p>因此，<strong>学习函数式编程，实际上就是学习函子的各种运算</strong>。由于可以把运算方法封装在函子里面，所以又衍生出各种不同类型的函子，有多少种运算，就有多少种函子。函数式编程就变成了运用不同的函子，解决实际问题。</p>\n<h2 id=\"四、of-方法\"><a href=\"#四、of-方法\" class=\"headerlink\" title=\"四、of 方法\"></a>四、of 方法</h2><p>你可能注意到了，上面生成新的函子的时候，用了<code>new</code>命令。这实在太不像函数式编程了，因为<code>new</code>命令是面向对象编程的标志。</p>\n<p>函数式编程一般约定，函子有一个<code>of</code>方法，用来生成新的容器。</p>\n<p>下面就用<code>of</code>方法替换掉<code>new</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> Functor.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Functor(val); </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>然后，前面的例子就可以改成下面这样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> Functor.of(<span class=\"number\">2</span>).map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">two</span>) </span>&#123; </div><div class=\"line\">     <span class=\"keyword\">return</span> two + <span class=\"number\">2</span>; </div><div class=\"line\"> &#125;); </div><div class=\"line\"><span class=\"comment\">// Functor(4)</span></div></pre></td></tr></table></figure>\n<p>这就更像函数式编程了。</p>\n<h2 id=\"五、Maybe-函子\"><a href=\"#五、Maybe-函子\" class=\"headerlink\" title=\"五、Maybe 函子\"></a>五、Maybe 函子</h2><p>函子接受各种函数，处理容器内部的值。这里就有一个问题，容器内部的值可能是一个空值（比如<code>null</code>），而外部函数未必有处理空值的机制，如果传入空值，很可能就会出错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> Functor.of(<span class=\"literal\">null</span>).map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123; </div><div class=\"line\">     <span class=\"keyword\">return</span> s.toUpperCase(); </div><div class=\"line\"> &#125;); </div><div class=\"line\"><span class=\"comment\">// TypeError</span></div></pre></td></tr></table></figure>\n<p>上面代码中，函子里面的值是<code>null</code>，结果小写变成大写的时候就出错了。</p>\n<p>Maybe 函子就是为了解决这一类问题而设计的。简单说，它的<code>map</code>方法里面设置了空值检查。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Maybe</span> <span class=\"keyword\">extends</span> <span class=\"title\">Functor</span> </span>&#123; </div><div class=\"line\">    map(f) &#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.val ? Maybe.of(f(<span class=\"keyword\">this</span>.val)) : Maybe.of(<span class=\"literal\">null</span>); </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>有了 Maybe 函子，处理空值就不会出错了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> Maybe.of(<span class=\"literal\">null</span>).map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">return</span> s.toUpperCase(); </div><div class=\"line\"> &#125;); </div><div class=\"line\"><span class=\"comment\">// Maybe(null)</span></div></pre></td></tr></table></figure>\n<h2 id=\"六、Either-函子\"><a href=\"#六、Either-函子\" class=\"headerlink\" title=\"六、Either 函子\"></a>六、Either 函子</h2><p>条件运算<code>if...else</code>是最常见的运算之一，函数式编程里面，使用 Either 函子表达。</p>\n<p>Either 函子内部有两个值：左值（<code>Left</code>）和右值（<code>Right</code>）。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Either</span> <span class=\"keyword\">extends</span> <span class=\"title\">Functor</span> </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">constructor</span>(left, right) &#123; </div><div class=\"line\">        <span class=\"keyword\">this</span>.left = left; </div><div class=\"line\">        <span class=\"keyword\">this</span>.right = right; </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    map(f) &#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.right ? </div><div class=\"line\">            Either.of(<span class=\"keyword\">this</span>.left, f(<span class=\"keyword\">this</span>.right)) : </div><div class=\"line\">            Either.of(f(<span class=\"keyword\">this</span>.left), <span class=\"keyword\">this</span>.right); </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\">Either.of = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">left, right</span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Either(left, right); </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>下面是用法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">var</span> addOne = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">return</span> x + <span class=\"number\">1</span>;</div><div class=\"line\">&#125;; </div><div class=\"line\"></div><div class=\"line\">Either.of(<span class=\"number\">5</span>, <span class=\"number\">6</span>).map(addOne); </div><div class=\"line\"><span class=\"comment\">// Either(5, 7); </span></div><div class=\"line\"></div><div class=\"line\">Either.of(<span class=\"number\">1</span>, <span class=\"literal\">null</span>).map(addOne); </div><div class=\"line\"><span class=\"comment\">// Either(2, null);</span></div></pre></td></tr></table></figure>\n<p>上面代码中，如果右值有值，就使用右值，否则使用左值。通过这种方式，Either 函子表达了条件运算。</p>\n<p>Either 函子的常见用途是提供默认值。下面是一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Either </div><div class=\"line\">.of(&#123;<span class=\"attr\">address</span>: <span class=\"string\">'xxx'</span>&#125;, currentUser.address) </div><div class=\"line\">.map(updateField);</div></pre></td></tr></table></figure>\n<p>上面代码中，如果用户没有提供地址，Either 函子就会使用左值的默认地址。</p>\n<p>Either 函子的另一个用途是代替<code>try...catch</code>，使用左值表示错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseJSON</span>(<span class=\"params\">json</span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">try</span> &#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> Either.of(<span class=\"literal\">null</span>, <span class=\"built_in\">JSON</span>.parse(json)); </div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: <span class=\"built_in\">Error</span>) &#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> Either.of(e, <span class=\"literal\">null</span>); </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，左值为空，就表示没有出错，否则左值会包含一个错误对象<code>e</code>。一般来说，所有可能出错的运算，都可以返回一个 Either 函子。</p>\n<p>七、ap 函子</p>\n<p>函子里面包含的值，完全可能是函数。我们可以想象这样一种情况，一个函子的值是数值，另一个函子的值是函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTwo</span>(<span class=\"params\">x</span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">return</span> x + <span class=\"number\">2</span>; </div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> A = Functor.of(<span class=\"number\">2</span>); </div><div class=\"line\"><span class=\"keyword\">const</span> B = Functor.of(addTwo)</div></pre></td></tr></table></figure>\n<p>上面代码中，函子<code>A</code>内部的值是<code>2</code>，函子<code>B</code>内部的值是函数<code>addTwo</code>。</p>\n<p>有时，我们想让函子<code>B</code>内部的函数，可以使用函子<code>A</code>内部的值进行运算。这时就需要用到 ap 函子。</p>\n<p>ap 是 applicative（应用）的缩写。凡是部署了<code>ap</code>方法的函子，就是 ap 函子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Ap</span> <span class=\"keyword\">extends</span> <span class=\"title\">Functor</span> </span>&#123; </div><div class=\"line\">    ap(F) &#123; <span class=\"keyword\">return</span> Ap.of(<span class=\"keyword\">this</span>.val(F.val)); </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意，<code>ap</code>方法的参数不是函数，而是另一个函子。</p>\n<p>因此，前面例子可以写成下面的形式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Ap.of(addTwo).ap(<span class=\"built_in\">Function</span>.of(<span class=\"number\">2</span>)) </div><div class=\"line\"><span class=\"comment\">// Ap(4)</span></div></pre></td></tr></table></figure>\n<p>ap 函子的意义在于，对于那些多参数的函数，就可以从多个容器之中取值，实现函子的链式操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x</span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">y</span>) </span>&#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> x + y; &#125;; </div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\">Ap.of(add).ap(Maybe.of(<span class=\"number\">2</span>)).ap(Maybe.of(<span class=\"number\">3</span>)); </div><div class=\"line\"><span class=\"comment\">// Ap(5)</span></div></pre></td></tr></table></figure>\n<p>上面代码中，函数<code>add</code>是柯里化以后的形式，一共需要两个参数。通过 ap 函子，我们就可以实现从两个容器之中取值。它还有另外一种写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Ap.of(add(<span class=\"number\">2</span>)).ap(Maybe.of(<span class=\"number\">3</span>));</div></pre></td></tr></table></figure>\n<h2 id=\"八、Monad-函子\"><a href=\"#八、Monad-函子\" class=\"headerlink\" title=\"八、Monad 函子\"></a>八、Monad 函子</h2><p>函子是一个容器，可以包含任何值。函子之中再包含一个函子，也是完全合法的。但是，这样就会出现多层嵌套的函子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Maybe.of(</div><div class=\"line\">  Maybe.of(</div><div class=\"line\">    Maybe.of(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'Mulburry'</span>, <span class=\"attr\">number</span>: <span class=\"number\">8402</span>&#125;)</div><div class=\"line\">  )</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>上面这个函子，一共有三个<code>Maybe</code>嵌套。如果要取出内部的值，就要连续取三次<code>this.val</code>。这当然很不方便，因此就出现了 Monad 函子。</p>\n<p><strong>Monad 函子的作用是，总是返回一个单层的函子</strong>。它有一个<code>flatMap</code>方法，与<code>map</code>方法作用相同，唯一的区别是如果生成了一个嵌套函子，它会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Monad</span> <span class=\"keyword\">extends</span> <span class=\"title\">Functor</span> </span>&#123;</div><div class=\"line\">  join() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.val;</div><div class=\"line\">  &#125;</div><div class=\"line\">  flatMap(f) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.map(f).join();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，如果函数<code>f</code>返回的是一个函子，那么<code>this.map(f)</code>就会生成一个嵌套的函子。所以，<code>join</code>方法保证了<code>flatMap</code>方法总是返回一个单层的函子。这意味着嵌套的函子会被铺平（flatten）。</p>\n<h2 id=\"九、IO-操作\"><a href=\"#九、IO-操作\" class=\"headerlink\" title=\"九、IO 操作\"></a>九、IO 操作</h2><p>Monad 函子的重要应用，就是实现 I/O （输入输出）操作。</p>\n<p>I/O 是不纯的操作，普通的函数式编程没法做，这时就需要把 IO 操作写成<code>Monad</code>函子，通过它来完成。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> readFile = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">filename</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IO(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> fs.readFileSync(filename, <span class=\"string\">'utf-8'</span>);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> print = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IO(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(x);</div><div class=\"line\">    <span class=\"keyword\">return</span> x;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，读取文件和打印本身都是不纯的操作，但是<code>readFile</code>和<code>print</code>却是纯函数，因为它们总是返回 IO 函子。</p>\n<p>如果 IO 函子是一个<code>Monad</code>，具有<code>flatMap</code>方法，那么我们就可以像下面这样调用这两个函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">readFile(<span class=\"string\">'./user.txt'</span>) </div><div class=\"line\">.flatMap(print)</div></pre></td></tr></table></figure>\n<p>这就是神奇的地方，上面的代码完成了不纯的操作，但是因为<code>flatMap</code>返回的还是一个 IO 函子，所以这个表达式是纯的。我们通过一个纯的表达式，完成带有副作用的操作，这就是 Monad 的作用。</p>\n<p>由于返回还是 IO 函子，所以可以实现链式操作。因此，在大多数库里面，<code>flatMap</code>方法被改名成<code>chain</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> tail = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IO(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x[x.length - <span class=\"number\">1</span>];</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">readFile(<span class=\"string\">'./user.txt'</span>)</div><div class=\"line\">.flatMap(tail)</div><div class=\"line\">.flatMap(print)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\">readFile(<span class=\"string\">'./user.txt'</span>)</div><div class=\"line\">.chain(tail)</div><div class=\"line\">.chain(print)</div></pre></td></tr></table></figure>\n<p>上面代码读取了文件<code>user.txt</code>，然后选取最后一行输出。</p>\n<h2 id=\"十、参考链接\"><a href=\"#十、参考链接\" class=\"headerlink\" title=\"十、参考链接\"></a>十、参考链接</h2><ul>\n<li><a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/\">JS 函数式编程指南</a></li>\n<li><a href=\"http://mattfield.github.io/javascript/2013/07/28/taking-things-out-of-context-functors-in-javascript/\">Taking Things Out of Context: Functors in JavaScript</a></li>\n<li><a href=\"https://gist.github.com/buzzdecafe/5721205\">Functor.js</a></li>\n<li><a href=\"https://gist.github.com/rjchatfield/54393388f80f55fcc81a\">Maybe, Either &amp; Try Functors in ES6</a></li>\n<li><a href=\"http://rs.io/why-category-theory-matters/\">Why Category Theory Matters</a></li>\n</ul>"},{"title":"hexo使用、二级域名访问及多终端编辑","date":"2016-12-27T18:09:31.000Z","_content":"### hexo部署\n先说一下，如果你GitHub主页原来是有项目的，那千万别直接`hexo d -g`到你的主页所在项目里。\n\n**千万别！千万别！千万别！**\n<!-- more -->\n因为hexo部署是`git push --force`强制提交的，会覆盖掉你原来的项目，包括提交记录，如果你本地仓库也没有了，那是很绝望的。别问我怎么知道的（还好我本地仓库完好，又`git push --force`回去了。\n\n### Next主题\n无论是hexo还是我使用的主题Next的文档都很详尽，特别是Next的文档，所以虽然会踩一些坑，但是也能很快搭建起来。除了有些CSS样式错误，直接在Chrome调试工具定位CSS文件，都能自己改一下。所以直接看文档，有问题也可以留言给我\n\n### 二级域名访问\n我的GitHub主页已经有很多demo页面，我又不想在动这些demo，所以我用hexo的时候想在根项目下建立一个blog目录用于存放博客的静态页面。google了一下发现这样就只能手动`push`public目录到blog。后来发现可以新建一个项目并通过`blog.strongfanfan.top`这种二级域名访问，是不是比`www.strongfanfan.top/blog`逼格稍微高一点。下面我就来说说是怎么实现的。\n#### 1. 个人主页和项目主页\n\n个人主页只能有一个，而项目主页可以有很多个\n\n你的每个项目Settings\\>GitHub Pages\\>Source默认选项是`none`，改为`master branch`，点击`save`就可以通过`yourName.github.com/repoName`访问。\n#### 2. CNAME文件\n   \n   在你的项目根目录下创建CNAME文件，没有文件后缀。内容写上你的二级域名，不带协议，即`http://`，比如我的内容就是`blog.strongfanfan.top`，因为deploy部署可能会删除这个文件，所以最好放在hexo根目录下source文件夹下。\n #### 3. DNS解析\n   \n   最后就是给你的一级域名解析添加一行`CNAME`记录，主机记录为你想要的二级域名字段，比如我的是`blog`，记录值就是你的GitHub主页，比如`strongfanfan.github.io`，保存以后等几分钟就可以通过你的二级域名直接访问你的博客了\n\n---------------------------------------------------\n  \n### Front-matter\n最后贴一些日常写作可能用到的Front-matter，方便以后查找。\n> #### md模板预定义参数\n\n> |参数|描述|默认值|\n>|:---:|:---:|:---:|\n>|  layout|\t布局||\t\n>|title|\t标题||\t\n>|date|\t建立日期|\t文件建立日期\n>|updated\t|更新日期\t|文件更新日期\n>|comments|\t开启文章的评论功能|\ttrue\n>|tags|\t标签（不适用于分页）||\t\n>|categories|\t分类（不适用于分页）||\t\n>|permalink|\t覆盖文章网址| .|\t\n\n>  #### 分类和标签\n\n >只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。\n```md\ncategories:\n- Diary\ntags:\n- PS3\n- Games\n```\n\n--------------------\n更新于2017/1/12\n\n### 多终端编辑\n\n新建一个项目或者在blog项目下新建分支，用于存放博客源码，每次部署完博客网页，`push`一下源码到分支，在公司电脑或者新机器上`clone`下来，执行`npm install`命令就可以同步编辑部署了。\n下次就直接`pull`一下远程仓库的版本就可以了。","source":"_posts/hexo放到子目录并通过二级域名访问.md","raw":"---\ntitle: hexo使用、二级域名访问及多终端编辑\ndate: 2016-12-28 02:09:31\ncategories:\n- hexo\ntags: \n- hexo \n---\n### hexo部署\n先说一下，如果你GitHub主页原来是有项目的，那千万别直接`hexo d -g`到你的主页所在项目里。\n\n**千万别！千万别！千万别！**\n<!-- more -->\n因为hexo部署是`git push --force`强制提交的，会覆盖掉你原来的项目，包括提交记录，如果你本地仓库也没有了，那是很绝望的。别问我怎么知道的（还好我本地仓库完好，又`git push --force`回去了。\n\n### Next主题\n无论是hexo还是我使用的主题Next的文档都很详尽，特别是Next的文档，所以虽然会踩一些坑，但是也能很快搭建起来。除了有些CSS样式错误，直接在Chrome调试工具定位CSS文件，都能自己改一下。所以直接看文档，有问题也可以留言给我\n\n### 二级域名访问\n我的GitHub主页已经有很多demo页面，我又不想在动这些demo，所以我用hexo的时候想在根项目下建立一个blog目录用于存放博客的静态页面。google了一下发现这样就只能手动`push`public目录到blog。后来发现可以新建一个项目并通过`blog.strongfanfan.top`这种二级域名访问，是不是比`www.strongfanfan.top/blog`逼格稍微高一点。下面我就来说说是怎么实现的。\n#### 1. 个人主页和项目主页\n\n个人主页只能有一个，而项目主页可以有很多个\n\n你的每个项目Settings\\>GitHub Pages\\>Source默认选项是`none`，改为`master branch`，点击`save`就可以通过`yourName.github.com/repoName`访问。\n#### 2. CNAME文件\n   \n   在你的项目根目录下创建CNAME文件，没有文件后缀。内容写上你的二级域名，不带协议，即`http://`，比如我的内容就是`blog.strongfanfan.top`，因为deploy部署可能会删除这个文件，所以最好放在hexo根目录下source文件夹下。\n #### 3. DNS解析\n   \n   最后就是给你的一级域名解析添加一行`CNAME`记录，主机记录为你想要的二级域名字段，比如我的是`blog`，记录值就是你的GitHub主页，比如`strongfanfan.github.io`，保存以后等几分钟就可以通过你的二级域名直接访问你的博客了\n\n---------------------------------------------------\n  \n### Front-matter\n最后贴一些日常写作可能用到的Front-matter，方便以后查找。\n> #### md模板预定义参数\n\n> |参数|描述|默认值|\n>|:---:|:---:|:---:|\n>|  layout|\t布局||\t\n>|title|\t标题||\t\n>|date|\t建立日期|\t文件建立日期\n>|updated\t|更新日期\t|文件更新日期\n>|comments|\t开启文章的评论功能|\ttrue\n>|tags|\t标签（不适用于分页）||\t\n>|categories|\t分类（不适用于分页）||\t\n>|permalink|\t覆盖文章网址| .|\t\n\n>  #### 分类和标签\n\n >只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。\n```md\ncategories:\n- Diary\ntags:\n- PS3\n- Games\n```\n\n--------------------\n更新于2017/1/12\n\n### 多终端编辑\n\n新建一个项目或者在blog项目下新建分支，用于存放博客源码，每次部署完博客网页，`push`一下源码到分支，在公司电脑或者新机器上`clone`下来，执行`npm install`命令就可以同步编辑部署了。\n下次就直接`pull`一下远程仓库的版本就可以了。","slug":"hexo放到子目录并通过二级域名访问","published":1,"updated":"2017-02-20T06:33:54.195Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizhru6pg0009osqprscq0z8l","content":"<h3 id=\"hexo部署\"><a href=\"#hexo部署\" class=\"headerlink\" title=\"hexo部署\"></a>hexo部署</h3><p>先说一下，如果你GitHub主页原来是有项目的，那千万别直接<code>hexo d -g</code>到你的主页所在项目里。</p>\n<p><strong>千万别！千万别！千万别！</strong><br><a id=\"more\"></a><br>因为hexo部署是<code>git push --force</code>强制提交的，会覆盖掉你原来的项目，包括提交记录，如果你本地仓库也没有了，那是很绝望的。别问我怎么知道的（还好我本地仓库完好，又<code>git push --force</code>回去了。</p>\n<h3 id=\"Next主题\"><a href=\"#Next主题\" class=\"headerlink\" title=\"Next主题\"></a>Next主题</h3><p>无论是hexo还是我使用的主题Next的文档都很详尽，特别是Next的文档，所以虽然会踩一些坑，但是也能很快搭建起来。除了有些CSS样式错误，直接在Chrome调试工具定位CSS文件，都能自己改一下。所以直接看文档，有问题也可以留言给我</p>\n<h3 id=\"二级域名访问\"><a href=\"#二级域名访问\" class=\"headerlink\" title=\"二级域名访问\"></a>二级域名访问</h3><p>我的GitHub主页已经有很多demo页面，我又不想在动这些demo，所以我用hexo的时候想在根项目下建立一个blog目录用于存放博客的静态页面。google了一下发现这样就只能手动<code>push</code>public目录到blog。后来发现可以新建一个项目并通过<code>blog.strongfanfan.top</code>这种二级域名访问，是不是比<code>www.strongfanfan.top/blog</code>逼格稍微高一点。下面我就来说说是怎么实现的。</p>\n<h4 id=\"1-个人主页和项目主页\"><a href=\"#1-个人主页和项目主页\" class=\"headerlink\" title=\"1. 个人主页和项目主页\"></a>1. 个人主页和项目主页</h4><p>个人主页只能有一个，而项目主页可以有很多个</p>\n<p>你的每个项目Settings>GitHub Pages>Source默认选项是<code>none</code>，改为<code>master branch</code>，点击<code>save</code>就可以通过<code>yourName.github.com/repoName</code>访问。</p>\n<h4 id=\"2-CNAME文件\"><a href=\"#2-CNAME文件\" class=\"headerlink\" title=\"2. CNAME文件\"></a>2. CNAME文件</h4><p>   在你的项目根目录下创建CNAME文件，没有文件后缀。内容写上你的二级域名，不带协议，即<code>http://</code>，比如我的内容就是<code>blog.strongfanfan.top</code>，因为deploy部署可能会删除这个文件，所以最好放在hexo根目录下source文件夹下。</p>\n<h4 id=\"3-DNS解析\"><a href=\"#3-DNS解析\" class=\"headerlink\" title=\"3. DNS解析\"></a>3. DNS解析</h4><p>   最后就是给你的一级域名解析添加一行<code>CNAME</code>记录，主机记录为你想要的二级域名字段，比如我的是<code>blog</code>，记录值就是你的GitHub主页，比如<code>strongfanfan.github.io</code>，保存以后等几分钟就可以通过你的二级域名直接访问你的博客了</p>\n<hr>\n<h3 id=\"Front-matter\"><a href=\"#Front-matter\" class=\"headerlink\" title=\"Front-matter\"></a>Front-matter</h3><p>最后贴一些日常写作可能用到的Front-matter，方便以后查找。</p>\n<blockquote>\n<h4 id=\"md模板预定义参数\"><a href=\"#md模板预定义参数\" class=\"headerlink\" title=\"md模板预定义参数\"></a>md模板预定义参数</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">layout</td>\n<td style=\"text-align:center\">布局</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">title</td>\n<td style=\"text-align:center\">标题</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">date</td>\n<td style=\"text-align:center\">建立日期</td>\n<td style=\"text-align:center\">文件建立日期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">updated</td>\n<td style=\"text-align:center\">更新日期</td>\n<td style=\"text-align:center\">文件更新日期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">comments</td>\n<td style=\"text-align:center\">开启文章的评论功能</td>\n<td style=\"text-align:center\">true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tags</td>\n<td style=\"text-align:center\">标签（不适用于分页）</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">categories</td>\n<td style=\"text-align:center\">分类（不适用于分页）</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">permalink</td>\n<td style=\"text-align:center\">覆盖文章网址</td>\n<td style=\"text-align:center\">.</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"分类和标签\"><a href=\"#分类和标签\" class=\"headerlink\" title=\"分类和标签\"></a>分类和标签</h4><p>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。<br><figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">categories:</div><div class=\"line\"><span class=\"bullet\">- </span>Diary</div><div class=\"line\">tags:</div><div class=\"line\"><span class=\"bullet\">- </span>PS3</div><div class=\"line\"><span class=\"bullet\">- </span>Games</div></pre></td></tr></table></figure></p>\n</blockquote>\n<hr>\n<p>更新于2017/1/12</p>\n<h3 id=\"多终端编辑\"><a href=\"#多终端编辑\" class=\"headerlink\" title=\"多终端编辑\"></a>多终端编辑</h3><p>新建一个项目或者在blog项目下新建分支，用于存放博客源码，每次部署完博客网页，<code>push</code>一下源码到分支，在公司电脑或者新机器上<code>clone</code>下来，执行<code>npm install</code>命令就可以同步编辑部署了。<br>下次就直接<code>pull</code>一下远程仓库的版本就可以了。</p>\n","excerpt":"<h3 id=\"hexo部署\"><a href=\"#hexo部署\" class=\"headerlink\" title=\"hexo部署\"></a>hexo部署</h3><p>先说一下，如果你GitHub主页原来是有项目的，那千万别直接<code>hexo d -g</code>到你的主页所在项目里。</p>\n<p><strong>千万别！千万别！千万别！</strong><br>","more":"<br>因为hexo部署是<code>git push --force</code>强制提交的，会覆盖掉你原来的项目，包括提交记录，如果你本地仓库也没有了，那是很绝望的。别问我怎么知道的（还好我本地仓库完好，又<code>git push --force</code>回去了。</p>\n<h3 id=\"Next主题\"><a href=\"#Next主题\" class=\"headerlink\" title=\"Next主题\"></a>Next主题</h3><p>无论是hexo还是我使用的主题Next的文档都很详尽，特别是Next的文档，所以虽然会踩一些坑，但是也能很快搭建起来。除了有些CSS样式错误，直接在Chrome调试工具定位CSS文件，都能自己改一下。所以直接看文档，有问题也可以留言给我</p>\n<h3 id=\"二级域名访问\"><a href=\"#二级域名访问\" class=\"headerlink\" title=\"二级域名访问\"></a>二级域名访问</h3><p>我的GitHub主页已经有很多demo页面，我又不想在动这些demo，所以我用hexo的时候想在根项目下建立一个blog目录用于存放博客的静态页面。google了一下发现这样就只能手动<code>push</code>public目录到blog。后来发现可以新建一个项目并通过<code>blog.strongfanfan.top</code>这种二级域名访问，是不是比<code>www.strongfanfan.top/blog</code>逼格稍微高一点。下面我就来说说是怎么实现的。</p>\n<h4 id=\"1-个人主页和项目主页\"><a href=\"#1-个人主页和项目主页\" class=\"headerlink\" title=\"1. 个人主页和项目主页\"></a>1. 个人主页和项目主页</h4><p>个人主页只能有一个，而项目主页可以有很多个</p>\n<p>你的每个项目Settings>GitHub Pages>Source默认选项是<code>none</code>，改为<code>master branch</code>，点击<code>save</code>就可以通过<code>yourName.github.com/repoName</code>访问。</p>\n<h4 id=\"2-CNAME文件\"><a href=\"#2-CNAME文件\" class=\"headerlink\" title=\"2. CNAME文件\"></a>2. CNAME文件</h4><p>   在你的项目根目录下创建CNAME文件，没有文件后缀。内容写上你的二级域名，不带协议，即<code>http://</code>，比如我的内容就是<code>blog.strongfanfan.top</code>，因为deploy部署可能会删除这个文件，所以最好放在hexo根目录下source文件夹下。</p>\n<h4 id=\"3-DNS解析\"><a href=\"#3-DNS解析\" class=\"headerlink\" title=\"3. DNS解析\"></a>3. DNS解析</h4><p>   最后就是给你的一级域名解析添加一行<code>CNAME</code>记录，主机记录为你想要的二级域名字段，比如我的是<code>blog</code>，记录值就是你的GitHub主页，比如<code>strongfanfan.github.io</code>，保存以后等几分钟就可以通过你的二级域名直接访问你的博客了</p>\n<hr>\n<h3 id=\"Front-matter\"><a href=\"#Front-matter\" class=\"headerlink\" title=\"Front-matter\"></a>Front-matter</h3><p>最后贴一些日常写作可能用到的Front-matter，方便以后查找。</p>\n<blockquote>\n<h4 id=\"md模板预定义参数\"><a href=\"#md模板预定义参数\" class=\"headerlink\" title=\"md模板预定义参数\"></a>md模板预定义参数</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">layout</td>\n<td style=\"text-align:center\">布局</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">title</td>\n<td style=\"text-align:center\">标题</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">date</td>\n<td style=\"text-align:center\">建立日期</td>\n<td style=\"text-align:center\">文件建立日期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">updated</td>\n<td style=\"text-align:center\">更新日期</td>\n<td style=\"text-align:center\">文件更新日期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">comments</td>\n<td style=\"text-align:center\">开启文章的评论功能</td>\n<td style=\"text-align:center\">true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tags</td>\n<td style=\"text-align:center\">标签（不适用于分页）</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">categories</td>\n<td style=\"text-align:center\">分类（不适用于分页）</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">permalink</td>\n<td style=\"text-align:center\">覆盖文章网址</td>\n<td style=\"text-align:center\">.</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"分类和标签\"><a href=\"#分类和标签\" class=\"headerlink\" title=\"分类和标签\"></a>分类和标签</h4><p>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。<br><figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">categories:</div><div class=\"line\"><span class=\"bullet\">- </span>Diary</div><div class=\"line\">tags:</div><div class=\"line\"><span class=\"bullet\">- </span>PS3</div><div class=\"line\"><span class=\"bullet\">- </span>Games</div></pre></td></tr></table></figure></p>\n</blockquote>\n<hr>\n<p>更新于2017/1/12</p>\n<h3 id=\"多终端编辑\"><a href=\"#多终端编辑\" class=\"headerlink\" title=\"多终端编辑\"></a>多终端编辑</h3><p>新建一个项目或者在blog项目下新建分支，用于存放博客源码，每次部署完博客网页，<code>push</code>一下源码到分支，在公司电脑或者新机器上<code>clone</code>下来，执行<code>npm install</code>命令就可以同步编辑部署了。<br>下次就直接<code>pull</code>一下远程仓库的版本就可以了。</p>"},{"title":"npm插件开发之旅","date":"2017-01-31T07:28:07.000Z","_content":"### npm插件\n\n刚开始学习node，年前试着写了一个插件，主要是熟悉AMD，require模块化，node的http模块及npm插件的开发流程。\n\n插件本身用了http模块请求数据，并且引入一个转码模块对输入进行转码，然后对res进行简单处理。\n\n\n然后复盘一下用到的知识点和遇到的坑。\n<!-- more -->\n\n### `require`、`exports`、`module`\n#### `require`的路径写法\n\n`require`函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者是绝对路径（以/或C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略。以下是一个例子。\n```js\nvar foo1 = require('./foo');\nvar foo2 = require('./foo.js');\nvar foo3 = require('/home/user/foo');\nvar foo4 = require('/home/user/foo.js');\n\n// foo1至foo4中保存的是同一个模块的导出对象。\n```\n\n#### exports\nexports对象是当前模块的导出对象，用于导出模块公有方法和属性。别的模块通过require函数使用当前模块时得到的就是当前模块的exports对象。以下例子中导出了一个公有方法。\n```js\nexports.hello = function () {\n    console.log('Hello World!');\n};\n```\n#### module\n\n通过module对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。例如模块导出对象默认是一个普通对象，如果想改成一个函数的话，可以使用以下方式。\n```js\nmodule.exports = function () {\n    console.log('Hello World!');\n};\n```\n\n以上代码中，模块默认导出对象被替换为一个函数。\n\n\n### 插件的工程目录结构\n```\n- /home/user/workspace/node-echo/   # 工程目录\n    - bin/                          # 存放命令行相关代码\n        node-echo\n    + doc/                          # 存放文档\n    - lib/                          # 存放API相关代码\n        echo.js\n    - node_modules/                 # 存放三方包\n        + argv/\n    + tests/                        # 存放测试用例\n    package.json                    # 元数据文件\n    README.md                       # 说明文件\n```\n### 添加package.json的bin字段\n```\n \"bin\": {\n    \"hi\": \"./bin/hi.js\"\n  },\n```\n这样`npm install -g`安装后会自动生成`.cmd`文件\n\n### URLencode编码\n\n测试接口的时候一直报下面的错误\n```\n{\n\t\"reason\":\"info参数错误\",\n\t\"result\":null,\n\t\"error_code\":211201\n}\n```\n仔细看了API文档以后，发现接口不能接受中文字符，需要进行转码，然而并不知道要使用哪种转码方式，经过吐血的测试以后，终于确定是URLencode转码。封装成一个`urlencode`模块\n```js\nvar urlencode = require('urlencode');\n```\n\n\n### 在npm发布\n\n如果报错是这样\n```\nno_perms Private mode enable, only admin can publish this module\n```\n使用下面代码重置npm镜像\n```\nnpm config set registry http://registry.npmjs.org\n```\n\n### 最后一个坑\n\n本地测试正常，npm发布后再`npm install -g`安装执行就报错\n```\n command not found\n```\n着实纠结好久，最后试着是在入口文件中加\n`#!/usr/bin/env node`\n\n虽然可以了，但是原理不太理解，`#!/usr/bin/env node`是Linux系统下，在shell脚本中，通过#!注释来指定当前脚本使用的解析器。\n\n\n### 参考文章\n\n> [npm插件开发流程](https://my.oschina.net/ubuntuvim/blog/540494)\n\n> [七天学会NodeJS](https://nqdeng.github.io/7-days-nodejs/)","source":"_posts/npm插件开发之旅.md","raw":"---\ntitle: 'npm插件开发之旅'\ndate: 2017-01-31 15:28:07\ncategories:\n- node\ntags:\n- npm\n- node\n- JavaScript\n---\n### npm插件\n\n刚开始学习node，年前试着写了一个插件，主要是熟悉AMD，require模块化，node的http模块及npm插件的开发流程。\n\n插件本身用了http模块请求数据，并且引入一个转码模块对输入进行转码，然后对res进行简单处理。\n\n\n然后复盘一下用到的知识点和遇到的坑。\n<!-- more -->\n\n### `require`、`exports`、`module`\n#### `require`的路径写法\n\n`require`函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者是绝对路径（以/或C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略。以下是一个例子。\n```js\nvar foo1 = require('./foo');\nvar foo2 = require('./foo.js');\nvar foo3 = require('/home/user/foo');\nvar foo4 = require('/home/user/foo.js');\n\n// foo1至foo4中保存的是同一个模块的导出对象。\n```\n\n#### exports\nexports对象是当前模块的导出对象，用于导出模块公有方法和属性。别的模块通过require函数使用当前模块时得到的就是当前模块的exports对象。以下例子中导出了一个公有方法。\n```js\nexports.hello = function () {\n    console.log('Hello World!');\n};\n```\n#### module\n\n通过module对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。例如模块导出对象默认是一个普通对象，如果想改成一个函数的话，可以使用以下方式。\n```js\nmodule.exports = function () {\n    console.log('Hello World!');\n};\n```\n\n以上代码中，模块默认导出对象被替换为一个函数。\n\n\n### 插件的工程目录结构\n```\n- /home/user/workspace/node-echo/   # 工程目录\n    - bin/                          # 存放命令行相关代码\n        node-echo\n    + doc/                          # 存放文档\n    - lib/                          # 存放API相关代码\n        echo.js\n    - node_modules/                 # 存放三方包\n        + argv/\n    + tests/                        # 存放测试用例\n    package.json                    # 元数据文件\n    README.md                       # 说明文件\n```\n### 添加package.json的bin字段\n```\n \"bin\": {\n    \"hi\": \"./bin/hi.js\"\n  },\n```\n这样`npm install -g`安装后会自动生成`.cmd`文件\n\n### URLencode编码\n\n测试接口的时候一直报下面的错误\n```\n{\n\t\"reason\":\"info参数错误\",\n\t\"result\":null,\n\t\"error_code\":211201\n}\n```\n仔细看了API文档以后，发现接口不能接受中文字符，需要进行转码，然而并不知道要使用哪种转码方式，经过吐血的测试以后，终于确定是URLencode转码。封装成一个`urlencode`模块\n```js\nvar urlencode = require('urlencode');\n```\n\n\n### 在npm发布\n\n如果报错是这样\n```\nno_perms Private mode enable, only admin can publish this module\n```\n使用下面代码重置npm镜像\n```\nnpm config set registry http://registry.npmjs.org\n```\n\n### 最后一个坑\n\n本地测试正常，npm发布后再`npm install -g`安装执行就报错\n```\n command not found\n```\n着实纠结好久，最后试着是在入口文件中加\n`#!/usr/bin/env node`\n\n虽然可以了，但是原理不太理解，`#!/usr/bin/env node`是Linux系统下，在shell脚本中，通过#!注释来指定当前脚本使用的解析器。\n\n\n### 参考文章\n\n> [npm插件开发流程](https://my.oschina.net/ubuntuvim/blog/540494)\n\n> [七天学会NodeJS](https://nqdeng.github.io/7-days-nodejs/)","slug":"npm插件开发之旅","published":1,"updated":"2017-02-20T06:33:54.199Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizhru6pj000cosqpbeu4g9rg","content":"<h3 id=\"npm插件\"><a href=\"#npm插件\" class=\"headerlink\" title=\"npm插件\"></a>npm插件</h3><p>刚开始学习node，年前试着写了一个插件，主要是熟悉AMD，require模块化，node的http模块及npm插件的开发流程。</p>\n<p>插件本身用了http模块请求数据，并且引入一个转码模块对输入进行转码，然后对res进行简单处理。</p>\n<p>然后复盘一下用到的知识点和遇到的坑。<br><a id=\"more\"></a></p>\n<h3 id=\"require、exports、module\"><a href=\"#require、exports、module\" class=\"headerlink\" title=\"require、exports、module\"></a><code>require</code>、<code>exports</code>、<code>module</code></h3><h4 id=\"require的路径写法\"><a href=\"#require的路径写法\" class=\"headerlink\" title=\"require的路径写法\"></a><code>require</code>的路径写法</h4><p><code>require</code>函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者是绝对路径（以/或C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略。以下是一个例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> foo1 = <span class=\"built_in\">require</span>(<span class=\"string\">'./foo'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> foo2 = <span class=\"built_in\">require</span>(<span class=\"string\">'./foo.js'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> foo3 = <span class=\"built_in\">require</span>(<span class=\"string\">'/home/user/foo'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> foo4 = <span class=\"built_in\">require</span>(<span class=\"string\">'/home/user/foo.js'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// foo1至foo4中保存的是同一个模块的导出对象。</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"exports\"><a href=\"#exports\" class=\"headerlink\" title=\"exports\"></a>exports</h4><p>exports对象是当前模块的导出对象，用于导出模块公有方法和属性。别的模块通过require函数使用当前模块时得到的就是当前模块的exports对象。以下例子中导出了一个公有方法。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">exports.hello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello World!'</span>);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h4 id=\"module\"><a href=\"#module\" class=\"headerlink\" title=\"module\"></a>module</h4><p>通过module对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。例如模块导出对象默认是一个普通对象，如果想改成一个函数的话，可以使用以下方式。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello World!'</span>);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>以上代码中，模块默认导出对象被替换为一个函数。</p>\n<h3 id=\"插件的工程目录结构\"><a href=\"#插件的工程目录结构\" class=\"headerlink\" title=\"插件的工程目录结构\"></a>插件的工程目录结构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- /home/user/workspace/node-echo/   # 工程目录</div><div class=\"line\">    - bin/                          # 存放命令行相关代码</div><div class=\"line\">        node-echo</div><div class=\"line\">    + doc/                          # 存放文档</div><div class=\"line\">    - lib/                          # 存放API相关代码</div><div class=\"line\">        echo.js</div><div class=\"line\">    - node_modules/                 # 存放三方包</div><div class=\"line\">        + argv/</div><div class=\"line\">    + tests/                        # 存放测试用例</div><div class=\"line\">    package.json                    # 元数据文件</div><div class=\"line\">    README.md                       # 说明文件</div></pre></td></tr></table></figure>\n<h3 id=\"添加package-json的bin字段\"><a href=\"#添加package-json的bin字段\" class=\"headerlink\" title=\"添加package.json的bin字段\"></a>添加package.json的bin字段</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;bin&quot;: &#123;</div><div class=\"line\">   &quot;hi&quot;: &quot;./bin/hi.js&quot;</div><div class=\"line\"> &#125;,</div></pre></td></tr></table></figure>\n<p>这样<code>npm install -g</code>安装后会自动生成<code>.cmd</code>文件</p>\n<h3 id=\"URLencode编码\"><a href=\"#URLencode编码\" class=\"headerlink\" title=\"URLencode编码\"></a>URLencode编码</h3><p>测试接口的时候一直报下面的错误<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t&quot;reason&quot;:&quot;info参数错误&quot;,</div><div class=\"line\">\t&quot;result&quot;:null,</div><div class=\"line\">\t&quot;error_code&quot;:211201</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>仔细看了API文档以后，发现接口不能接受中文字符，需要进行转码，然而并不知道要使用哪种转码方式，经过吐血的测试以后，终于确定是URLencode转码。封装成一个<code>urlencode</code>模块<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> urlencode = <span class=\"built_in\">require</span>(<span class=\"string\">'urlencode'</span>);</div></pre></td></tr></table></figure></p>\n<h3 id=\"在npm发布\"><a href=\"#在npm发布\" class=\"headerlink\" title=\"在npm发布\"></a>在npm发布</h3><p>如果报错是这样<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">no_perms Private mode enable, only admin can publish this module</div></pre></td></tr></table></figure></p>\n<p>使用下面代码重置npm镜像<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm config set registry http://registry.npmjs.org</div></pre></td></tr></table></figure></p>\n<h3 id=\"最后一个坑\"><a href=\"#最后一个坑\" class=\"headerlink\" title=\"最后一个坑\"></a>最后一个坑</h3><p>本地测试正常，npm发布后再<code>npm install -g</code>安装执行就报错<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">command not found</div></pre></td></tr></table></figure></p>\n<p>着实纠结好久，最后试着是在入口文件中加<br><code>#!/usr/bin/env node</code></p>\n<p>虽然可以了，但是原理不太理解，<code>#!/usr/bin/env node</code>是Linux系统下，在shell脚本中，通过#!注释来指定当前脚本使用的解析器。</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><blockquote>\n<p><a href=\"https://my.oschina.net/ubuntuvim/blog/540494\" target=\"_blank\" rel=\"external\">npm插件开发流程</a></p>\n<p><a href=\"https://nqdeng.github.io/7-days-nodejs/\" target=\"_blank\" rel=\"external\">七天学会NodeJS</a></p>\n</blockquote>\n","excerpt":"<h3 id=\"npm插件\"><a href=\"#npm插件\" class=\"headerlink\" title=\"npm插件\"></a>npm插件</h3><p>刚开始学习node，年前试着写了一个插件，主要是熟悉AMD，require模块化，node的http模块及npm插件的开发流程。</p>\n<p>插件本身用了http模块请求数据，并且引入一个转码模块对输入进行转码，然后对res进行简单处理。</p>\n<p>然后复盘一下用到的知识点和遇到的坑。<br>","more":"</p>\n<h3 id=\"require、exports、module\"><a href=\"#require、exports、module\" class=\"headerlink\" title=\"require、exports、module\"></a><code>require</code>、<code>exports</code>、<code>module</code></h3><h4 id=\"require的路径写法\"><a href=\"#require的路径写法\" class=\"headerlink\" title=\"require的路径写法\"></a><code>require</code>的路径写法</h4><p><code>require</code>函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者是绝对路径（以/或C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略。以下是一个例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> foo1 = <span class=\"built_in\">require</span>(<span class=\"string\">'./foo'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> foo2 = <span class=\"built_in\">require</span>(<span class=\"string\">'./foo.js'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> foo3 = <span class=\"built_in\">require</span>(<span class=\"string\">'/home/user/foo'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> foo4 = <span class=\"built_in\">require</span>(<span class=\"string\">'/home/user/foo.js'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// foo1至foo4中保存的是同一个模块的导出对象。</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"exports\"><a href=\"#exports\" class=\"headerlink\" title=\"exports\"></a>exports</h4><p>exports对象是当前模块的导出对象，用于导出模块公有方法和属性。别的模块通过require函数使用当前模块时得到的就是当前模块的exports对象。以下例子中导出了一个公有方法。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">exports.hello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello World!'</span>);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h4 id=\"module\"><a href=\"#module\" class=\"headerlink\" title=\"module\"></a>module</h4><p>通过module对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。例如模块导出对象默认是一个普通对象，如果想改成一个函数的话，可以使用以下方式。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello World!'</span>);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>以上代码中，模块默认导出对象被替换为一个函数。</p>\n<h3 id=\"插件的工程目录结构\"><a href=\"#插件的工程目录结构\" class=\"headerlink\" title=\"插件的工程目录结构\"></a>插件的工程目录结构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- /home/user/workspace/node-echo/   # 工程目录</div><div class=\"line\">    - bin/                          # 存放命令行相关代码</div><div class=\"line\">        node-echo</div><div class=\"line\">    + doc/                          # 存放文档</div><div class=\"line\">    - lib/                          # 存放API相关代码</div><div class=\"line\">        echo.js</div><div class=\"line\">    - node_modules/                 # 存放三方包</div><div class=\"line\">        + argv/</div><div class=\"line\">    + tests/                        # 存放测试用例</div><div class=\"line\">    package.json                    # 元数据文件</div><div class=\"line\">    README.md                       # 说明文件</div></pre></td></tr></table></figure>\n<h3 id=\"添加package-json的bin字段\"><a href=\"#添加package-json的bin字段\" class=\"headerlink\" title=\"添加package.json的bin字段\"></a>添加package.json的bin字段</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;bin&quot;: &#123;</div><div class=\"line\">   &quot;hi&quot;: &quot;./bin/hi.js&quot;</div><div class=\"line\"> &#125;,</div></pre></td></tr></table></figure>\n<p>这样<code>npm install -g</code>安装后会自动生成<code>.cmd</code>文件</p>\n<h3 id=\"URLencode编码\"><a href=\"#URLencode编码\" class=\"headerlink\" title=\"URLencode编码\"></a>URLencode编码</h3><p>测试接口的时候一直报下面的错误<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t&quot;reason&quot;:&quot;info参数错误&quot;,</div><div class=\"line\">\t&quot;result&quot;:null,</div><div class=\"line\">\t&quot;error_code&quot;:211201</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>仔细看了API文档以后，发现接口不能接受中文字符，需要进行转码，然而并不知道要使用哪种转码方式，经过吐血的测试以后，终于确定是URLencode转码。封装成一个<code>urlencode</code>模块<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> urlencode = <span class=\"built_in\">require</span>(<span class=\"string\">'urlencode'</span>);</div></pre></td></tr></table></figure></p>\n<h3 id=\"在npm发布\"><a href=\"#在npm发布\" class=\"headerlink\" title=\"在npm发布\"></a>在npm发布</h3><p>如果报错是这样<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">no_perms Private mode enable, only admin can publish this module</div></pre></td></tr></table></figure></p>\n<p>使用下面代码重置npm镜像<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm config set registry http://registry.npmjs.org</div></pre></td></tr></table></figure></p>\n<h3 id=\"最后一个坑\"><a href=\"#最后一个坑\" class=\"headerlink\" title=\"最后一个坑\"></a>最后一个坑</h3><p>本地测试正常，npm发布后再<code>npm install -g</code>安装执行就报错<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">command not found</div></pre></td></tr></table></figure></p>\n<p>着实纠结好久，最后试着是在入口文件中加<br><code>#!/usr/bin/env node</code></p>\n<p>虽然可以了，但是原理不太理解，<code>#!/usr/bin/env node</code>是Linux系统下，在shell脚本中，通过#!注释来指定当前脚本使用的解析器。</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><blockquote>\n<p><a href=\"https://my.oschina.net/ubuntuvim/blog/540494\">npm插件开发流程</a></p>\n<p><a href=\"https://nqdeng.github.io/7-days-nodejs/\">七天学会NodeJS</a></p>\n</blockquote>"},{"title":"现代Javascript纵览--外文搬运系列（一）","date":"2017-02-21T03:45:50.000Z","_content":"\n**本文译自[原文链接](https://auth0.com/blog/glossary-of-modern-javascript-concepts/)**\n\n**考虑到句子通顺，以及本人语言水平有限，有些地方没有按照原文直译。容易引起误解的地方都贴上原文了。**\n\n\n\n<!-- more -->\n\n## 概念\n### 纯函数（Pure Functions）\n一个纯函数的返回值仅由它决定的输入值，无副作用（参数）。当给定的相同的参数，结果将始终是相同的。下面是一个例子：\n```js\n\n    function add10(a){\n        return a+10\n    }\n```\n\n该add(a)函数接受一个数字a并返回与10相加的值。\n\n如果我们传递的参数8给这个函数，该函数总是返回18。\n\n对于一个确定的参数，纯函数会返回一个确定的值，不依赖和改变外部状态。\n\n纯函数不能从父范围内引用变量，除非他们明确地传递给函数作为参数。即使这样，该函数可以不修改外部状态。\n```js\n    var num=10\n    \n    function add10(){\n        return num+10\n    }\n    //这就不是一个纯函数\n```\n\n**总结一下**\n\n- 纯函数必须有参数\n- 同样的输入有相同输出\n- 纯函数不依赖或者改变外部状态（注意console.log()改变全局状态）\n- 纯函数不产生副作用\n- 纯函数不能调用非纯函数\n\n### 非纯函数（Impure Functions）\n非纯函数会改变自身作用域以外的状态。一个函数运行时会改变外部状态（副作用），那么它就是非纯函数，没有返回值的函数也是非纯的。\n\n考虑下面的例子\n\n```js\n// impure function producing a side effect\n//非纯函数产生了副作用\nfunction showAlert() {\n  alert('This is a side effect!');\n}\n\n// impure function mutating external state\n// 非纯函数改变了外部变量\nvar globalVal = 1;\nfunction incrementGlobalVal(x) {\n  globalVal += x;\n}\n\n// impure function calling pure functions procedurally\n// 调用纯函数的非纯函数（调用了console.log()才是重点，所以不太理解作者要表达什么）\nfunction proceduralFn() {\n  const result1 = pureFnFirst(1);\n  const result2 = pureFnLast(2);\n  console.log(`Done with ${result1} and ${result2}!`);\n}\n\n// impure function that resembles a pure function,\n// but returns different results given the same inputs\n//看起来像是一个纯函数，但是这个函数对同一输入会返回不同输出，所以是不纯函数\nfunction getRandomRange(min, max) {\n  return Math.random() * (max - min) + min;\n}\n```\n\n### 副作用\n当一个功能或表达修改其自己的上下文之外的状态，其结果是一个副作用。\n\n副作用的例子包括制作一个API的调用，操纵DOM，抛出一个警告对话框，写入数据库等。如果功能产生副作用，它被认为是不纯的。引起副作用的函数是难以预料和难以测试，因为它们会导致以外的局部范围内变化。\n\n## 状态和无状态\n状态指的是程序访问，并且可以在一个时间点上操作的信息。这包括存储在存储器中，以及OS的存储器，输入/输出端口，数据库等的数据。例如，变量在任何给定时刻的应用程序的内容是代表应用程序的的状态。\n### 有状态（Stateful）\n有状态的程序，应用程序或组件的数据存储在有关当前状态的内存。他们可以修改状态以及访问它的历史。下面的例子是有状态：\n```js\n// stateful \n//有状态\nvar number = 1;\nfunction increment() {\n  return number++;\n}\nincrement(); // global variable modified: number = 2\n            //全局变量被更改\n```\n### 无状态（Stateless）\n无状态的函数和组件每一次执行都像是第一次执行。\n\n这意味着他们不引用或不在其执行前引用任何信息，无状态是引用透明。\n\n函数只依赖自身的参数而且不需要也不访问自身作用域外的任何东西。\n\n请看下面例子：\n```js\n// stateless\n//无状态\nvar number = 1;\nfunction increment(n) {\n  return n + 1;\n}\nincrement(number); // global variable NOT modified: returns 2\n                    //全局变量未改变\n```\n无状态应用程序仍然管理状态，然而他们是返回当前状态，而不不改变以前的状态（However, they return their current state without mutating previous state.怎么翻译都觉得别扭，贴上原文），这是函数式编程的一个宗旨。\n\n## 不变性和可变性（Immutability and Mutability）\nJavaScript的不可变性和可变性的概念比其他一些编程语言更加模糊不清，然而当你阅读JS中的函数式编程时会听到很多不可变性的概念。知道这些概念是如何使用和在JavaScript中实现是非常重要的。简单的定义：\n\n### 不可变性（Immutable）\n如果一个对象是不可变的。则它的值不能在创建以后修改。\n\n### 可变性（Mutable）\n如果一个对象是可变的。则它的值能在创建以后修改。\n\n### Javascript语言设计中的可变性和不可变性\n在JavaScript中，设计上，字符串和数字是不可变的。如果我们对它进行操作，下面的方法很容易理解。\n\n```js\n\nvar str = 'Hello!';\nvar anotherStr = str.substring(2);\n// result: str = 'Hello!' (unchanged)\n// result: anotherStr = 'llo!' (new string)\n```\n\n我们使用的方法并没有修改原始字符串。相反，它会创建一个新的字符串。我们可以给变量一个其他值，but once we've created our string, it will always be .\n\n数字最好也是不变性的。下面代码始终具有相同的结果：\n```js\nvar three = 1 + 2;\n// result: three = 3\n```\n这表明，不变性在JavaScript的设计中确实存在。然而，JS开发人员都知道，JS中大部分是可变的。例如，对象和数组设计可变的。考虑以下：\n\n```js\nvar arr = [1, 2, 3];\narr.push(4);\n// result: arr = [1, 2, 3, 4]\n\nvar obj = { greeting: 'Hello' };\nobj.name = 'Jon';\n// result: obj = { greeting: 'Hello', name: 'Jon' }\n```\n在这些例子中，原始的对象被改变。没有返回新的对象；\n\n要了解更多关于其他语言的可变性，分辨出什么是可变，什么是不可变。\n### JavaScript实践中不变性\n\n函数式编程在JavaScript中获得了大量的关注。但是在设计上，JS是一个非常易变的，多范型的语言。函数式编程强调不变性。当开发人员试图改变不可变对象时将引发错误。所以写函数式程序时我们怎么能调和JS与生俱来的可变性？","source":"_posts/translation-1.md","raw":"---\ntitle: '现代Javascript纵览--外文搬运系列（一）'\ndate: 2017-02-21 11:45:50\ncategories:\n- Translation\ntags: \n- JavaScript\n- 函数式编程\n---\n\n**本文译自[原文链接](https://auth0.com/blog/glossary-of-modern-javascript-concepts/)**\n\n**考虑到句子通顺，以及本人语言水平有限，有些地方没有按照原文直译。容易引起误解的地方都贴上原文了。**\n\n\n\n<!-- more -->\n\n## 概念\n### 纯函数（Pure Functions）\n一个纯函数的返回值仅由它决定的输入值，无副作用（参数）。当给定的相同的参数，结果将始终是相同的。下面是一个例子：\n```js\n\n    function add10(a){\n        return a+10\n    }\n```\n\n该add(a)函数接受一个数字a并返回与10相加的值。\n\n如果我们传递的参数8给这个函数，该函数总是返回18。\n\n对于一个确定的参数，纯函数会返回一个确定的值，不依赖和改变外部状态。\n\n纯函数不能从父范围内引用变量，除非他们明确地传递给函数作为参数。即使这样，该函数可以不修改外部状态。\n```js\n    var num=10\n    \n    function add10(){\n        return num+10\n    }\n    //这就不是一个纯函数\n```\n\n**总结一下**\n\n- 纯函数必须有参数\n- 同样的输入有相同输出\n- 纯函数不依赖或者改变外部状态（注意console.log()改变全局状态）\n- 纯函数不产生副作用\n- 纯函数不能调用非纯函数\n\n### 非纯函数（Impure Functions）\n非纯函数会改变自身作用域以外的状态。一个函数运行时会改变外部状态（副作用），那么它就是非纯函数，没有返回值的函数也是非纯的。\n\n考虑下面的例子\n\n```js\n// impure function producing a side effect\n//非纯函数产生了副作用\nfunction showAlert() {\n  alert('This is a side effect!');\n}\n\n// impure function mutating external state\n// 非纯函数改变了外部变量\nvar globalVal = 1;\nfunction incrementGlobalVal(x) {\n  globalVal += x;\n}\n\n// impure function calling pure functions procedurally\n// 调用纯函数的非纯函数（调用了console.log()才是重点，所以不太理解作者要表达什么）\nfunction proceduralFn() {\n  const result1 = pureFnFirst(1);\n  const result2 = pureFnLast(2);\n  console.log(`Done with ${result1} and ${result2}!`);\n}\n\n// impure function that resembles a pure function,\n// but returns different results given the same inputs\n//看起来像是一个纯函数，但是这个函数对同一输入会返回不同输出，所以是不纯函数\nfunction getRandomRange(min, max) {\n  return Math.random() * (max - min) + min;\n}\n```\n\n### 副作用\n当一个功能或表达修改其自己的上下文之外的状态，其结果是一个副作用。\n\n副作用的例子包括制作一个API的调用，操纵DOM，抛出一个警告对话框，写入数据库等。如果功能产生副作用，它被认为是不纯的。引起副作用的函数是难以预料和难以测试，因为它们会导致以外的局部范围内变化。\n\n## 状态和无状态\n状态指的是程序访问，并且可以在一个时间点上操作的信息。这包括存储在存储器中，以及OS的存储器，输入/输出端口，数据库等的数据。例如，变量在任何给定时刻的应用程序的内容是代表应用程序的的状态。\n### 有状态（Stateful）\n有状态的程序，应用程序或组件的数据存储在有关当前状态的内存。他们可以修改状态以及访问它的历史。下面的例子是有状态：\n```js\n// stateful \n//有状态\nvar number = 1;\nfunction increment() {\n  return number++;\n}\nincrement(); // global variable modified: number = 2\n            //全局变量被更改\n```\n### 无状态（Stateless）\n无状态的函数和组件每一次执行都像是第一次执行。\n\n这意味着他们不引用或不在其执行前引用任何信息，无状态是引用透明。\n\n函数只依赖自身的参数而且不需要也不访问自身作用域外的任何东西。\n\n请看下面例子：\n```js\n// stateless\n//无状态\nvar number = 1;\nfunction increment(n) {\n  return n + 1;\n}\nincrement(number); // global variable NOT modified: returns 2\n                    //全局变量未改变\n```\n无状态应用程序仍然管理状态，然而他们是返回当前状态，而不不改变以前的状态（However, they return their current state without mutating previous state.怎么翻译都觉得别扭，贴上原文），这是函数式编程的一个宗旨。\n\n## 不变性和可变性（Immutability and Mutability）\nJavaScript的不可变性和可变性的概念比其他一些编程语言更加模糊不清，然而当你阅读JS中的函数式编程时会听到很多不可变性的概念。知道这些概念是如何使用和在JavaScript中实现是非常重要的。简单的定义：\n\n### 不可变性（Immutable）\n如果一个对象是不可变的。则它的值不能在创建以后修改。\n\n### 可变性（Mutable）\n如果一个对象是可变的。则它的值能在创建以后修改。\n\n### Javascript语言设计中的可变性和不可变性\n在JavaScript中，设计上，字符串和数字是不可变的。如果我们对它进行操作，下面的方法很容易理解。\n\n```js\n\nvar str = 'Hello!';\nvar anotherStr = str.substring(2);\n// result: str = 'Hello!' (unchanged)\n// result: anotherStr = 'llo!' (new string)\n```\n\n我们使用的方法并没有修改原始字符串。相反，它会创建一个新的字符串。我们可以给变量一个其他值，but once we've created our string, it will always be .\n\n数字最好也是不变性的。下面代码始终具有相同的结果：\n```js\nvar three = 1 + 2;\n// result: three = 3\n```\n这表明，不变性在JavaScript的设计中确实存在。然而，JS开发人员都知道，JS中大部分是可变的。例如，对象和数组设计可变的。考虑以下：\n\n```js\nvar arr = [1, 2, 3];\narr.push(4);\n// result: arr = [1, 2, 3, 4]\n\nvar obj = { greeting: 'Hello' };\nobj.name = 'Jon';\n// result: obj = { greeting: 'Hello', name: 'Jon' }\n```\n在这些例子中，原始的对象被改变。没有返回新的对象；\n\n要了解更多关于其他语言的可变性，分辨出什么是可变，什么是不可变。\n### JavaScript实践中不变性\n\n函数式编程在JavaScript中获得了大量的关注。但是在设计上，JS是一个非常易变的，多范型的语言。函数式编程强调不变性。当开发人员试图改变不可变对象时将引发错误。所以写函数式程序时我们怎么能调和JS与生俱来的可变性？","slug":"translation-1","published":1,"updated":"2017-02-23T03:09:09.909Z","_id":"cizhru6pk000eosqp4wlstv2b","comments":1,"layout":"post","photos":[],"link":"","content":"<p><strong>本文译自<a href=\"https://auth0.com/blog/glossary-of-modern-javascript-concepts/\" target=\"_blank\" rel=\"external\">原文链接</a></strong></p>\n<p><strong>考虑到句子通顺，以及本人语言水平有限，有些地方没有按照原文直译。容易引起误解的地方都贴上原文了。</strong></p>\n<a id=\"more\"></a>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><h3 id=\"纯函数（Pure-Functions）\"><a href=\"#纯函数（Pure-Functions）\" class=\"headerlink\" title=\"纯函数（Pure Functions）\"></a>纯函数（Pure Functions）</h3><p>一个纯函数的返回值仅由它决定的输入值，无副作用（参数）。当给定的相同的参数，结果将始终是相同的。下面是一个例子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add10</span>(<span class=\"params\">a</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a+<span class=\"number\">10</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>该add(a)函数接受一个数字a并返回与10相加的值。</p>\n<p>如果我们传递的参数8给这个函数，该函数总是返回18。</p>\n<p>对于一个确定的参数，纯函数会返回一个确定的值，不依赖和改变外部状态。</p>\n<p>纯函数不能从父范围内引用变量，除非他们明确地传递给函数作为参数。即使这样，该函数可以不修改外部状态。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> num=<span class=\"number\">10</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add10</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> num+<span class=\"number\">10</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//这就不是一个纯函数</span></div></pre></td></tr></table></figure></p>\n<p><strong>总结一下</strong></p>\n<ul>\n<li>纯函数必须有参数</li>\n<li>同样的输入有相同输出</li>\n<li>纯函数不依赖或者改变外部状态（注意console.log()改变全局状态）</li>\n<li>纯函数不产生副作用</li>\n<li>纯函数不能调用非纯函数</li>\n</ul>\n<h3 id=\"非纯函数（Impure-Functions）\"><a href=\"#非纯函数（Impure-Functions）\" class=\"headerlink\" title=\"非纯函数（Impure Functions）\"></a>非纯函数（Impure Functions）</h3><p>非纯函数会改变自身作用域以外的状态。一个函数运行时会改变外部状态（副作用），那么它就是非纯函数，没有返回值的函数也是非纯的。</p>\n<p>考虑下面的例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// impure function producing a side effect</span></div><div class=\"line\"><span class=\"comment\">//非纯函数产生了副作用</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showAlert</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  alert(<span class=\"string\">'This is a side effect!'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// impure function mutating external state</span></div><div class=\"line\"><span class=\"comment\">// 非纯函数改变了外部变量</span></div><div class=\"line\"><span class=\"keyword\">var</span> globalVal = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">incrementGlobalVal</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">  globalVal += x;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// impure function calling pure functions procedurally</span></div><div class=\"line\"><span class=\"comment\">// 调用纯函数的非纯函数（调用了console.log()才是重点，所以不太理解作者要表达什么）</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">proceduralFn</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> result1 = pureFnFirst(<span class=\"number\">1</span>);</div><div class=\"line\">  <span class=\"keyword\">const</span> result2 = pureFnLast(<span class=\"number\">2</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`Done with <span class=\"subst\">$&#123;result1&#125;</span> and <span class=\"subst\">$&#123;result2&#125;</span>!`</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// impure function that resembles a pure function,</span></div><div class=\"line\"><span class=\"comment\">// but returns different results given the same inputs</span></div><div class=\"line\"><span class=\"comment\">//看起来像是一个纯函数，但是这个函数对同一输入会返回不同输出，所以是不纯函数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRandomRange</span>(<span class=\"params\">min, max</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random() * (max - min) + min;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"副作用\"><a href=\"#副作用\" class=\"headerlink\" title=\"副作用\"></a>副作用</h3><p>当一个功能或表达修改其自己的上下文之外的状态，其结果是一个副作用。</p>\n<p>副作用的例子包括制作一个API的调用，操纵DOM，抛出一个警告对话框，写入数据库等。如果功能产生副作用，它被认为是不纯的。引起副作用的函数是难以预料和难以测试，因为它们会导致以外的局部范围内变化。</p>\n<h2 id=\"状态和无状态\"><a href=\"#状态和无状态\" class=\"headerlink\" title=\"状态和无状态\"></a>状态和无状态</h2><p>状态指的是程序访问，并且可以在一个时间点上操作的信息。这包括存储在存储器中，以及OS的存储器，输入/输出端口，数据库等的数据。例如，变量在任何给定时刻的应用程序的内容是代表应用程序的的状态。</p>\n<h3 id=\"有状态（Stateful）\"><a href=\"#有状态（Stateful）\" class=\"headerlink\" title=\"有状态（Stateful）\"></a>有状态（Stateful）</h3><p>有状态的程序，应用程序或组件的数据存储在有关当前状态的内存。他们可以修改状态以及访问它的历史。下面的例子是有状态：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// stateful </span></div><div class=\"line\"><span class=\"comment\">//有状态</span></div><div class=\"line\"><span class=\"keyword\">var</span> number = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">increment</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> number++;</div><div class=\"line\">&#125;</div><div class=\"line\">increment(); <span class=\"comment\">// global variable modified: number = 2</span></div><div class=\"line\">            <span class=\"comment\">//全局变量被更改</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"无状态（Stateless）\"><a href=\"#无状态（Stateless）\" class=\"headerlink\" title=\"无状态（Stateless）\"></a>无状态（Stateless）</h3><p>无状态的函数和组件每一次执行都像是第一次执行。</p>\n<p>这意味着他们不引用或不在其执行前引用任何信息，无状态是引用透明。</p>\n<p>函数只依赖自身的参数而且不需要也不访问自身作用域外的任何东西。</p>\n<p>请看下面例子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// stateless</span></div><div class=\"line\"><span class=\"comment\">//无状态</span></div><div class=\"line\"><span class=\"keyword\">var</span> number = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">increment</span>(<span class=\"params\">n</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> n + <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">increment(number); <span class=\"comment\">// global variable NOT modified: returns 2</span></div><div class=\"line\">                    <span class=\"comment\">//全局变量未改变</span></div></pre></td></tr></table></figure></p>\n<p>无状态应用程序仍然管理状态，然而他们是返回当前状态，而不不改变以前的状态（However, they return their current state without mutating previous state.怎么翻译都觉得别扭，贴上原文），这是函数式编程的一个宗旨。</p>\n<h2 id=\"不变性和可变性（Immutability-and-Mutability）\"><a href=\"#不变性和可变性（Immutability-and-Mutability）\" class=\"headerlink\" title=\"不变性和可变性（Immutability and Mutability）\"></a>不变性和可变性（Immutability and Mutability）</h2><p>JavaScript的不可变性和可变性的概念比其他一些编程语言更加模糊不清，然而当你阅读JS中的函数式编程时会听到很多不可变性的概念。知道这些概念是如何使用和在JavaScript中实现是非常重要的。简单的定义：</p>\n<h3 id=\"不可变性（Immutable）\"><a href=\"#不可变性（Immutable）\" class=\"headerlink\" title=\"不可变性（Immutable）\"></a>不可变性（Immutable）</h3><p>如果一个对象是不可变的。则它的值不能在创建以后修改。</p>\n<h3 id=\"可变性（Mutable）\"><a href=\"#可变性（Mutable）\" class=\"headerlink\" title=\"可变性（Mutable）\"></a>可变性（Mutable）</h3><p>如果一个对象是可变的。则它的值能在创建以后修改。</p>\n<h3 id=\"Javascript语言设计中的可变性和不可变性\"><a href=\"#Javascript语言设计中的可变性和不可变性\" class=\"headerlink\" title=\"Javascript语言设计中的可变性和不可变性\"></a>Javascript语言设计中的可变性和不可变性</h3><p>在JavaScript中，设计上，字符串和数字是不可变的。如果我们对它进行操作，下面的方法很容易理解。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'Hello!'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> anotherStr = str.substring(<span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"comment\">// result: str = 'Hello!' (unchanged)</span></div><div class=\"line\"><span class=\"comment\">// result: anotherStr = 'llo!' (new string)</span></div></pre></td></tr></table></figure>\n<p>我们使用的方法并没有修改原始字符串。相反，它会创建一个新的字符串。我们可以给变量一个其他值，but once we’ve created our string, it will always be .</p>\n<p>数字最好也是不变性的。下面代码始终具有相同的结果：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> three = <span class=\"number\">1</span> + <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"comment\">// result: three = 3</span></div></pre></td></tr></table></figure></p>\n<p>这表明，不变性在JavaScript的设计中确实存在。然而，JS开发人员都知道，JS中大部分是可变的。例如，对象和数组设计可变的。考虑以下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\">arr.push(<span class=\"number\">4</span>);</div><div class=\"line\"><span class=\"comment\">// result: arr = [1, 2, 3, 4]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">greeting</span>: <span class=\"string\">'Hello'</span> &#125;;</div><div class=\"line\">obj.name = <span class=\"string\">'Jon'</span>;</div><div class=\"line\"><span class=\"comment\">// result: obj = &#123; greeting: 'Hello', name: 'Jon' &#125;</span></div></pre></td></tr></table></figure>\n<p>在这些例子中，原始的对象被改变。没有返回新的对象；</p>\n<p>要了解更多关于其他语言的可变性，分辨出什么是可变，什么是不可变。</p>\n<h3 id=\"JavaScript实践中不变性\"><a href=\"#JavaScript实践中不变性\" class=\"headerlink\" title=\"JavaScript实践中不变性\"></a>JavaScript实践中不变性</h3><p>函数式编程在JavaScript中获得了大量的关注。但是在设计上，JS是一个非常易变的，多范型的语言。函数式编程强调不变性。当开发人员试图改变不可变对象时将引发错误。所以写函数式程序时我们怎么能调和JS与生俱来的可变性？</p>\n","excerpt":"<p><strong>本文译自<a href=\"https://auth0.com/blog/glossary-of-modern-javascript-concepts/\">原文链接</a></strong></p>\n<p><strong>考虑到句子通顺，以及本人语言水平有限，有些地方没有按照原文直译。容易引起误解的地方都贴上原文了。</strong></p>","more":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><h3 id=\"纯函数（Pure-Functions）\"><a href=\"#纯函数（Pure-Functions）\" class=\"headerlink\" title=\"纯函数（Pure Functions）\"></a>纯函数（Pure Functions）</h3><p>一个纯函数的返回值仅由它决定的输入值，无副作用（参数）。当给定的相同的参数，结果将始终是相同的。下面是一个例子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add10</span>(<span class=\"params\">a</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a+<span class=\"number\">10</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>该add(a)函数接受一个数字a并返回与10相加的值。</p>\n<p>如果我们传递的参数8给这个函数，该函数总是返回18。</p>\n<p>对于一个确定的参数，纯函数会返回一个确定的值，不依赖和改变外部状态。</p>\n<p>纯函数不能从父范围内引用变量，除非他们明确地传递给函数作为参数。即使这样，该函数可以不修改外部状态。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> num=<span class=\"number\">10</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add10</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> num+<span class=\"number\">10</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//这就不是一个纯函数</span></div></pre></td></tr></table></figure></p>\n<p><strong>总结一下</strong></p>\n<ul>\n<li>纯函数必须有参数</li>\n<li>同样的输入有相同输出</li>\n<li>纯函数不依赖或者改变外部状态（注意console.log()改变全局状态）</li>\n<li>纯函数不产生副作用</li>\n<li>纯函数不能调用非纯函数</li>\n</ul>\n<h3 id=\"非纯函数（Impure-Functions）\"><a href=\"#非纯函数（Impure-Functions）\" class=\"headerlink\" title=\"非纯函数（Impure Functions）\"></a>非纯函数（Impure Functions）</h3><p>非纯函数会改变自身作用域以外的状态。一个函数运行时会改变外部状态（副作用），那么它就是非纯函数，没有返回值的函数也是非纯的。</p>\n<p>考虑下面的例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// impure function producing a side effect</span></div><div class=\"line\"><span class=\"comment\">//非纯函数产生了副作用</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showAlert</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  alert(<span class=\"string\">'This is a side effect!'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// impure function mutating external state</span></div><div class=\"line\"><span class=\"comment\">// 非纯函数改变了外部变量</span></div><div class=\"line\"><span class=\"keyword\">var</span> globalVal = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">incrementGlobalVal</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">  globalVal += x;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// impure function calling pure functions procedurally</span></div><div class=\"line\"><span class=\"comment\">// 调用纯函数的非纯函数（调用了console.log()才是重点，所以不太理解作者要表达什么）</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">proceduralFn</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> result1 = pureFnFirst(<span class=\"number\">1</span>);</div><div class=\"line\">  <span class=\"keyword\">const</span> result2 = pureFnLast(<span class=\"number\">2</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`Done with <span class=\"subst\">$&#123;result1&#125;</span> and <span class=\"subst\">$&#123;result2&#125;</span>!`</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// impure function that resembles a pure function,</span></div><div class=\"line\"><span class=\"comment\">// but returns different results given the same inputs</span></div><div class=\"line\"><span class=\"comment\">//看起来像是一个纯函数，但是这个函数对同一输入会返回不同输出，所以是不纯函数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRandomRange</span>(<span class=\"params\">min, max</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random() * (max - min) + min;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"副作用\"><a href=\"#副作用\" class=\"headerlink\" title=\"副作用\"></a>副作用</h3><p>当一个功能或表达修改其自己的上下文之外的状态，其结果是一个副作用。</p>\n<p>副作用的例子包括制作一个API的调用，操纵DOM，抛出一个警告对话框，写入数据库等。如果功能产生副作用，它被认为是不纯的。引起副作用的函数是难以预料和难以测试，因为它们会导致以外的局部范围内变化。</p>\n<h2 id=\"状态和无状态\"><a href=\"#状态和无状态\" class=\"headerlink\" title=\"状态和无状态\"></a>状态和无状态</h2><p>状态指的是程序访问，并且可以在一个时间点上操作的信息。这包括存储在存储器中，以及OS的存储器，输入/输出端口，数据库等的数据。例如，变量在任何给定时刻的应用程序的内容是代表应用程序的的状态。</p>\n<h3 id=\"有状态（Stateful）\"><a href=\"#有状态（Stateful）\" class=\"headerlink\" title=\"有状态（Stateful）\"></a>有状态（Stateful）</h3><p>有状态的程序，应用程序或组件的数据存储在有关当前状态的内存。他们可以修改状态以及访问它的历史。下面的例子是有状态：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// stateful </span></div><div class=\"line\"><span class=\"comment\">//有状态</span></div><div class=\"line\"><span class=\"keyword\">var</span> number = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">increment</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> number++;</div><div class=\"line\">&#125;</div><div class=\"line\">increment(); <span class=\"comment\">// global variable modified: number = 2</span></div><div class=\"line\">            <span class=\"comment\">//全局变量被更改</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"无状态（Stateless）\"><a href=\"#无状态（Stateless）\" class=\"headerlink\" title=\"无状态（Stateless）\"></a>无状态（Stateless）</h3><p>无状态的函数和组件每一次执行都像是第一次执行。</p>\n<p>这意味着他们不引用或不在其执行前引用任何信息，无状态是引用透明。</p>\n<p>函数只依赖自身的参数而且不需要也不访问自身作用域外的任何东西。</p>\n<p>请看下面例子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// stateless</span></div><div class=\"line\"><span class=\"comment\">//无状态</span></div><div class=\"line\"><span class=\"keyword\">var</span> number = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">increment</span>(<span class=\"params\">n</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> n + <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">increment(number); <span class=\"comment\">// global variable NOT modified: returns 2</span></div><div class=\"line\">                    <span class=\"comment\">//全局变量未改变</span></div></pre></td></tr></table></figure></p>\n<p>无状态应用程序仍然管理状态，然而他们是返回当前状态，而不不改变以前的状态（However, they return their current state without mutating previous state.怎么翻译都觉得别扭，贴上原文），这是函数式编程的一个宗旨。</p>\n<h2 id=\"不变性和可变性（Immutability-and-Mutability）\"><a href=\"#不变性和可变性（Immutability-and-Mutability）\" class=\"headerlink\" title=\"不变性和可变性（Immutability and Mutability）\"></a>不变性和可变性（Immutability and Mutability）</h2><p>JavaScript的不可变性和可变性的概念比其他一些编程语言更加模糊不清，然而当你阅读JS中的函数式编程时会听到很多不可变性的概念。知道这些概念是如何使用和在JavaScript中实现是非常重要的。简单的定义：</p>\n<h3 id=\"不可变性（Immutable）\"><a href=\"#不可变性（Immutable）\" class=\"headerlink\" title=\"不可变性（Immutable）\"></a>不可变性（Immutable）</h3><p>如果一个对象是不可变的。则它的值不能在创建以后修改。</p>\n<h3 id=\"可变性（Mutable）\"><a href=\"#可变性（Mutable）\" class=\"headerlink\" title=\"可变性（Mutable）\"></a>可变性（Mutable）</h3><p>如果一个对象是可变的。则它的值能在创建以后修改。</p>\n<h3 id=\"Javascript语言设计中的可变性和不可变性\"><a href=\"#Javascript语言设计中的可变性和不可变性\" class=\"headerlink\" title=\"Javascript语言设计中的可变性和不可变性\"></a>Javascript语言设计中的可变性和不可变性</h3><p>在JavaScript中，设计上，字符串和数字是不可变的。如果我们对它进行操作，下面的方法很容易理解。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'Hello!'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> anotherStr = str.substring(<span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"comment\">// result: str = 'Hello!' (unchanged)</span></div><div class=\"line\"><span class=\"comment\">// result: anotherStr = 'llo!' (new string)</span></div></pre></td></tr></table></figure>\n<p>我们使用的方法并没有修改原始字符串。相反，它会创建一个新的字符串。我们可以给变量一个其他值，but once we’ve created our string, it will always be .</p>\n<p>数字最好也是不变性的。下面代码始终具有相同的结果：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> three = <span class=\"number\">1</span> + <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"comment\">// result: three = 3</span></div></pre></td></tr></table></figure></p>\n<p>这表明，不变性在JavaScript的设计中确实存在。然而，JS开发人员都知道，JS中大部分是可变的。例如，对象和数组设计可变的。考虑以下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\">arr.push(<span class=\"number\">4</span>);</div><div class=\"line\"><span class=\"comment\">// result: arr = [1, 2, 3, 4]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">greeting</span>: <span class=\"string\">'Hello'</span> &#125;;</div><div class=\"line\">obj.name = <span class=\"string\">'Jon'</span>;</div><div class=\"line\"><span class=\"comment\">// result: obj = &#123; greeting: 'Hello', name: 'Jon' &#125;</span></div></pre></td></tr></table></figure>\n<p>在这些例子中，原始的对象被改变。没有返回新的对象；</p>\n<p>要了解更多关于其他语言的可变性，分辨出什么是可变，什么是不可变。</p>\n<h3 id=\"JavaScript实践中不变性\"><a href=\"#JavaScript实践中不变性\" class=\"headerlink\" title=\"JavaScript实践中不变性\"></a>JavaScript实践中不变性</h3><p>函数式编程在JavaScript中获得了大量的关注。但是在设计上，JS是一个非常易变的，多范型的语言。函数式编程强调不变性。当开发人员试图改变不可变对象时将引发错误。所以写函数式程序时我们怎么能调和JS与生俱来的可变性？</p>"},{"title":"工具集","date":"2017-01-12T05:44:10.000Z","_content":"原来一直在印象笔记上写笔记，感觉自己像是一个小水轮车，水流过来的时候能用的上，但是知识沉淀率太低，总是看的多，忘得多。\n\n后来看到这个[知乎问题](https://www.zhihu.com/question/26865557)，觉得有必要开始总结，归纳，索引自己的知识和有用的资源。\n\n下面是总结的一些素材资源网站、在线工具、Chrome插件、益于时间管理的工具。作为找回资源的备份，本文会不断更新\n<!-- more -->\n\n### 素材资源网站\n\n#### 1. [阿里的矢量图标库](http://www.iconfont.cn/)\n丰富的图标可供下载，还可以选择自己想要的颜色，支持`SVG||PNG||AI`三种格式下载\n\n#### 2. [WEB安全色](http://www.bootcss.com/p/websafecolors/)\nBootstrap中文网下的推荐配色方案\n\n#### 3. [日系风格设计网站](http://bm.straightline.jp/)\n收录很多优质的网站设计\n\n#### 4. [方便查询标签的设计网站](http://www.collectui.com/)\n\n#### 5. [免费的图片素材](https://unsplash.com/)\n\n### 在线工具\n\n#### 1. [文件格式转换](https://convertio.co/zh/)\n处理PDF、Word文件，OCR识别等很多工具，强大且全面，最关键的是免费\n\n#### 2. [专业的PDf处理工具](http://www.ilovepdf.com/)\n\n支持各种格式和PDf之间的转换\n\n#### 3. [文图](http://wentu.io/)\n数据可视化工具，而且支持数据源API接口。（ps：这个我还不怎么会用）\n\n#### 4. [icon图标制作](http://www.ico.la/)\n\n### Chrome插件（*以下插件均是免费的*）\n\n#### 1. 谷歌访问助手\n方便下载以下插件的前提是你要先科学上网，这个插件可以帮助你上Google下的搜索、应用商店、账号管理、Gmail等服务。而且是**免费的**。\n#### 2. Adblock Plus\n强大的广告拦截插件，某60口中的装机必备\n#### 3. Chrono下载管理器\n可替代Chrome自带的下载器，功能很强大\n#### 4. ColorZilla\n网页拾色器，可以提取文字，图片的颜色，看到一款好的配色就可以提取出来\n#### 5. Google翻译 \n不多说，看文档必需品\n#### 6. Momentum\n美化新建标签页，还可以添加简单的日程管理\n#### 7. Page Ruler\n量取、查看视图元素的大小\n#### 8. React Developer Tools\nReact调试工具\n#### 9. Search by Image\n一键谷歌搜图\n#### 10. 一键管理所以扩展\n下载的插件多了，就需要用这个插件进行管理\n#### 11. 网页截图:注释&批注\n相比较其他截图插件，这个算是比较强大的了，但是没有滚动截屏的功能\n#### 12. 阅读模式\n这个对于经常要看技术博客的人算是必需品吧，屏蔽掉影响阅读的广告栏\n\n### 时间管理\n#### 1. Manic Time\n记录电脑活动的窗口，可用于量化时间分配，审视自己的工作效率（强烈推荐）\n#### 2. Android下的 奇妙日程\n日程计划管理的App\n\n### 彩蛋\n一些有趣的工具\n#### 1. Tickeys\n让你找对Coding的感觉\n","source":"_posts/工具集.md","raw":"---\ntitle: 工具集\ndate: 2017-01-12 13:44:10\ncategories:\n- 工具\ntags: \n- 素材资源\n- 在线工具\n- Chrome插件\n- 时间管理\n- 快乐的coding\n\n---\n原来一直在印象笔记上写笔记，感觉自己像是一个小水轮车，水流过来的时候能用的上，但是知识沉淀率太低，总是看的多，忘得多。\n\n后来看到这个[知乎问题](https://www.zhihu.com/question/26865557)，觉得有必要开始总结，归纳，索引自己的知识和有用的资源。\n\n下面是总结的一些素材资源网站、在线工具、Chrome插件、益于时间管理的工具。作为找回资源的备份，本文会不断更新\n<!-- more -->\n\n### 素材资源网站\n\n#### 1. [阿里的矢量图标库](http://www.iconfont.cn/)\n丰富的图标可供下载，还可以选择自己想要的颜色，支持`SVG||PNG||AI`三种格式下载\n\n#### 2. [WEB安全色](http://www.bootcss.com/p/websafecolors/)\nBootstrap中文网下的推荐配色方案\n\n#### 3. [日系风格设计网站](http://bm.straightline.jp/)\n收录很多优质的网站设计\n\n#### 4. [方便查询标签的设计网站](http://www.collectui.com/)\n\n#### 5. [免费的图片素材](https://unsplash.com/)\n\n### 在线工具\n\n#### 1. [文件格式转换](https://convertio.co/zh/)\n处理PDF、Word文件，OCR识别等很多工具，强大且全面，最关键的是免费\n\n#### 2. [专业的PDf处理工具](http://www.ilovepdf.com/)\n\n支持各种格式和PDf之间的转换\n\n#### 3. [文图](http://wentu.io/)\n数据可视化工具，而且支持数据源API接口。（ps：这个我还不怎么会用）\n\n#### 4. [icon图标制作](http://www.ico.la/)\n\n### Chrome插件（*以下插件均是免费的*）\n\n#### 1. 谷歌访问助手\n方便下载以下插件的前提是你要先科学上网，这个插件可以帮助你上Google下的搜索、应用商店、账号管理、Gmail等服务。而且是**免费的**。\n#### 2. Adblock Plus\n强大的广告拦截插件，某60口中的装机必备\n#### 3. Chrono下载管理器\n可替代Chrome自带的下载器，功能很强大\n#### 4. ColorZilla\n网页拾色器，可以提取文字，图片的颜色，看到一款好的配色就可以提取出来\n#### 5. Google翻译 \n不多说，看文档必需品\n#### 6. Momentum\n美化新建标签页，还可以添加简单的日程管理\n#### 7. Page Ruler\n量取、查看视图元素的大小\n#### 8. React Developer Tools\nReact调试工具\n#### 9. Search by Image\n一键谷歌搜图\n#### 10. 一键管理所以扩展\n下载的插件多了，就需要用这个插件进行管理\n#### 11. 网页截图:注释&批注\n相比较其他截图插件，这个算是比较强大的了，但是没有滚动截屏的功能\n#### 12. 阅读模式\n这个对于经常要看技术博客的人算是必需品吧，屏蔽掉影响阅读的广告栏\n\n### 时间管理\n#### 1. Manic Time\n记录电脑活动的窗口，可用于量化时间分配，审视自己的工作效率（强烈推荐）\n#### 2. Android下的 奇妙日程\n日程计划管理的App\n\n### 彩蛋\n一些有趣的工具\n#### 1. Tickeys\n让你找对Coding的感觉\n","slug":"工具集","published":1,"updated":"2017-02-20T06:33:54.207Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizhru6pq000hosqptp76bu04","content":"<p>原来一直在印象笔记上写笔记，感觉自己像是一个小水轮车，水流过来的时候能用的上，但是知识沉淀率太低，总是看的多，忘得多。</p>\n<p>后来看到这个<a href=\"https://www.zhihu.com/question/26865557\" target=\"_blank\" rel=\"external\">知乎问题</a>，觉得有必要开始总结，归纳，索引自己的知识和有用的资源。</p>\n<p>下面是总结的一些素材资源网站、在线工具、Chrome插件、益于时间管理的工具。作为找回资源的备份，本文会不断更新<br><a id=\"more\"></a></p>\n<h3 id=\"素材资源网站\"><a href=\"#素材资源网站\" class=\"headerlink\" title=\"素材资源网站\"></a>素材资源网站</h3><h4 id=\"1-阿里的矢量图标库\"><a href=\"#1-阿里的矢量图标库\" class=\"headerlink\" title=\"1. 阿里的矢量图标库\"></a>1. <a href=\"http://www.iconfont.cn/\" target=\"_blank\" rel=\"external\">阿里的矢量图标库</a></h4><p>丰富的图标可供下载，还可以选择自己想要的颜色，支持<code>SVG||PNG||AI</code>三种格式下载</p>\n<h4 id=\"2-WEB安全色\"><a href=\"#2-WEB安全色\" class=\"headerlink\" title=\"2. WEB安全色\"></a>2. <a href=\"http://www.bootcss.com/p/websafecolors/\" target=\"_blank\" rel=\"external\">WEB安全色</a></h4><p>Bootstrap中文网下的推荐配色方案</p>\n<h4 id=\"3-日系风格设计网站\"><a href=\"#3-日系风格设计网站\" class=\"headerlink\" title=\"3. 日系风格设计网站\"></a>3. <a href=\"http://bm.straightline.jp/\" target=\"_blank\" rel=\"external\">日系风格设计网站</a></h4><p>收录很多优质的网站设计</p>\n<h4 id=\"4-方便查询标签的设计网站\"><a href=\"#4-方便查询标签的设计网站\" class=\"headerlink\" title=\"4. 方便查询标签的设计网站\"></a>4. <a href=\"http://www.collectui.com/\" target=\"_blank\" rel=\"external\">方便查询标签的设计网站</a></h4><h4 id=\"5-免费的图片素材\"><a href=\"#5-免费的图片素材\" class=\"headerlink\" title=\"5. 免费的图片素材\"></a>5. <a href=\"https://unsplash.com/\" target=\"_blank\" rel=\"external\">免费的图片素材</a></h4><h3 id=\"在线工具\"><a href=\"#在线工具\" class=\"headerlink\" title=\"在线工具\"></a>在线工具</h3><h4 id=\"1-文件格式转换\"><a href=\"#1-文件格式转换\" class=\"headerlink\" title=\"1. 文件格式转换\"></a>1. <a href=\"https://convertio.co/zh/\" target=\"_blank\" rel=\"external\">文件格式转换</a></h4><p>处理PDF、Word文件，OCR识别等很多工具，强大且全面，最关键的是免费</p>\n<h4 id=\"2-专业的PDf处理工具\"><a href=\"#2-专业的PDf处理工具\" class=\"headerlink\" title=\"2. 专业的PDf处理工具\"></a>2. <a href=\"http://www.ilovepdf.com/\" target=\"_blank\" rel=\"external\">专业的PDf处理工具</a></h4><p>支持各种格式和PDf之间的转换</p>\n<h4 id=\"3-文图\"><a href=\"#3-文图\" class=\"headerlink\" title=\"3. 文图\"></a>3. <a href=\"http://wentu.io/\" target=\"_blank\" rel=\"external\">文图</a></h4><p>数据可视化工具，而且支持数据源API接口。（ps：这个我还不怎么会用）</p>\n<h4 id=\"4-icon图标制作\"><a href=\"#4-icon图标制作\" class=\"headerlink\" title=\"4. icon图标制作\"></a>4. <a href=\"http://www.ico.la/\" target=\"_blank\" rel=\"external\">icon图标制作</a></h4><h3 id=\"Chrome插件（以下插件均是免费的）\"><a href=\"#Chrome插件（以下插件均是免费的）\" class=\"headerlink\" title=\"Chrome插件（以下插件均是免费的）\"></a>Chrome插件（<em>以下插件均是免费的</em>）</h3><h4 id=\"1-谷歌访问助手\"><a href=\"#1-谷歌访问助手\" class=\"headerlink\" title=\"1. 谷歌访问助手\"></a>1. 谷歌访问助手</h4><p>方便下载以下插件的前提是你要先科学上网，这个插件可以帮助你上Google下的搜索、应用商店、账号管理、Gmail等服务。而且是<strong>免费的</strong>。</p>\n<h4 id=\"2-Adblock-Plus\"><a href=\"#2-Adblock-Plus\" class=\"headerlink\" title=\"2. Adblock Plus\"></a>2. Adblock Plus</h4><p>强大的广告拦截插件，某60口中的装机必备</p>\n<h4 id=\"3-Chrono下载管理器\"><a href=\"#3-Chrono下载管理器\" class=\"headerlink\" title=\"3. Chrono下载管理器\"></a>3. Chrono下载管理器</h4><p>可替代Chrome自带的下载器，功能很强大</p>\n<h4 id=\"4-ColorZilla\"><a href=\"#4-ColorZilla\" class=\"headerlink\" title=\"4. ColorZilla\"></a>4. ColorZilla</h4><p>网页拾色器，可以提取文字，图片的颜色，看到一款好的配色就可以提取出来</p>\n<h4 id=\"5-Google翻译\"><a href=\"#5-Google翻译\" class=\"headerlink\" title=\"5. Google翻译\"></a>5. Google翻译</h4><p>不多说，看文档必需品</p>\n<h4 id=\"6-Momentum\"><a href=\"#6-Momentum\" class=\"headerlink\" title=\"6. Momentum\"></a>6. Momentum</h4><p>美化新建标签页，还可以添加简单的日程管理</p>\n<h4 id=\"7-Page-Ruler\"><a href=\"#7-Page-Ruler\" class=\"headerlink\" title=\"7. Page Ruler\"></a>7. Page Ruler</h4><p>量取、查看视图元素的大小</p>\n<h4 id=\"8-React-Developer-Tools\"><a href=\"#8-React-Developer-Tools\" class=\"headerlink\" title=\"8. React Developer Tools\"></a>8. React Developer Tools</h4><p>React调试工具</p>\n<h4 id=\"9-Search-by-Image\"><a href=\"#9-Search-by-Image\" class=\"headerlink\" title=\"9. Search by Image\"></a>9. Search by Image</h4><p>一键谷歌搜图</p>\n<h4 id=\"10-一键管理所以扩展\"><a href=\"#10-一键管理所以扩展\" class=\"headerlink\" title=\"10. 一键管理所以扩展\"></a>10. 一键管理所以扩展</h4><p>下载的插件多了，就需要用这个插件进行管理</p>\n<h4 id=\"11-网页截图-注释-amp-批注\"><a href=\"#11-网页截图-注释-amp-批注\" class=\"headerlink\" title=\"11. 网页截图:注释&amp;批注\"></a>11. 网页截图:注释&amp;批注</h4><p>相比较其他截图插件，这个算是比较强大的了，但是没有滚动截屏的功能</p>\n<h4 id=\"12-阅读模式\"><a href=\"#12-阅读模式\" class=\"headerlink\" title=\"12. 阅读模式\"></a>12. 阅读模式</h4><p>这个对于经常要看技术博客的人算是必需品吧，屏蔽掉影响阅读的广告栏</p>\n<h3 id=\"时间管理\"><a href=\"#时间管理\" class=\"headerlink\" title=\"时间管理\"></a>时间管理</h3><h4 id=\"1-Manic-Time\"><a href=\"#1-Manic-Time\" class=\"headerlink\" title=\"1. Manic Time\"></a>1. Manic Time</h4><p>记录电脑活动的窗口，可用于量化时间分配，审视自己的工作效率（强烈推荐）</p>\n<h4 id=\"2-Android下的-奇妙日程\"><a href=\"#2-Android下的-奇妙日程\" class=\"headerlink\" title=\"2. Android下的 奇妙日程\"></a>2. Android下的 奇妙日程</h4><p>日程计划管理的App</p>\n<h3 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h3><p>一些有趣的工具</p>\n<h4 id=\"1-Tickeys\"><a href=\"#1-Tickeys\" class=\"headerlink\" title=\"1. Tickeys\"></a>1. Tickeys</h4><p>让你找对Coding的感觉</p>\n","excerpt":"<p>原来一直在印象笔记上写笔记，感觉自己像是一个小水轮车，水流过来的时候能用的上，但是知识沉淀率太低，总是看的多，忘得多。</p>\n<p>后来看到这个<a href=\"https://www.zhihu.com/question/26865557\">知乎问题</a>，觉得有必要开始总结，归纳，索引自己的知识和有用的资源。</p>\n<p>下面是总结的一些素材资源网站、在线工具、Chrome插件、益于时间管理的工具。作为找回资源的备份，本文会不断更新<br>","more":"</p>\n<h3 id=\"素材资源网站\"><a href=\"#素材资源网站\" class=\"headerlink\" title=\"素材资源网站\"></a>素材资源网站</h3><h4 id=\"1-阿里的矢量图标库\"><a href=\"#1-阿里的矢量图标库\" class=\"headerlink\" title=\"1. 阿里的矢量图标库\"></a>1. <a href=\"http://www.iconfont.cn/\">阿里的矢量图标库</a></h4><p>丰富的图标可供下载，还可以选择自己想要的颜色，支持<code>SVG||PNG||AI</code>三种格式下载</p>\n<h4 id=\"2-WEB安全色\"><a href=\"#2-WEB安全色\" class=\"headerlink\" title=\"2. WEB安全色\"></a>2. <a href=\"http://www.bootcss.com/p/websafecolors/\">WEB安全色</a></h4><p>Bootstrap中文网下的推荐配色方案</p>\n<h4 id=\"3-日系风格设计网站\"><a href=\"#3-日系风格设计网站\" class=\"headerlink\" title=\"3. 日系风格设计网站\"></a>3. <a href=\"http://bm.straightline.jp/\">日系风格设计网站</a></h4><p>收录很多优质的网站设计</p>\n<h4 id=\"4-方便查询标签的设计网站\"><a href=\"#4-方便查询标签的设计网站\" class=\"headerlink\" title=\"4. 方便查询标签的设计网站\"></a>4. <a href=\"http://www.collectui.com/\">方便查询标签的设计网站</a></h4><h4 id=\"5-免费的图片素材\"><a href=\"#5-免费的图片素材\" class=\"headerlink\" title=\"5. 免费的图片素材\"></a>5. <a href=\"https://unsplash.com/\">免费的图片素材</a></h4><h3 id=\"在线工具\"><a href=\"#在线工具\" class=\"headerlink\" title=\"在线工具\"></a>在线工具</h3><h4 id=\"1-文件格式转换\"><a href=\"#1-文件格式转换\" class=\"headerlink\" title=\"1. 文件格式转换\"></a>1. <a href=\"https://convertio.co/zh/\">文件格式转换</a></h4><p>处理PDF、Word文件，OCR识别等很多工具，强大且全面，最关键的是免费</p>\n<h4 id=\"2-专业的PDf处理工具\"><a href=\"#2-专业的PDf处理工具\" class=\"headerlink\" title=\"2. 专业的PDf处理工具\"></a>2. <a href=\"http://www.ilovepdf.com/\">专业的PDf处理工具</a></h4><p>支持各种格式和PDf之间的转换</p>\n<h4 id=\"3-文图\"><a href=\"#3-文图\" class=\"headerlink\" title=\"3. 文图\"></a>3. <a href=\"http://wentu.io/\">文图</a></h4><p>数据可视化工具，而且支持数据源API接口。（ps：这个我还不怎么会用）</p>\n<h4 id=\"4-icon图标制作\"><a href=\"#4-icon图标制作\" class=\"headerlink\" title=\"4. icon图标制作\"></a>4. <a href=\"http://www.ico.la/\">icon图标制作</a></h4><h3 id=\"Chrome插件（以下插件均是免费的）\"><a href=\"#Chrome插件（以下插件均是免费的）\" class=\"headerlink\" title=\"Chrome插件（以下插件均是免费的）\"></a>Chrome插件（<em>以下插件均是免费的</em>）</h3><h4 id=\"1-谷歌访问助手\"><a href=\"#1-谷歌访问助手\" class=\"headerlink\" title=\"1. 谷歌访问助手\"></a>1. 谷歌访问助手</h4><p>方便下载以下插件的前提是你要先科学上网，这个插件可以帮助你上Google下的搜索、应用商店、账号管理、Gmail等服务。而且是<strong>免费的</strong>。</p>\n<h4 id=\"2-Adblock-Plus\"><a href=\"#2-Adblock-Plus\" class=\"headerlink\" title=\"2. Adblock Plus\"></a>2. Adblock Plus</h4><p>强大的广告拦截插件，某60口中的装机必备</p>\n<h4 id=\"3-Chrono下载管理器\"><a href=\"#3-Chrono下载管理器\" class=\"headerlink\" title=\"3. Chrono下载管理器\"></a>3. Chrono下载管理器</h4><p>可替代Chrome自带的下载器，功能很强大</p>\n<h4 id=\"4-ColorZilla\"><a href=\"#4-ColorZilla\" class=\"headerlink\" title=\"4. ColorZilla\"></a>4. ColorZilla</h4><p>网页拾色器，可以提取文字，图片的颜色，看到一款好的配色就可以提取出来</p>\n<h4 id=\"5-Google翻译\"><a href=\"#5-Google翻译\" class=\"headerlink\" title=\"5. Google翻译\"></a>5. Google翻译</h4><p>不多说，看文档必需品</p>\n<h4 id=\"6-Momentum\"><a href=\"#6-Momentum\" class=\"headerlink\" title=\"6. Momentum\"></a>6. Momentum</h4><p>美化新建标签页，还可以添加简单的日程管理</p>\n<h4 id=\"7-Page-Ruler\"><a href=\"#7-Page-Ruler\" class=\"headerlink\" title=\"7. Page Ruler\"></a>7. Page Ruler</h4><p>量取、查看视图元素的大小</p>\n<h4 id=\"8-React-Developer-Tools\"><a href=\"#8-React-Developer-Tools\" class=\"headerlink\" title=\"8. React Developer Tools\"></a>8. React Developer Tools</h4><p>React调试工具</p>\n<h4 id=\"9-Search-by-Image\"><a href=\"#9-Search-by-Image\" class=\"headerlink\" title=\"9. Search by Image\"></a>9. Search by Image</h4><p>一键谷歌搜图</p>\n<h4 id=\"10-一键管理所以扩展\"><a href=\"#10-一键管理所以扩展\" class=\"headerlink\" title=\"10. 一键管理所以扩展\"></a>10. 一键管理所以扩展</h4><p>下载的插件多了，就需要用这个插件进行管理</p>\n<h4 id=\"11-网页截图-注释-amp-批注\"><a href=\"#11-网页截图-注释-amp-批注\" class=\"headerlink\" title=\"11. 网页截图:注释&amp;批注\"></a>11. 网页截图:注释&amp;批注</h4><p>相比较其他截图插件，这个算是比较强大的了，但是没有滚动截屏的功能</p>\n<h4 id=\"12-阅读模式\"><a href=\"#12-阅读模式\" class=\"headerlink\" title=\"12. 阅读模式\"></a>12. 阅读模式</h4><p>这个对于经常要看技术博客的人算是必需品吧，屏蔽掉影响阅读的广告栏</p>\n<h3 id=\"时间管理\"><a href=\"#时间管理\" class=\"headerlink\" title=\"时间管理\"></a>时间管理</h3><h4 id=\"1-Manic-Time\"><a href=\"#1-Manic-Time\" class=\"headerlink\" title=\"1. Manic Time\"></a>1. Manic Time</h4><p>记录电脑活动的窗口，可用于量化时间分配，审视自己的工作效率（强烈推荐）</p>\n<h4 id=\"2-Android下的-奇妙日程\"><a href=\"#2-Android下的-奇妙日程\" class=\"headerlink\" title=\"2. Android下的 奇妙日程\"></a>2. Android下的 奇妙日程</h4><p>日程计划管理的App</p>\n<h3 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h3><p>一些有趣的工具</p>\n<h4 id=\"1-Tickeys\"><a href=\"#1-Tickeys\" class=\"headerlink\" title=\"1. Tickeys\"></a>1. Tickeys</h4><p>让你找对Coding的感觉</p>"},{"title":"video标签的属性和方法总结","date":"2017-01-15T09:54:34.000Z","_content":"最近想做一个弹幕插件，查了很多video标签的属性和方法\n\n### error属性\n\n   在正常读取时候，使用媒体数据的过程中，video元素或audio元素的error属性为null，但是任何时候只要出现错误，error属性将返回一个MediaError对象，该对象的code返回对应的错误状态，共有4个可能值：\n   \n* `MEDIA_ERR_ABORTED(数字值为1)`，媒体数据的下载过程由于用户的操作原因而被终止。\n- `MEDIA_ERR_NETWORK(数字值为2)`，确认媒体资源可用，但是在下载出现网络错误，媒体数据的下载过程被中止。\n<!-- more -->\n\n- `MEDIA_ERR_DECODE(数字值为3)`，确认媒体资源可用，但是解码时发生错误。\n- `MEDIA_ERR_SRC_NOT_SUPPORTED(数字值为4)`，媒体资源不可用或媒体格式不被支持。\n代码如下：\n```js\n<video src=\"\" id=\"videoElement\"></video>\n var video = document.getElementById(\"videoElement\");\n video.addEventListener(\"error\",function(){\n     var error = video.error;\n     swicth(error.code) {\n         case 1:\n            alert(\"视频的下载过程被中止\");\n         break;\n \n         case 2:\n            alert(\"网络发生故障，视频的下载过程被中止\");\n         break;\n \n         case 3:\n            alert(\"解码失败\");\n         break;\n \n         case 4:\n            alert(\"媒体资源不可用或媒体格式不被支持\");\n         break; \n \n     }\n },false);\n```\n### networkState属性\n\n在媒体数据加载过程中可以使用video元素或audio元素的networkState属性读取当前网络状态，共有4个可能的值；\n1．  NETWORK_EMPTY（数字值为0）：元素处于初始状态。\n2．  NETWORK_IDLE(数字值为1)，浏览器已选择好用什么编码格式来播放媒体，但是尚未建立网络连接。\n3．  NETWORK_LOADING(数字值为2)：媒体数据加载中\n4．  NETWORK_NO_SOURCE(数字值为3)，没有支持的编码格式，不执行加载。\n### currentTime属性与duration属性\n\nvideo元素或audio元素的currentTime属性来读取媒体的当前播放位置(单位是s)，也可以通过修改currentTime属性来修改当前播放位置，如果修改的位置上没有可用的媒体数据时，将抛出INVALID_STATE_ERR异常；\nvideo元素或audio元素的duration属性来读取媒体文件总的播放时间。\n我们可以来做demo如下：\nHTML代码如下：\n\n```html\n<video id=\"video\" controls width=640 height=360 autoplay>\n    <source src=\"Wildlife/Wildlife.ogv\" type=\"video/ogg; codecs=\"theora, vorbis\"\"/>\n    <source src=\"Wildlife/Wildlife.webm\" type=\"video/webm\" >\n    <source src=\"Wildlife/Wildlife.mp4\" type=\"video/mp4\">\n    <p>Video is not visible, most likely your browser does not support HTML5 video</p>\n</video>\n<button onclick=\"getCurTime()\" type=\"button\">获得当前时间的位置</button>\n<button onclick=\"setCurTime()\" type=\"button\">把时间位置设置为 5 秒</button>\n<button onclick=\"duration()\" type=\"button\">读取媒体文件总的播放时间</button>\n```\n \nJS代码如下：\n```js\nvar myVid=document.getElementById(\"video\");\nfunction getCurTime(){ \n    // 获得当前视频或者音频时间的位置\n    alert(myVid.currentTime);   \n} \nfunction setCurTime(){ \n// 给当前的视频或者音频设置5s时间的位置\n    myVid.currentTime=5;        \n} \nfunction duration() {\n    //读取媒体文件总的播放时间 单位为S\n    alert(myVid.duration); \n}\n```\n大家可以复制代码，换一张视频地址就可以看到效果了~；\n\n### played属性，paused属性与ended属性\n- played：video元素或audio元素的played属性来返回一个TimeRanges对象，从该对象中可以读取媒体文件的已播放部分的时间段。开始时间为已播放部分的开始时间，结束时间为已播放部分的结束时间。\n- paused属性：使用video元素或audio元素的paused属性来返回一个布尔值，表示是否处于暂停播放中，true表示媒体暂停播放，false表示媒体正在播放；\n- ended属性：使用video元素或audio元素的ended属性来返回一个布尔值，表示是否播放完毕，true表示媒体播放完毕，false表示媒体还没有播放完毕。\nHTML代码如下：\n```html\n    <video id=\"video\" controls width=640 height=360 autoplay loop>\n    <source src=\"Wildlife/Wildlife.ogv\" type=\"video/ogg; codecs=\"theora, vorbis\"\"/>\n    <source src=\"Wildlife/Wildlife.webm\" type=\"video/webm\" >\n    <source src=\"Wildlife/Wildlife.mp4\" type=\"video/mp4\">\n    <p>Video is not visible, most likely your browser does not support HTML5 video</p>\n    </video>\n    <button onclick=\"played()\" type=\"button\">读取媒体文件的已播放部分的时间段</button>\n    <button onclick=\"paused()\" type=\"button\">是否处于暂停播放</button>\n    <button onclick=\"ended()\" type=\"button\">是否播放完毕</button>\n```\n\nJS代码如下：\n```js\nvar myVid=document.getElementById(\"video\");\nfunction played() {\n    //读取媒体文件的已播放部分的时间段\n    console.log(myVid.played);\n}\nfunction paused() {\n    // 是否处于暂停播放\n    alert(myVid.paused);\n}\nfunction ended() {\n    // 是否播放完毕\n    alert(myVid.ended);\n}\n\n```\n### defaultPlaybackRate属性与playbackRate属性\n- defaultPlaybackRate属性：可以使用video元素或者audio元素的defaultPlaybackRate属性读取或修改媒体默认的播放速率。\n- playbackRate属性：可以使用video元素或者audio元素的playbackRate属性读取或修改媒体当前的播放速率。\n### volume属性与muted属性\n- volume属性：使用video元素或audio元素的volume属性读取或修改媒体的播放音量，范围为0到1,0为静音，1为最大音量。\n- muted属性：使用video元素或audio元素的muted属性读取或修改媒体的静音状态，该值为布尔值，true表示处于静音状态，false表示处于非静音状态。\nHTML代码如下：\n```html\n<video id=\"video\" controls width=640 height=360 autoplay loop>\n    <source src=\"Wildlife/Wildlife.ogv\" type=\"video/ogg; codecs=\"theora, vorbis\"\"/>\n    <source src=\"Wildlife/Wildlife.webm\" type=\"video/webm\" >\n    <source src=\"Wildlife/Wildlife.mp4\" type=\"video/mp4\">\n    <p>Video is not visible, most likely your browser does not support HTML5 video</p>\n</video>\n<button onclick=\"volume()\" type=\"button\">读取或修改媒体的播放音量</button>\n<button onclick=\"muted()\" type=\"button\">读取或修改媒体当前的静音状态</button>\n```\n\nJS代码如下：\n```js\nvar myVid=document.getElementById(\"video\");\nfunction volume(){\n    // 读取或修改媒体的播放音量\n    myVid.volume = 0.1;\n}\nfunction muted() {\n    //读取或修改媒体当前的静音状态\n    myVid.muted = true;\n}\n```\n大家可以使用下，当我点击”读取或修改媒体的播放音量”按钮时候，声音会变的很小，当我点击”读取或修改媒体当前的静音状态”按钮时候，视频完全就没有声音。\n###方法\nvideo元素与audio元素有以下四种方法；\n- play方法：使用play方法来播放媒体，自动将元素的paused属性的值变为false。\n- pause方法：使用pause方法来暂停播放，自动将元素的paused属性的值变为true。\n- load方法，使用load方法来重新载入媒体进行播放，自动将元素的playbackRate属性的值变为defaultPlaybackRate属性的值，自动将元素的error的值变为null。\n下面是播放和暂停的demo如下：\n```html\n<video id=\"video\" controls width=640 height=360>\n    <source src=\"Wildlife/Wildlife.ogv\" type=\"video/ogg; codecs=\"theora, vorbis\"\"/>\n    <source src=\"Wildlife/Wildlife.webm\" type=\"video/webm\" >\n    <source src=\"Wildlife/Wildlife.mp4\" type=\"video/mp4\">\n    <p>Video is not visible, most likely your browser does not support HTML5 video</p>\n</video>\n<button onclick=\"play()\">播放</button>\n<button onclick=\"pause()\">暂停</button>\n```\nJS代码如下：\n```js\nvar myVid=document.getElementById(\"video\");\n// 监听视频播放结束的事件\nmyVid.addEventListener(\"ended\",function(){\n    alert(\"播放结束\");\n},true);\n// 发生错误\nmyVid.addEventListener(\"error\",function(){\n    switch(myVid.error.code) {\n        case 1: \n          alert(\"视频的下载过程被中止\");\n        break;\n\n        case 2:\n              alert(\"网络发生故障，视频的下载过程被中止\");\n        break;\n\n        case 3:\n              alert(\"解码失败\");\n        break;\n\n        case 4:\n              alert(\"不支持播放的视频格式\");\n        break;\n\n        default:\n              alert(\"发生未知错误\");\n        }\n},false);\n\nfunction play() {\n    // 播放视频\n    myVid.play();\n}\nfunction pause() {\n    // 暂停播放\n    myVid.pause();\n}\n```\n>如上代码，默认的情况下是不自动播放，当我点击播放按钮时候，就播放，当我点击暂停按钮时候就停止当前的播放。\n- canPlayType方法：\n使用canPlayType方法来测试浏览器是否支持指定的媒体类型，该方法定义如下：\n`var support = videoElement.canPlayType(type);`\nvideoElement表示页面上的video元素或audio元素，该方法使用一个参数type，该参数的指定方法与source元素的type参数的指定方法相同，用播放文件的MIME类型来指定，可以在指定的字符串中加上表示媒体编码格式的codes参数。\n该方法可能返回的值如下所示：\n1. 空字符串：表示浏览器不支持此种媒体类型。\n2. maybe: 表示浏览器可能支持此种媒体类型。\n3. probably： 表示浏览器确定支持此种媒体类型。\nHTML代码如下：\n```html\n<video id=\"video\" controls width=640 height=360>\n    <source src=\"Wildlife/Wildlife.ogv\" type=\"video/ogg; codecs=\"theora, vorbis\"\"/>\n    <source src=\"Wildlife/Wildlife.webm\" type=\"video/webm\" >\n    <source src=\"Wildlife/Wildlife.mp4\" type=\"video/mp4\">\n    <p>Video is not visible, most likely your browser does not support HTML5 video</p>\n</video>\n<button onclick=\"canPlayType()\">canPlayType方法</button>\n```\n\nJS代码如下：\n```js\nvar myVid=document.getElementById(\"video\");\nfunction canPlayType() {\n    var support = myVid.canPlayType(\"video/webm\");\n    console.log(support); // maybe\n\n    var support = myVid.canPlayType(\"video/ogg; codecs=\"theora, vorbis\");\n    console.log(support); // probably\n}\n```\n### 事件\n1. 事件处理方式\n\n使用video元素或audio元素的事件方式有2种，第一种是监听的方式，使用video元素或audio元素的addEventListener方法来对事件的发生进行监听，该方法定义如下：\n`videoElement.addEventListener(type,listener,userCapture);`\n\n如上的监听方式和我们的JS的监听的方式一样，不做详细介绍，我们来看看第二种事件监听方式是为javascript脚本中常见的获取事件句柄的方式，如下所示：\n```js\n<video id=”” src=””  onplay=”begin()”></video>\nfunction begin(){}\n```\n\n| 事件   |  描述   |\n| :---: | :---: |\n|   loadstart\t  |    浏览器开始在网上寻找媒体数据   |\n|progress| 浏览器正在获取媒体数据|\n| suspend|\t 浏览器暂停获取媒体数据，但是下载过程中并没有正常结束|\n |abort\t| 浏览器在下载完全部媒体数据之前中止获取媒体数据，但是并不是由错误引起的|\n |error|\t 获取媒体数据过程中出错|\n |emptied|\t 暂不考虑，可以网上看|\n |stalled|\t 浏览器尝试获取媒体数据失败|\n |play\t| 即将开始播放，当执行了play方法时触发，或数据下载后元素被设为autoplay|\n |pause\t| 播放暂停，当执行了pause方法触发|\n |loadedmetadata|\t 浏览器获取完媒体的时长和字节数|\n |loadeddata\t| 浏览器已加载完毕当前播放位置的媒体数据，准备播放|\n |waiting|\t 可以暂不看|\n |playing|\t 正在播放|\n |canplay|\t 浏览器能够播放媒体，但估计以当前播放速率不能直接将媒体播完，播放期间需要缓冲|\n |canplaythrough|\t 浏览器能够播放媒体，但估计以当前播放速率能将媒体播完，不再需要缓冲|\n |seeking|\t Seeking变为true，表示浏览器正在请求数据|\n |seeked|\t Seeking属性变为false，表面浏览器停止请求数据|\n |timeupdate|\t 当前播放位置发生改变，可能是播放过程中的自然改变，也可能是人为改变，或由于播放不能连续而发生的跳变。|\n |ended|\t 播放结束后停止播放|\n |ratechange\t| DefaultplaybackRate属性或playbackRate属性发生改变|\n |durationchange|\t 播放时长发生改变|\n |volumechange|\t volume属性或muted属性发生改变|\n \t \n","source":"_posts/video标签的属性和方法总结.md","raw":"---\ntitle: video标签的属性和方法总结\ndate: 2017-01-15 17:54:34\ncategories:\n- HTML5\n\ntags:\n- video\n- HTML5\n---\n最近想做一个弹幕插件，查了很多video标签的属性和方法\n\n### error属性\n\n   在正常读取时候，使用媒体数据的过程中，video元素或audio元素的error属性为null，但是任何时候只要出现错误，error属性将返回一个MediaError对象，该对象的code返回对应的错误状态，共有4个可能值：\n   \n* `MEDIA_ERR_ABORTED(数字值为1)`，媒体数据的下载过程由于用户的操作原因而被终止。\n- `MEDIA_ERR_NETWORK(数字值为2)`，确认媒体资源可用，但是在下载出现网络错误，媒体数据的下载过程被中止。\n<!-- more -->\n\n- `MEDIA_ERR_DECODE(数字值为3)`，确认媒体资源可用，但是解码时发生错误。\n- `MEDIA_ERR_SRC_NOT_SUPPORTED(数字值为4)`，媒体资源不可用或媒体格式不被支持。\n代码如下：\n```js\n<video src=\"\" id=\"videoElement\"></video>\n var video = document.getElementById(\"videoElement\");\n video.addEventListener(\"error\",function(){\n     var error = video.error;\n     swicth(error.code) {\n         case 1:\n            alert(\"视频的下载过程被中止\");\n         break;\n \n         case 2:\n            alert(\"网络发生故障，视频的下载过程被中止\");\n         break;\n \n         case 3:\n            alert(\"解码失败\");\n         break;\n \n         case 4:\n            alert(\"媒体资源不可用或媒体格式不被支持\");\n         break; \n \n     }\n },false);\n```\n### networkState属性\n\n在媒体数据加载过程中可以使用video元素或audio元素的networkState属性读取当前网络状态，共有4个可能的值；\n1．  NETWORK_EMPTY（数字值为0）：元素处于初始状态。\n2．  NETWORK_IDLE(数字值为1)，浏览器已选择好用什么编码格式来播放媒体，但是尚未建立网络连接。\n3．  NETWORK_LOADING(数字值为2)：媒体数据加载中\n4．  NETWORK_NO_SOURCE(数字值为3)，没有支持的编码格式，不执行加载。\n### currentTime属性与duration属性\n\nvideo元素或audio元素的currentTime属性来读取媒体的当前播放位置(单位是s)，也可以通过修改currentTime属性来修改当前播放位置，如果修改的位置上没有可用的媒体数据时，将抛出INVALID_STATE_ERR异常；\nvideo元素或audio元素的duration属性来读取媒体文件总的播放时间。\n我们可以来做demo如下：\nHTML代码如下：\n\n```html\n<video id=\"video\" controls width=640 height=360 autoplay>\n    <source src=\"Wildlife/Wildlife.ogv\" type=\"video/ogg; codecs=\"theora, vorbis\"\"/>\n    <source src=\"Wildlife/Wildlife.webm\" type=\"video/webm\" >\n    <source src=\"Wildlife/Wildlife.mp4\" type=\"video/mp4\">\n    <p>Video is not visible, most likely your browser does not support HTML5 video</p>\n</video>\n<button onclick=\"getCurTime()\" type=\"button\">获得当前时间的位置</button>\n<button onclick=\"setCurTime()\" type=\"button\">把时间位置设置为 5 秒</button>\n<button onclick=\"duration()\" type=\"button\">读取媒体文件总的播放时间</button>\n```\n \nJS代码如下：\n```js\nvar myVid=document.getElementById(\"video\");\nfunction getCurTime(){ \n    // 获得当前视频或者音频时间的位置\n    alert(myVid.currentTime);   \n} \nfunction setCurTime(){ \n// 给当前的视频或者音频设置5s时间的位置\n    myVid.currentTime=5;        \n} \nfunction duration() {\n    //读取媒体文件总的播放时间 单位为S\n    alert(myVid.duration); \n}\n```\n大家可以复制代码，换一张视频地址就可以看到效果了~；\n\n### played属性，paused属性与ended属性\n- played：video元素或audio元素的played属性来返回一个TimeRanges对象，从该对象中可以读取媒体文件的已播放部分的时间段。开始时间为已播放部分的开始时间，结束时间为已播放部分的结束时间。\n- paused属性：使用video元素或audio元素的paused属性来返回一个布尔值，表示是否处于暂停播放中，true表示媒体暂停播放，false表示媒体正在播放；\n- ended属性：使用video元素或audio元素的ended属性来返回一个布尔值，表示是否播放完毕，true表示媒体播放完毕，false表示媒体还没有播放完毕。\nHTML代码如下：\n```html\n    <video id=\"video\" controls width=640 height=360 autoplay loop>\n    <source src=\"Wildlife/Wildlife.ogv\" type=\"video/ogg; codecs=\"theora, vorbis\"\"/>\n    <source src=\"Wildlife/Wildlife.webm\" type=\"video/webm\" >\n    <source src=\"Wildlife/Wildlife.mp4\" type=\"video/mp4\">\n    <p>Video is not visible, most likely your browser does not support HTML5 video</p>\n    </video>\n    <button onclick=\"played()\" type=\"button\">读取媒体文件的已播放部分的时间段</button>\n    <button onclick=\"paused()\" type=\"button\">是否处于暂停播放</button>\n    <button onclick=\"ended()\" type=\"button\">是否播放完毕</button>\n```\n\nJS代码如下：\n```js\nvar myVid=document.getElementById(\"video\");\nfunction played() {\n    //读取媒体文件的已播放部分的时间段\n    console.log(myVid.played);\n}\nfunction paused() {\n    // 是否处于暂停播放\n    alert(myVid.paused);\n}\nfunction ended() {\n    // 是否播放完毕\n    alert(myVid.ended);\n}\n\n```\n### defaultPlaybackRate属性与playbackRate属性\n- defaultPlaybackRate属性：可以使用video元素或者audio元素的defaultPlaybackRate属性读取或修改媒体默认的播放速率。\n- playbackRate属性：可以使用video元素或者audio元素的playbackRate属性读取或修改媒体当前的播放速率。\n### volume属性与muted属性\n- volume属性：使用video元素或audio元素的volume属性读取或修改媒体的播放音量，范围为0到1,0为静音，1为最大音量。\n- muted属性：使用video元素或audio元素的muted属性读取或修改媒体的静音状态，该值为布尔值，true表示处于静音状态，false表示处于非静音状态。\nHTML代码如下：\n```html\n<video id=\"video\" controls width=640 height=360 autoplay loop>\n    <source src=\"Wildlife/Wildlife.ogv\" type=\"video/ogg; codecs=\"theora, vorbis\"\"/>\n    <source src=\"Wildlife/Wildlife.webm\" type=\"video/webm\" >\n    <source src=\"Wildlife/Wildlife.mp4\" type=\"video/mp4\">\n    <p>Video is not visible, most likely your browser does not support HTML5 video</p>\n</video>\n<button onclick=\"volume()\" type=\"button\">读取或修改媒体的播放音量</button>\n<button onclick=\"muted()\" type=\"button\">读取或修改媒体当前的静音状态</button>\n```\n\nJS代码如下：\n```js\nvar myVid=document.getElementById(\"video\");\nfunction volume(){\n    // 读取或修改媒体的播放音量\n    myVid.volume = 0.1;\n}\nfunction muted() {\n    //读取或修改媒体当前的静音状态\n    myVid.muted = true;\n}\n```\n大家可以使用下，当我点击”读取或修改媒体的播放音量”按钮时候，声音会变的很小，当我点击”读取或修改媒体当前的静音状态”按钮时候，视频完全就没有声音。\n###方法\nvideo元素与audio元素有以下四种方法；\n- play方法：使用play方法来播放媒体，自动将元素的paused属性的值变为false。\n- pause方法：使用pause方法来暂停播放，自动将元素的paused属性的值变为true。\n- load方法，使用load方法来重新载入媒体进行播放，自动将元素的playbackRate属性的值变为defaultPlaybackRate属性的值，自动将元素的error的值变为null。\n下面是播放和暂停的demo如下：\n```html\n<video id=\"video\" controls width=640 height=360>\n    <source src=\"Wildlife/Wildlife.ogv\" type=\"video/ogg; codecs=\"theora, vorbis\"\"/>\n    <source src=\"Wildlife/Wildlife.webm\" type=\"video/webm\" >\n    <source src=\"Wildlife/Wildlife.mp4\" type=\"video/mp4\">\n    <p>Video is not visible, most likely your browser does not support HTML5 video</p>\n</video>\n<button onclick=\"play()\">播放</button>\n<button onclick=\"pause()\">暂停</button>\n```\nJS代码如下：\n```js\nvar myVid=document.getElementById(\"video\");\n// 监听视频播放结束的事件\nmyVid.addEventListener(\"ended\",function(){\n    alert(\"播放结束\");\n},true);\n// 发生错误\nmyVid.addEventListener(\"error\",function(){\n    switch(myVid.error.code) {\n        case 1: \n          alert(\"视频的下载过程被中止\");\n        break;\n\n        case 2:\n              alert(\"网络发生故障，视频的下载过程被中止\");\n        break;\n\n        case 3:\n              alert(\"解码失败\");\n        break;\n\n        case 4:\n              alert(\"不支持播放的视频格式\");\n        break;\n\n        default:\n              alert(\"发生未知错误\");\n        }\n},false);\n\nfunction play() {\n    // 播放视频\n    myVid.play();\n}\nfunction pause() {\n    // 暂停播放\n    myVid.pause();\n}\n```\n>如上代码，默认的情况下是不自动播放，当我点击播放按钮时候，就播放，当我点击暂停按钮时候就停止当前的播放。\n- canPlayType方法：\n使用canPlayType方法来测试浏览器是否支持指定的媒体类型，该方法定义如下：\n`var support = videoElement.canPlayType(type);`\nvideoElement表示页面上的video元素或audio元素，该方法使用一个参数type，该参数的指定方法与source元素的type参数的指定方法相同，用播放文件的MIME类型来指定，可以在指定的字符串中加上表示媒体编码格式的codes参数。\n该方法可能返回的值如下所示：\n1. 空字符串：表示浏览器不支持此种媒体类型。\n2. maybe: 表示浏览器可能支持此种媒体类型。\n3. probably： 表示浏览器确定支持此种媒体类型。\nHTML代码如下：\n```html\n<video id=\"video\" controls width=640 height=360>\n    <source src=\"Wildlife/Wildlife.ogv\" type=\"video/ogg; codecs=\"theora, vorbis\"\"/>\n    <source src=\"Wildlife/Wildlife.webm\" type=\"video/webm\" >\n    <source src=\"Wildlife/Wildlife.mp4\" type=\"video/mp4\">\n    <p>Video is not visible, most likely your browser does not support HTML5 video</p>\n</video>\n<button onclick=\"canPlayType()\">canPlayType方法</button>\n```\n\nJS代码如下：\n```js\nvar myVid=document.getElementById(\"video\");\nfunction canPlayType() {\n    var support = myVid.canPlayType(\"video/webm\");\n    console.log(support); // maybe\n\n    var support = myVid.canPlayType(\"video/ogg; codecs=\"theora, vorbis\");\n    console.log(support); // probably\n}\n```\n### 事件\n1. 事件处理方式\n\n使用video元素或audio元素的事件方式有2种，第一种是监听的方式，使用video元素或audio元素的addEventListener方法来对事件的发生进行监听，该方法定义如下：\n`videoElement.addEventListener(type,listener,userCapture);`\n\n如上的监听方式和我们的JS的监听的方式一样，不做详细介绍，我们来看看第二种事件监听方式是为javascript脚本中常见的获取事件句柄的方式，如下所示：\n```js\n<video id=”” src=””  onplay=”begin()”></video>\nfunction begin(){}\n```\n\n| 事件   |  描述   |\n| :---: | :---: |\n|   loadstart\t  |    浏览器开始在网上寻找媒体数据   |\n|progress| 浏览器正在获取媒体数据|\n| suspend|\t 浏览器暂停获取媒体数据，但是下载过程中并没有正常结束|\n |abort\t| 浏览器在下载完全部媒体数据之前中止获取媒体数据，但是并不是由错误引起的|\n |error|\t 获取媒体数据过程中出错|\n |emptied|\t 暂不考虑，可以网上看|\n |stalled|\t 浏览器尝试获取媒体数据失败|\n |play\t| 即将开始播放，当执行了play方法时触发，或数据下载后元素被设为autoplay|\n |pause\t| 播放暂停，当执行了pause方法触发|\n |loadedmetadata|\t 浏览器获取完媒体的时长和字节数|\n |loadeddata\t| 浏览器已加载完毕当前播放位置的媒体数据，准备播放|\n |waiting|\t 可以暂不看|\n |playing|\t 正在播放|\n |canplay|\t 浏览器能够播放媒体，但估计以当前播放速率不能直接将媒体播完，播放期间需要缓冲|\n |canplaythrough|\t 浏览器能够播放媒体，但估计以当前播放速率能将媒体播完，不再需要缓冲|\n |seeking|\t Seeking变为true，表示浏览器正在请求数据|\n |seeked|\t Seeking属性变为false，表面浏览器停止请求数据|\n |timeupdate|\t 当前播放位置发生改变，可能是播放过程中的自然改变，也可能是人为改变，或由于播放不能连续而发生的跳变。|\n |ended|\t 播放结束后停止播放|\n |ratechange\t| DefaultplaybackRate属性或playbackRate属性发生改变|\n |durationchange|\t 播放时长发生改变|\n |volumechange|\t volume属性或muted属性发生改变|\n \t \n","slug":"video标签的属性和方法总结","published":1,"updated":"2017-02-20T06:33:54.204Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizhru6pt000josqph88gz4ji","content":"<p>最近想做一个弹幕插件，查了很多video标签的属性和方法</p>\n<h3 id=\"error属性\"><a href=\"#error属性\" class=\"headerlink\" title=\"error属性\"></a>error属性</h3><p>   在正常读取时候，使用媒体数据的过程中，video元素或audio元素的error属性为null，但是任何时候只要出现错误，error属性将返回一个MediaError对象，该对象的code返回对应的错误状态，共有4个可能值：</p>\n<ul>\n<li><code>MEDIA_ERR_ABORTED(数字值为1)</code>，媒体数据的下载过程由于用户的操作原因而被终止。</li>\n</ul>\n<ul>\n<li><p><code>MEDIA_ERR_NETWORK(数字值为2)</code>，确认媒体资源可用，但是在下载出现网络错误，媒体数据的下载过程被中止。</p>\n<a id=\"more\"></a>\n</li>\n<li><p><code>MEDIA_ERR_DECODE(数字值为3)</code>，确认媒体资源可用，但是解码时发生错误。</p>\n</li>\n<li><code>MEDIA_ERR_SRC_NOT_SUPPORTED(数字值为4)</code>，媒体资源不可用或媒体格式不被支持。<br>代码如下：<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;video src=<span class=\"string\">\"\"</span> id=<span class=\"string\">\"videoElement\"</span>&gt;&lt;/video&gt;</div><div class=\"line\"> <span class=\"keyword\">var</span> video = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"videoElement\"</span>);</div><div class=\"line\"> video.addEventListener(<span class=\"string\">\"error\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">     <span class=\"keyword\">var</span> error = video.error;</div><div class=\"line\">     swicth(error.code) &#123;</div><div class=\"line\">         <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</div><div class=\"line\">            alert(<span class=\"string\">\"视频的下载过程被中止\"</span>);</div><div class=\"line\">         <span class=\"keyword\">break</span>;</div><div class=\"line\"> </div><div class=\"line\">         <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</div><div class=\"line\">            alert(<span class=\"string\">\"网络发生故障，视频的下载过程被中止\"</span>);</div><div class=\"line\">         <span class=\"keyword\">break</span>;</div><div class=\"line\"> </div><div class=\"line\">         <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</div><div class=\"line\">            alert(<span class=\"string\">\"解码失败\"</span>);</div><div class=\"line\">         <span class=\"keyword\">break</span>;</div><div class=\"line\"> </div><div class=\"line\">         <span class=\"keyword\">case</span> <span class=\"number\">4</span>:</div><div class=\"line\">            alert(<span class=\"string\">\"媒体资源不可用或媒体格式不被支持\"</span>);</div><div class=\"line\">         <span class=\"keyword\">break</span>; </div><div class=\"line\"> </div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;,<span class=\"literal\">false</span>);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"networkState属性\"><a href=\"#networkState属性\" class=\"headerlink\" title=\"networkState属性\"></a>networkState属性</h3><p>在媒体数据加载过程中可以使用video元素或audio元素的networkState属性读取当前网络状态，共有4个可能的值；<br>1．  NETWORK_EMPTY（数字值为0）：元素处于初始状态。<br>2．  NETWORK_IDLE(数字值为1)，浏览器已选择好用什么编码格式来播放媒体，但是尚未建立网络连接。<br>3．  NETWORK_LOADING(数字值为2)：媒体数据加载中<br>4．  NETWORK_NO_SOURCE(数字值为3)，没有支持的编码格式，不执行加载。</p>\n<h3 id=\"currentTime属性与duration属性\"><a href=\"#currentTime属性与duration属性\" class=\"headerlink\" title=\"currentTime属性与duration属性\"></a>currentTime属性与duration属性</h3><p>video元素或audio元素的currentTime属性来读取媒体的当前播放位置(单位是s)，也可以通过修改currentTime属性来修改当前播放位置，如果修改的位置上没有可用的媒体数据时，将抛出INVALID_STATE_ERR异常；<br>video元素或audio元素的duration属性来读取媒体文件总的播放时间。<br>我们可以来做demo如下：<br>HTML代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">id</span>=<span class=\"string\">\"video\"</span> <span class=\"attr\">controls</span> <span class=\"attr\">width</span>=<span class=\"string\">640</span> <span class=\"attr\">height</span>=<span class=\"string\">360</span> <span class=\"attr\">autoplay</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.ogv\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/ogg; codecs=\"</span><span class=\"attr\">theora</span>, <span class=\"attr\">vorbis</span>\"\"/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.webm\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/webm\"</span> &gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.mp4\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/mp4\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Video is not visible, most likely your browser does not support HTML5 video<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">video</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"getCurTime()\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>获得当前时间的位置<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"setCurTime()\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>把时间位置设置为 5 秒<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"duration()\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>读取媒体文件总的播放时间<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>JS代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> myVid=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"video\"</span>);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCurTime</span>(<span class=\"params\"></span>)</span>&#123; </div><div class=\"line\">    <span class=\"comment\">// 获得当前视频或者音频时间的位置</span></div><div class=\"line\">    alert(myVid.currentTime);   </div><div class=\"line\">&#125; </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setCurTime</span>(<span class=\"params\"></span>)</span>&#123; </div><div class=\"line\"><span class=\"comment\">// 给当前的视频或者音频设置5s时间的位置</span></div><div class=\"line\">    myVid.currentTime=<span class=\"number\">5</span>;        </div><div class=\"line\">&#125; </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">duration</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//读取媒体文件总的播放时间 单位为S</span></div><div class=\"line\">    alert(myVid.duration); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>大家可以复制代码，换一张视频地址就可以看到效果了~；</p>\n<h3 id=\"played属性，paused属性与ended属性\"><a href=\"#played属性，paused属性与ended属性\" class=\"headerlink\" title=\"played属性，paused属性与ended属性\"></a>played属性，paused属性与ended属性</h3><ul>\n<li>played：video元素或audio元素的played属性来返回一个TimeRanges对象，从该对象中可以读取媒体文件的已播放部分的时间段。开始时间为已播放部分的开始时间，结束时间为已播放部分的结束时间。</li>\n<li>paused属性：使用video元素或audio元素的paused属性来返回一个布尔值，表示是否处于暂停播放中，true表示媒体暂停播放，false表示媒体正在播放；</li>\n<li>ended属性：使用video元素或audio元素的ended属性来返回一个布尔值，表示是否播放完毕，true表示媒体播放完毕，false表示媒体还没有播放完毕。<br>HTML代码如下：<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">id</span>=<span class=\"string\">\"video\"</span> <span class=\"attr\">controls</span> <span class=\"attr\">width</span>=<span class=\"string\">640</span> <span class=\"attr\">height</span>=<span class=\"string\">360</span> <span class=\"attr\">autoplay</span> <span class=\"attr\">loop</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.ogv\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/ogg; codecs=\"</span><span class=\"attr\">theora</span>, <span class=\"attr\">vorbis</span>\"\"/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.webm\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/webm\"</span> &gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.mp4\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/mp4\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Video is not visible, most likely your browser does not support HTML5 video<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">video</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"played()\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>读取媒体文件的已播放部分的时间段<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"paused()\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>是否处于暂停播放<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"ended()\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>是否播放完毕<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>JS代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> myVid=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"video\"</span>);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">played</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//读取媒体文件的已播放部分的时间段</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(myVid.played);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">paused</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 是否处于暂停播放</span></div><div class=\"line\">    alert(myVid.paused);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ended</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 是否播放完毕</span></div><div class=\"line\">    alert(myVid.ended);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"defaultPlaybackRate属性与playbackRate属性\"><a href=\"#defaultPlaybackRate属性与playbackRate属性\" class=\"headerlink\" title=\"defaultPlaybackRate属性与playbackRate属性\"></a>defaultPlaybackRate属性与playbackRate属性</h3><ul>\n<li>defaultPlaybackRate属性：可以使用video元素或者audio元素的defaultPlaybackRate属性读取或修改媒体默认的播放速率。</li>\n<li>playbackRate属性：可以使用video元素或者audio元素的playbackRate属性读取或修改媒体当前的播放速率。<h3 id=\"volume属性与muted属性\"><a href=\"#volume属性与muted属性\" class=\"headerlink\" title=\"volume属性与muted属性\"></a>volume属性与muted属性</h3></li>\n<li>volume属性：使用video元素或audio元素的volume属性读取或修改媒体的播放音量，范围为0到1,0为静音，1为最大音量。</li>\n<li>muted属性：使用video元素或audio元素的muted属性读取或修改媒体的静音状态，该值为布尔值，true表示处于静音状态，false表示处于非静音状态。<br>HTML代码如下：<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">id</span>=<span class=\"string\">\"video\"</span> <span class=\"attr\">controls</span> <span class=\"attr\">width</span>=<span class=\"string\">640</span> <span class=\"attr\">height</span>=<span class=\"string\">360</span> <span class=\"attr\">autoplay</span> <span class=\"attr\">loop</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.ogv\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/ogg; codecs=\"</span><span class=\"attr\">theora</span>, <span class=\"attr\">vorbis</span>\"\"/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.webm\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/webm\"</span> &gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.mp4\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/mp4\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Video is not visible, most likely your browser does not support HTML5 video<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">video</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"volume()\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>读取或修改媒体的播放音量<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"muted()\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>读取或修改媒体当前的静音状态<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>JS代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> myVid=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"video\"</span>);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">volume</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 读取或修改媒体的播放音量</span></div><div class=\"line\">    myVid.volume = <span class=\"number\">0.1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">muted</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//读取或修改媒体当前的静音状态</span></div><div class=\"line\">    myVid.muted = <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>大家可以使用下，当我点击”读取或修改媒体的播放音量”按钮时候，声音会变的很小，当我点击”读取或修改媒体当前的静音状态”按钮时候，视频完全就没有声音。</p>\n<p>###方法<br>video元素与audio元素有以下四种方法；</p>\n<ul>\n<li>play方法：使用play方法来播放媒体，自动将元素的paused属性的值变为false。</li>\n<li>pause方法：使用pause方法来暂停播放，自动将元素的paused属性的值变为true。</li>\n<li>load方法，使用load方法来重新载入媒体进行播放，自动将元素的playbackRate属性的值变为defaultPlaybackRate属性的值，自动将元素的error的值变为null。<br>下面是播放和暂停的demo如下：<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">id</span>=<span class=\"string\">\"video\"</span> <span class=\"attr\">controls</span> <span class=\"attr\">width</span>=<span class=\"string\">640</span> <span class=\"attr\">height</span>=<span class=\"string\">360</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.ogv\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/ogg; codecs=\"</span><span class=\"attr\">theora</span>, <span class=\"attr\">vorbis</span>\"\"/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.webm\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/webm\"</span> &gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.mp4\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/mp4\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Video is not visible, most likely your browser does not support HTML5 video<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">video</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"play()\"</span>&gt;</span>播放<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"pause()\"</span>&gt;</span>暂停<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>JS代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> myVid=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"video\"</span>);</div><div class=\"line\"><span class=\"comment\">// 监听视频播放结束的事件</span></div><div class=\"line\">myVid.addEventListener(<span class=\"string\">\"ended\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    alert(<span class=\"string\">\"播放结束\"</span>);</div><div class=\"line\">&#125;,<span class=\"literal\">true</span>);</div><div class=\"line\"><span class=\"comment\">// 发生错误</span></div><div class=\"line\">myVid.addEventListener(<span class=\"string\">\"error\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">switch</span>(myVid.error.code) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>: </div><div class=\"line\">          alert(<span class=\"string\">\"视频的下载过程被中止\"</span>);</div><div class=\"line\">        <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</div><div class=\"line\">              alert(<span class=\"string\">\"网络发生故障，视频的下载过程被中止\"</span>);</div><div class=\"line\">        <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</div><div class=\"line\">              alert(<span class=\"string\">\"解码失败\"</span>);</div><div class=\"line\">        <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">4</span>:</div><div class=\"line\">              alert(<span class=\"string\">\"不支持播放的视频格式\"</span>);</div><div class=\"line\">        <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">              alert(<span class=\"string\">\"发生未知错误\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;,<span class=\"literal\">false</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">play</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 播放视频</span></div><div class=\"line\">    myVid.play();</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pause</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 暂停播放</span></div><div class=\"line\">    myVid.pause();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>如上代码，默认的情况下是不自动播放，当我点击播放按钮时候，就播放，当我点击暂停按钮时候就停止当前的播放。</p>\n<ul>\n<li>canPlayType方法：<br>使用canPlayType方法来测试浏览器是否支持指定的媒体类型，该方法定义如下：<br><code>var support = videoElement.canPlayType(type);</code><br>videoElement表示页面上的video元素或audio元素，该方法使用一个参数type，该参数的指定方法与source元素的type参数的指定方法相同，用播放文件的MIME类型来指定，可以在指定的字符串中加上表示媒体编码格式的codes参数。<br>该方法可能返回的值如下所示：</li>\n</ul>\n<ol>\n<li>空字符串：表示浏览器不支持此种媒体类型。</li>\n<li>maybe: 表示浏览器可能支持此种媒体类型。</li>\n<li>probably： 表示浏览器确定支持此种媒体类型。<br>HTML代码如下：<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">id</span>=<span class=\"string\">\"video\"</span> <span class=\"attr\">controls</span> <span class=\"attr\">width</span>=<span class=\"string\">640</span> <span class=\"attr\">height</span>=<span class=\"string\">360</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.ogv\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/ogg; codecs=\"</span><span class=\"attr\">theora</span>, <span class=\"attr\">vorbis</span>\"\"/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.webm\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/webm\"</span> &gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.mp4\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/mp4\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Video is not visible, most likely your browser does not support HTML5 video<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">video</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"canPlayType()\"</span>&gt;</span>canPlayType方法<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<p>JS代码如下：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myVid=document.getElementById(\"video\");</div><div class=\"line\">function canPlayType() &#123;</div><div class=\"line\">    var support = myVid.canPlayType(\"video/webm\");</div><div class=\"line\">    console.log(support); // maybe</div><div class=\"line\"></div><div class=\"line\">    var support = myVid.canPlayType(\"video/ogg; codecs=\"theora, vorbis\");</div><div class=\"line\">    console.log(support); // probably</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h3><ol>\n<li>事件处理方式</li>\n</ol>\n<p>使用video元素或audio元素的事件方式有2种，第一种是监听的方式，使用video元素或audio元素的addEventListener方法来对事件的发生进行监听，该方法定义如下：<br><code>videoElement.addEventListener(type,listener,userCapture);</code></p>\n<p>如上的监听方式和我们的JS的监听的方式一样，不做详细介绍，我们来看看第二种事件监听方式是为javascript脚本中常见的获取事件句柄的方式，如下所示：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;video id=”” src=””  onplay=”begin()”&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">video</span>&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">begin</span>(<span class=\"params\"></span>)</span>&#123;&#125;</div></pre></td></tr></table></figure></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">事件</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">loadstart</td>\n<td style=\"text-align:center\">浏览器开始在网上寻找媒体数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">progress</td>\n<td style=\"text-align:center\">浏览器正在获取媒体数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">suspend</td>\n<td style=\"text-align:center\">浏览器暂停获取媒体数据，但是下载过程中并没有正常结束</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">abort</td>\n<td style=\"text-align:center\">浏览器在下载完全部媒体数据之前中止获取媒体数据，但是并不是由错误引起的</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">error</td>\n<td style=\"text-align:center\">获取媒体数据过程中出错</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">emptied</td>\n<td style=\"text-align:center\">暂不考虑，可以网上看</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">stalled</td>\n<td style=\"text-align:center\">浏览器尝试获取媒体数据失败</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">play</td>\n<td style=\"text-align:center\">即将开始播放，当执行了play方法时触发，或数据下载后元素被设为autoplay</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">pause</td>\n<td style=\"text-align:center\">播放暂停，当执行了pause方法触发</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">loadedmetadata</td>\n<td style=\"text-align:center\">浏览器获取完媒体的时长和字节数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">loadeddata</td>\n<td style=\"text-align:center\">浏览器已加载完毕当前播放位置的媒体数据，准备播放</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">waiting</td>\n<td style=\"text-align:center\">可以暂不看</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">playing</td>\n<td style=\"text-align:center\">正在播放</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">canplay</td>\n<td style=\"text-align:center\">浏览器能够播放媒体，但估计以当前播放速率不能直接将媒体播完，播放期间需要缓冲</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">canplaythrough</td>\n<td style=\"text-align:center\">浏览器能够播放媒体，但估计以当前播放速率能将媒体播完，不再需要缓冲</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">seeking</td>\n<td style=\"text-align:center\">Seeking变为true，表示浏览器正在请求数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">seeked</td>\n<td style=\"text-align:center\">Seeking属性变为false，表面浏览器停止请求数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">timeupdate</td>\n<td style=\"text-align:center\">当前播放位置发生改变，可能是播放过程中的自然改变，也可能是人为改变，或由于播放不能连续而发生的跳变。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ended</td>\n<td style=\"text-align:center\">播放结束后停止播放</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ratechange</td>\n<td style=\"text-align:center\">DefaultplaybackRate属性或playbackRate属性发生改变</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">durationchange</td>\n<td style=\"text-align:center\">播放时长发生改变</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">volumechange</td>\n<td style=\"text-align:center\">volume属性或muted属性发生改变</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"<p>最近想做一个弹幕插件，查了很多video标签的属性和方法</p>\n<h3 id=\"error属性\"><a href=\"#error属性\" class=\"headerlink\" title=\"error属性\"></a>error属性</h3><p>   在正常读取时候，使用媒体数据的过程中，video元素或audio元素的error属性为null，但是任何时候只要出现错误，error属性将返回一个MediaError对象，该对象的code返回对应的错误状态，共有4个可能值：</p>\n<ul>\n<li><code>MEDIA_ERR_ABORTED(数字值为1)</code>，媒体数据的下载过程由于用户的操作原因而被终止。</li>\n</ul>\n<ul>\n<li><p><code>MEDIA_ERR_NETWORK(数字值为2)</code>，确认媒体资源可用，但是在下载出现网络错误，媒体数据的下载过程被中止。</p>","more":"</li>\n<li><p><code>MEDIA_ERR_DECODE(数字值为3)</code>，确认媒体资源可用，但是解码时发生错误。</p>\n</li>\n<li><code>MEDIA_ERR_SRC_NOT_SUPPORTED(数字值为4)</code>，媒体资源不可用或媒体格式不被支持。<br>代码如下：<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;video src=<span class=\"string\">\"\"</span> id=<span class=\"string\">\"videoElement\"</span>&gt;&lt;/video&gt;</div><div class=\"line\"> <span class=\"keyword\">var</span> video = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"videoElement\"</span>);</div><div class=\"line\"> video.addEventListener(<span class=\"string\">\"error\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">     <span class=\"keyword\">var</span> error = video.error;</div><div class=\"line\">     swicth(error.code) &#123;</div><div class=\"line\">         <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</div><div class=\"line\">            alert(<span class=\"string\">\"视频的下载过程被中止\"</span>);</div><div class=\"line\">         <span class=\"keyword\">break</span>;</div><div class=\"line\"> </div><div class=\"line\">         <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</div><div class=\"line\">            alert(<span class=\"string\">\"网络发生故障，视频的下载过程被中止\"</span>);</div><div class=\"line\">         <span class=\"keyword\">break</span>;</div><div class=\"line\"> </div><div class=\"line\">         <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</div><div class=\"line\">            alert(<span class=\"string\">\"解码失败\"</span>);</div><div class=\"line\">         <span class=\"keyword\">break</span>;</div><div class=\"line\"> </div><div class=\"line\">         <span class=\"keyword\">case</span> <span class=\"number\">4</span>:</div><div class=\"line\">            alert(<span class=\"string\">\"媒体资源不可用或媒体格式不被支持\"</span>);</div><div class=\"line\">         <span class=\"keyword\">break</span>; </div><div class=\"line\"> </div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;,<span class=\"literal\">false</span>);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"networkState属性\"><a href=\"#networkState属性\" class=\"headerlink\" title=\"networkState属性\"></a>networkState属性</h3><p>在媒体数据加载过程中可以使用video元素或audio元素的networkState属性读取当前网络状态，共有4个可能的值；<br>1．  NETWORK_EMPTY（数字值为0）：元素处于初始状态。<br>2．  NETWORK_IDLE(数字值为1)，浏览器已选择好用什么编码格式来播放媒体，但是尚未建立网络连接。<br>3．  NETWORK_LOADING(数字值为2)：媒体数据加载中<br>4．  NETWORK_NO_SOURCE(数字值为3)，没有支持的编码格式，不执行加载。</p>\n<h3 id=\"currentTime属性与duration属性\"><a href=\"#currentTime属性与duration属性\" class=\"headerlink\" title=\"currentTime属性与duration属性\"></a>currentTime属性与duration属性</h3><p>video元素或audio元素的currentTime属性来读取媒体的当前播放位置(单位是s)，也可以通过修改currentTime属性来修改当前播放位置，如果修改的位置上没有可用的媒体数据时，将抛出INVALID_STATE_ERR异常；<br>video元素或audio元素的duration属性来读取媒体文件总的播放时间。<br>我们可以来做demo如下：<br>HTML代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">id</span>=<span class=\"string\">\"video\"</span> <span class=\"attr\">controls</span> <span class=\"attr\">width</span>=<span class=\"string\">640</span> <span class=\"attr\">height</span>=<span class=\"string\">360</span> <span class=\"attr\">autoplay</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.ogv\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/ogg; codecs=\"</span><span class=\"attr\">theora</span>, <span class=\"attr\">vorbis</span>\"\"/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.webm\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/webm\"</span> &gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.mp4\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/mp4\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Video is not visible, most likely your browser does not support HTML5 video<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">video</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"getCurTime()\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>获得当前时间的位置<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"setCurTime()\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>把时间位置设置为 5 秒<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"duration()\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>读取媒体文件总的播放时间<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>JS代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> myVid=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"video\"</span>);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCurTime</span>(<span class=\"params\"></span>)</span>&#123; </div><div class=\"line\">    <span class=\"comment\">// 获得当前视频或者音频时间的位置</span></div><div class=\"line\">    alert(myVid.currentTime);   </div><div class=\"line\">&#125; </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setCurTime</span>(<span class=\"params\"></span>)</span>&#123; </div><div class=\"line\"><span class=\"comment\">// 给当前的视频或者音频设置5s时间的位置</span></div><div class=\"line\">    myVid.currentTime=<span class=\"number\">5</span>;        </div><div class=\"line\">&#125; </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">duration</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//读取媒体文件总的播放时间 单位为S</span></div><div class=\"line\">    alert(myVid.duration); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>大家可以复制代码，换一张视频地址就可以看到效果了~；</p>\n<h3 id=\"played属性，paused属性与ended属性\"><a href=\"#played属性，paused属性与ended属性\" class=\"headerlink\" title=\"played属性，paused属性与ended属性\"></a>played属性，paused属性与ended属性</h3><ul>\n<li>played：video元素或audio元素的played属性来返回一个TimeRanges对象，从该对象中可以读取媒体文件的已播放部分的时间段。开始时间为已播放部分的开始时间，结束时间为已播放部分的结束时间。</li>\n<li>paused属性：使用video元素或audio元素的paused属性来返回一个布尔值，表示是否处于暂停播放中，true表示媒体暂停播放，false表示媒体正在播放；</li>\n<li>ended属性：使用video元素或audio元素的ended属性来返回一个布尔值，表示是否播放完毕，true表示媒体播放完毕，false表示媒体还没有播放完毕。<br>HTML代码如下：<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">id</span>=<span class=\"string\">\"video\"</span> <span class=\"attr\">controls</span> <span class=\"attr\">width</span>=<span class=\"string\">640</span> <span class=\"attr\">height</span>=<span class=\"string\">360</span> <span class=\"attr\">autoplay</span> <span class=\"attr\">loop</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.ogv\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/ogg; codecs=\"</span><span class=\"attr\">theora</span>, <span class=\"attr\">vorbis</span>\"\"/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.webm\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/webm\"</span> &gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.mp4\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/mp4\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Video is not visible, most likely your browser does not support HTML5 video<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">video</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"played()\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>读取媒体文件的已播放部分的时间段<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"paused()\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>是否处于暂停播放<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"ended()\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>是否播放完毕<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>JS代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> myVid=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"video\"</span>);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">played</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//读取媒体文件的已播放部分的时间段</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(myVid.played);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">paused</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 是否处于暂停播放</span></div><div class=\"line\">    alert(myVid.paused);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ended</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 是否播放完毕</span></div><div class=\"line\">    alert(myVid.ended);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"defaultPlaybackRate属性与playbackRate属性\"><a href=\"#defaultPlaybackRate属性与playbackRate属性\" class=\"headerlink\" title=\"defaultPlaybackRate属性与playbackRate属性\"></a>defaultPlaybackRate属性与playbackRate属性</h3><ul>\n<li>defaultPlaybackRate属性：可以使用video元素或者audio元素的defaultPlaybackRate属性读取或修改媒体默认的播放速率。</li>\n<li>playbackRate属性：可以使用video元素或者audio元素的playbackRate属性读取或修改媒体当前的播放速率。<h3 id=\"volume属性与muted属性\"><a href=\"#volume属性与muted属性\" class=\"headerlink\" title=\"volume属性与muted属性\"></a>volume属性与muted属性</h3></li>\n<li>volume属性：使用video元素或audio元素的volume属性读取或修改媒体的播放音量，范围为0到1,0为静音，1为最大音量。</li>\n<li>muted属性：使用video元素或audio元素的muted属性读取或修改媒体的静音状态，该值为布尔值，true表示处于静音状态，false表示处于非静音状态。<br>HTML代码如下：<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">id</span>=<span class=\"string\">\"video\"</span> <span class=\"attr\">controls</span> <span class=\"attr\">width</span>=<span class=\"string\">640</span> <span class=\"attr\">height</span>=<span class=\"string\">360</span> <span class=\"attr\">autoplay</span> <span class=\"attr\">loop</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.ogv\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/ogg; codecs=\"</span><span class=\"attr\">theora</span>, <span class=\"attr\">vorbis</span>\"\"/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.webm\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/webm\"</span> &gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.mp4\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/mp4\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Video is not visible, most likely your browser does not support HTML5 video<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">video</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"volume()\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>读取或修改媒体的播放音量<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"muted()\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>读取或修改媒体当前的静音状态<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>JS代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> myVid=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"video\"</span>);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">volume</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 读取或修改媒体的播放音量</span></div><div class=\"line\">    myVid.volume = <span class=\"number\">0.1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">muted</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//读取或修改媒体当前的静音状态</span></div><div class=\"line\">    myVid.muted = <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>大家可以使用下，当我点击”读取或修改媒体的播放音量”按钮时候，声音会变的很小，当我点击”读取或修改媒体当前的静音状态”按钮时候，视频完全就没有声音。</p>\n<p>###方法<br>video元素与audio元素有以下四种方法；</p>\n<ul>\n<li>play方法：使用play方法来播放媒体，自动将元素的paused属性的值变为false。</li>\n<li>pause方法：使用pause方法来暂停播放，自动将元素的paused属性的值变为true。</li>\n<li>load方法，使用load方法来重新载入媒体进行播放，自动将元素的playbackRate属性的值变为defaultPlaybackRate属性的值，自动将元素的error的值变为null。<br>下面是播放和暂停的demo如下：<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">id</span>=<span class=\"string\">\"video\"</span> <span class=\"attr\">controls</span> <span class=\"attr\">width</span>=<span class=\"string\">640</span> <span class=\"attr\">height</span>=<span class=\"string\">360</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.ogv\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/ogg; codecs=\"</span><span class=\"attr\">theora</span>, <span class=\"attr\">vorbis</span>\"\"/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.webm\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/webm\"</span> &gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.mp4\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/mp4\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Video is not visible, most likely your browser does not support HTML5 video<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">video</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"play()\"</span>&gt;</span>播放<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"pause()\"</span>&gt;</span>暂停<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>JS代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> myVid=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"video\"</span>);</div><div class=\"line\"><span class=\"comment\">// 监听视频播放结束的事件</span></div><div class=\"line\">myVid.addEventListener(<span class=\"string\">\"ended\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    alert(<span class=\"string\">\"播放结束\"</span>);</div><div class=\"line\">&#125;,<span class=\"literal\">true</span>);</div><div class=\"line\"><span class=\"comment\">// 发生错误</span></div><div class=\"line\">myVid.addEventListener(<span class=\"string\">\"error\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">switch</span>(myVid.error.code) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>: </div><div class=\"line\">          alert(<span class=\"string\">\"视频的下载过程被中止\"</span>);</div><div class=\"line\">        <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</div><div class=\"line\">              alert(<span class=\"string\">\"网络发生故障，视频的下载过程被中止\"</span>);</div><div class=\"line\">        <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</div><div class=\"line\">              alert(<span class=\"string\">\"解码失败\"</span>);</div><div class=\"line\">        <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">4</span>:</div><div class=\"line\">              alert(<span class=\"string\">\"不支持播放的视频格式\"</span>);</div><div class=\"line\">        <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">              alert(<span class=\"string\">\"发生未知错误\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;,<span class=\"literal\">false</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">play</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 播放视频</span></div><div class=\"line\">    myVid.play();</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pause</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 暂停播放</span></div><div class=\"line\">    myVid.pause();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>如上代码，默认的情况下是不自动播放，当我点击播放按钮时候，就播放，当我点击暂停按钮时候就停止当前的播放。</p>\n<ul>\n<li>canPlayType方法：<br>使用canPlayType方法来测试浏览器是否支持指定的媒体类型，该方法定义如下：<br><code>var support = videoElement.canPlayType(type);</code><br>videoElement表示页面上的video元素或audio元素，该方法使用一个参数type，该参数的指定方法与source元素的type参数的指定方法相同，用播放文件的MIME类型来指定，可以在指定的字符串中加上表示媒体编码格式的codes参数。<br>该方法可能返回的值如下所示：</li>\n</ul>\n<ol>\n<li>空字符串：表示浏览器不支持此种媒体类型。</li>\n<li>maybe: 表示浏览器可能支持此种媒体类型。</li>\n<li>probably： 表示浏览器确定支持此种媒体类型。<br>HTML代码如下：<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">id</span>=<span class=\"string\">\"video\"</span> <span class=\"attr\">controls</span> <span class=\"attr\">width</span>=<span class=\"string\">640</span> <span class=\"attr\">height</span>=<span class=\"string\">360</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.ogv\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/ogg; codecs=\"</span><span class=\"attr\">theora</span>, <span class=\"attr\">vorbis</span>\"\"/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.webm\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/webm\"</span> &gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Wildlife/Wildlife.mp4\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/mp4\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Video is not visible, most likely your browser does not support HTML5 video<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">video</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"canPlayType()\"</span>&gt;</span>canPlayType方法<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<p>JS代码如下：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myVid=document.getElementById(\"video\");</div><div class=\"line\">function canPlayType() &#123;</div><div class=\"line\">    var support = myVid.canPlayType(\"video/webm\");</div><div class=\"line\">    console.log(support); // maybe</div><div class=\"line\"></div><div class=\"line\">    var support = myVid.canPlayType(\"video/ogg; codecs=\"theora, vorbis\");</div><div class=\"line\">    console.log(support); // probably</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h3><ol>\n<li>事件处理方式</li>\n</ol>\n<p>使用video元素或audio元素的事件方式有2种，第一种是监听的方式，使用video元素或audio元素的addEventListener方法来对事件的发生进行监听，该方法定义如下：<br><code>videoElement.addEventListener(type,listener,userCapture);</code></p>\n<p>如上的监听方式和我们的JS的监听的方式一样，不做详细介绍，我们来看看第二种事件监听方式是为javascript脚本中常见的获取事件句柄的方式，如下所示：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;video id=”” src=””  onplay=”begin()”&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">video</span>&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">begin</span>(<span class=\"params\"></span>)</span>&#123;&#125;</div></pre></td></tr></table></figure></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">事件</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">loadstart</td>\n<td style=\"text-align:center\">浏览器开始在网上寻找媒体数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">progress</td>\n<td style=\"text-align:center\">浏览器正在获取媒体数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">suspend</td>\n<td style=\"text-align:center\">浏览器暂停获取媒体数据，但是下载过程中并没有正常结束</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">abort</td>\n<td style=\"text-align:center\">浏览器在下载完全部媒体数据之前中止获取媒体数据，但是并不是由错误引起的</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">error</td>\n<td style=\"text-align:center\">获取媒体数据过程中出错</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">emptied</td>\n<td style=\"text-align:center\">暂不考虑，可以网上看</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">stalled</td>\n<td style=\"text-align:center\">浏览器尝试获取媒体数据失败</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">play</td>\n<td style=\"text-align:center\">即将开始播放，当执行了play方法时触发，或数据下载后元素被设为autoplay</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">pause</td>\n<td style=\"text-align:center\">播放暂停，当执行了pause方法触发</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">loadedmetadata</td>\n<td style=\"text-align:center\">浏览器获取完媒体的时长和字节数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">loadeddata</td>\n<td style=\"text-align:center\">浏览器已加载完毕当前播放位置的媒体数据，准备播放</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">waiting</td>\n<td style=\"text-align:center\">可以暂不看</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">playing</td>\n<td style=\"text-align:center\">正在播放</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">canplay</td>\n<td style=\"text-align:center\">浏览器能够播放媒体，但估计以当前播放速率不能直接将媒体播完，播放期间需要缓冲</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">canplaythrough</td>\n<td style=\"text-align:center\">浏览器能够播放媒体，但估计以当前播放速率能将媒体播完，不再需要缓冲</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">seeking</td>\n<td style=\"text-align:center\">Seeking变为true，表示浏览器正在请求数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">seeked</td>\n<td style=\"text-align:center\">Seeking属性变为false，表面浏览器停止请求数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">timeupdate</td>\n<td style=\"text-align:center\">当前播放位置发生改变，可能是播放过程中的自然改变，也可能是人为改变，或由于播放不能连续而发生的跳变。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ended</td>\n<td style=\"text-align:center\">播放结束后停止播放</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ratechange</td>\n<td style=\"text-align:center\">DefaultplaybackRate属性或playbackRate属性发生改变</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">durationchange</td>\n<td style=\"text-align:center\">播放时长发生改变</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">volumechange</td>\n<td style=\"text-align:center\">volume属性或muted属性发生改变</td>\n</tr>\n</tbody>\n</table>"},{"title":"高级程序设计（第三版）笔记","date":"2017-01-18T04:43:13.000Z","_content":"\n本文是第二遍系统的读高级程序语言设计（第三版）时的笔记，包括\n\n- 平时用的比较少，记忆不深刻的方法API\n- 结合写代码中遇到的坑与书中知识点的印证（主要是原型和构造对象模式的知识点）\n- 笔记没有追求全面，只是对于知识点查漏补缺的索引\n\n<!-- more -->\n\n## Object [ prop ]和Object.prop的区别\n\n 1. 语法方面的区别 点表示法的对象的属性名是标识符，而后者的属性名则是一个字符串。\n 2. 灵活性方面的区别 在JavaScript编写程序中，可以为对象创建任意数目的属性。但使用\".\"运算符来存取一个对象的属性时，属性名是用标识符表示的。而在JavaScript程序中，标识符必须被逐字地输入，它们不是一种数据类型，因此程序不能对其操作。也就是说，标识符是静态的，在程序中必须对其进行硬编码。 而使用数组[]表示法来存取一个对象的属性时，属性名是用字符串表示的。字符串是JavaScript的一种数据类型，因此可以在程序运行中操作并创建它们。\n 3. 性能方面区别 数组[]表示法在存取属性值时会进行表达式运行。而点表示法是直接存取属性值，理论上执行效率会比数组表示法高。性能方面其实可以忽略。 某些场景必须用到数组表示法来动态存取属性值，这个是点表示法无法做到的。\n\n  ```js\n  var prop='name',object={name:'dasda'};\n         console.log(object[prop]);  //dasda\n         console.log(object.prop);   //undefined\n  ```\n\n 4. 总的来说，这两种方法区别上不大，都有对应的使用场景。点表示法一般作为静态对象使用时来存取属性。而数组表示法在动态存取属性时就非常有用。\n\n## arguments和命名参数单向同步\n\n```javascript\nfunction add(num1,num2){\n          arguments[1]=10;\n          alert(arguments[0]+num2);\n     }\n```\n\n- 执行add（）会重写第二个参数，arguments对象中的值会自动反应到命名参数，但这是单向的，也就是改变命名参数的值但是arguments对象中的值不会改变，\n- 严格模式中不能设置argumengts对象的值\n\n  ### typeof和instanceof\n\n- 因为typeof检测引用类型值时，不同浏览器会有不同的结果，所以推荐只用typeof检测基本数据类型，检测值是否存在\n- instanceof\n\n  - 语法 person instanceof Object\n  - 用来检测引用类型\n\n## Array类型的方法\n\n### Array.isArray()方法\n\n- 解决多个全局执行环境时（多个框架），Array构造函数不同，instanceof你能正确检测对象是不是数组的问题\n- 支持该方法的浏览器：IE9+、Firefox4+、Safari 5+、Opera 10.5+和Chrome\n\n### Array.sort()\n\n- 无论数组项是不是数值，都会调用每一项的tostring（）方法，然后比较字符串。\n\n  ```javascript\n  var values=[0,1,5,10,15];\n  alert(values.sort()); //0,1,10,15,5\n  ```\n\n- sort()方法可以传一个比较函数，比较函数接受两个参数（a，b），a>b 返回1，a< b,返回-1，相等返回0。\n\n  ```javascript\n  function compare(a,b){\n    if(a >b ){\n        return 1;\n    }else if (a < b ){\n        return -1;\n    }else{\n        return 0;\n    }\n  }\n  ```\n\n### slice()方法\n\n- slice(startIndex,endIndex)\n- 返回起始到结束位置之间的项，不包括结束位置,只传入一个参数时，返回索引位置到结束的所有项\n- 不会影响原数组\n\n  ```javascript\n  var value=[1,5,7,3,8,2];\n  var value1=value.slice(2,5);\n  var value2=value.slice(2);\n  alert(value1,'$$$$$'+value2);  //7,3,8$$$$$7,3,8,2\n  ```\n\n### splice()方法\n\n- splice(startIndex,count,item) //(起始位置，项数，插入项）\n- 返回删除的项\n\n  ```javascript\n  var value=[1,5,7,3,8,2] ;\n  alert(value.splice(2,1,1,2,3)); // 7\n  alert(value); // 1,5,1,2,3,3,8,2\n  ```\n\n### indexOf()和lastIndexOf()方法\n\n- indexof(item,startIndex)||lastIndexOf(item,startIndex) // (项的值,起始位置）\n- 查找比较时使用全等操作符\n\n  ```javascript\n  var value=[1,5,7,3,5,8,2];\n  alert(value.indexOf(5)); //1\n  alert(value.lastIndexOf(5)); //4\n  alert(value.indexOf(5,2)); //4\n  alert(value.lastIndexOf(5,3)) //1\n  ```\n\n### every()和some()方法\n\n- every(fn)，传入函数对**每一**项都返回`true`，这个方法返回`true`\n- some(fn),传入函数对**任一**项返回`true`，这个方法就返回`true`\n\n### filter()\n\n- filter(fn)\n- 返回该函数会返回`true`的项组成的数组\n\n### forEach()和map()方法\n\n- forEach(item,index,array) || map(item,index,array)\n- forEach没有返回值,map会返回一个每一项执行函数后返回的值组成的数组\n\n  ```javascript\n  var arr1=[1,5,9,43,65,7];\n    var arrMap=arr1.map(function (item,index,array){\n        return item*2\n    });\n    alert(arrMap);//2,10,18,86,130,14\n    alert(arr1);//1,5,9,43,65,7\n    var arrFor=arr1.forEach(function(item,index,array){\n        return item*2\n    });\n    alert(arrFor);//undefined\n    alert(arr1);//1,5,9,43,65,7\n  ```\n\n## string\n\n### trim()、trimLeft()、trimRight()方法\n\n- trim()返回删除前置和后缀空格以后的String副本，对原数据无改变\n- trimLeft(),trimRight()分别删除前置和后缀空格\n\n## 面向对象的程序设计\n\n面向对象的程序设计中的描述符等暂时想不到哪里能用到，用到再精读。这里说一下遇到的一个，如下\n\n```javascript\nfunction Pig() {\n}\nPig.prototype = {\n\n    init: function () {\n    },\n    move: function () {\n    },\n    render: function () {\n        this.move();\n        console.log(this)\n    }\n};\nvar pigPlayer=new Pig();\nsetInterval(pigPlayer.render.bind(pigPlayer),1000);\n```\n\n重写原型时会造成`Pig.prototype.constructor===Pig//false`,而像下面重写会造成`constructor`变为可枚举属性。记一下这个坑，非要爬坑详见高程P155.\n\n```js\nPig.prototype = {\n\n    constructor:Pig,\n\n    init: function () {\n    },\n    move: function () {\n    },\n    render: function () {\n        this.move();\n        console.log(this)\n    }\n};\n```\n\n### 原型链\n\n这里只说一个我第一次接触时的误区，**构造函数创建的实例中是没有`prototype`这个属性的，只有`_proto_`,所以本质上我们所说的实例的原型是构造器函数的原型**，如下\n\n```javascript\nvar Yo=function () {\n            this.name='ddd'\n        };\n        var yo=new Yo;\n        console.dir(yo);\n        //Yo  \n        //展开后    //name:'ddd'\n                //_proto_:Object\n        console.dir(Yo)\n        //function Yo()\n       //展开后  //arguments:null\n                //caller:null\n                //length:0\n                //name:\"Yo\"\n                //prototype:Object\n                //__proto__:()\n                //[[FunctionLocation]]:test.html:22\n                //[[Scopes]]:Scopes[1]\n    }\n```\n\n对于这部分更详细的内容，直接细看这一章\n\n## 方法\n\n### number<>string\n\n- parseInt（string，进制数） `parseInt（‘11dsad’，10）>>>11`\n\n- toString() Number>>>String时可传参数（进制数） `10.toString(2)>>>'1010'`\n\n### array<>string\n\n- `arr.join(param)` @param 分隔符 String格式\n- `string.split(param) @param 识别分隔符 String格式\n\n  ```javascript\n  var a='hello',b='llohe';\n     var isTrue=()=>a.split('').sort()===b.split('').sort()?true:false;\n     isTrue();// true\n  ```\n\n### for-in语句\n\n- 枚举对象属性\n\n  ```javascript\nfor(var prop in Object){\n          do something...\n     {\n  ```\n\n\n\n### switch的有趣用法\n\n\n\n  ```javascript\nvar num=25;\n     switch(true){\n          case num<0:break;\n          case num>0:break;\n          default:break;\n     }\n  ```\n\n- switch语句中 默认使用全等符 `===`\n","source":"_posts/高程笔记.md","raw":"---\ntitle: 高级程序设计（第三版）笔记\ndate: 2017-01-18T12:43:13.000Z\ncategories:\n  - JavaScript\ntags:\n  - JavaScript\n  - 读书\n---\n\n本文是第二遍系统的读高级程序语言设计（第三版）时的笔记，包括\n\n- 平时用的比较少，记忆不深刻的方法API\n- 结合写代码中遇到的坑与书中知识点的印证（主要是原型和构造对象模式的知识点）\n- 笔记没有追求全面，只是对于知识点查漏补缺的索引\n\n<!-- more -->\n\n## Object [ prop ]和Object.prop的区别\n\n 1. 语法方面的区别 点表示法的对象的属性名是标识符，而后者的属性名则是一个字符串。\n 2. 灵活性方面的区别 在JavaScript编写程序中，可以为对象创建任意数目的属性。但使用\".\"运算符来存取一个对象的属性时，属性名是用标识符表示的。而在JavaScript程序中，标识符必须被逐字地输入，它们不是一种数据类型，因此程序不能对其操作。也就是说，标识符是静态的，在程序中必须对其进行硬编码。 而使用数组[]表示法来存取一个对象的属性时，属性名是用字符串表示的。字符串是JavaScript的一种数据类型，因此可以在程序运行中操作并创建它们。\n 3. 性能方面区别 数组[]表示法在存取属性值时会进行表达式运行。而点表示法是直接存取属性值，理论上执行效率会比数组表示法高。性能方面其实可以忽略。 某些场景必须用到数组表示法来动态存取属性值，这个是点表示法无法做到的。\n\n  ```js\n  var prop='name',object={name:'dasda'};\n         console.log(object[prop]);  //dasda\n         console.log(object.prop);   //undefined\n  ```\n\n 4. 总的来说，这两种方法区别上不大，都有对应的使用场景。点表示法一般作为静态对象使用时来存取属性。而数组表示法在动态存取属性时就非常有用。\n\n## arguments和命名参数单向同步\n\n```javascript\nfunction add(num1,num2){\n          arguments[1]=10;\n          alert(arguments[0]+num2);\n     }\n```\n\n- 执行add（）会重写第二个参数，arguments对象中的值会自动反应到命名参数，但这是单向的，也就是改变命名参数的值但是arguments对象中的值不会改变，\n- 严格模式中不能设置argumengts对象的值\n\n  ### typeof和instanceof\n\n- 因为typeof检测引用类型值时，不同浏览器会有不同的结果，所以推荐只用typeof检测基本数据类型，检测值是否存在\n- instanceof\n\n  - 语法 person instanceof Object\n  - 用来检测引用类型\n\n## Array类型的方法\n\n### Array.isArray()方法\n\n- 解决多个全局执行环境时（多个框架），Array构造函数不同，instanceof你能正确检测对象是不是数组的问题\n- 支持该方法的浏览器：IE9+、Firefox4+、Safari 5+、Opera 10.5+和Chrome\n\n### Array.sort()\n\n- 无论数组项是不是数值，都会调用每一项的tostring（）方法，然后比较字符串。\n\n  ```javascript\n  var values=[0,1,5,10,15];\n  alert(values.sort()); //0,1,10,15,5\n  ```\n\n- sort()方法可以传一个比较函数，比较函数接受两个参数（a，b），a>b 返回1，a< b,返回-1，相等返回0。\n\n  ```javascript\n  function compare(a,b){\n    if(a >b ){\n        return 1;\n    }else if (a < b ){\n        return -1;\n    }else{\n        return 0;\n    }\n  }\n  ```\n\n### slice()方法\n\n- slice(startIndex,endIndex)\n- 返回起始到结束位置之间的项，不包括结束位置,只传入一个参数时，返回索引位置到结束的所有项\n- 不会影响原数组\n\n  ```javascript\n  var value=[1,5,7,3,8,2];\n  var value1=value.slice(2,5);\n  var value2=value.slice(2);\n  alert(value1,'$$$$$'+value2);  //7,3,8$$$$$7,3,8,2\n  ```\n\n### splice()方法\n\n- splice(startIndex,count,item) //(起始位置，项数，插入项）\n- 返回删除的项\n\n  ```javascript\n  var value=[1,5,7,3,8,2] ;\n  alert(value.splice(2,1,1,2,3)); // 7\n  alert(value); // 1,5,1,2,3,3,8,2\n  ```\n\n### indexOf()和lastIndexOf()方法\n\n- indexof(item,startIndex)||lastIndexOf(item,startIndex) // (项的值,起始位置）\n- 查找比较时使用全等操作符\n\n  ```javascript\n  var value=[1,5,7,3,5,8,2];\n  alert(value.indexOf(5)); //1\n  alert(value.lastIndexOf(5)); //4\n  alert(value.indexOf(5,2)); //4\n  alert(value.lastIndexOf(5,3)) //1\n  ```\n\n### every()和some()方法\n\n- every(fn)，传入函数对**每一**项都返回`true`，这个方法返回`true`\n- some(fn),传入函数对**任一**项返回`true`，这个方法就返回`true`\n\n### filter()\n\n- filter(fn)\n- 返回该函数会返回`true`的项组成的数组\n\n### forEach()和map()方法\n\n- forEach(item,index,array) || map(item,index,array)\n- forEach没有返回值,map会返回一个每一项执行函数后返回的值组成的数组\n\n  ```javascript\n  var arr1=[1,5,9,43,65,7];\n    var arrMap=arr1.map(function (item,index,array){\n        return item*2\n    });\n    alert(arrMap);//2,10,18,86,130,14\n    alert(arr1);//1,5,9,43,65,7\n    var arrFor=arr1.forEach(function(item,index,array){\n        return item*2\n    });\n    alert(arrFor);//undefined\n    alert(arr1);//1,5,9,43,65,7\n  ```\n\n## string\n\n### trim()、trimLeft()、trimRight()方法\n\n- trim()返回删除前置和后缀空格以后的String副本，对原数据无改变\n- trimLeft(),trimRight()分别删除前置和后缀空格\n\n## 面向对象的程序设计\n\n面向对象的程序设计中的描述符等暂时想不到哪里能用到，用到再精读。这里说一下遇到的一个，如下\n\n```javascript\nfunction Pig() {\n}\nPig.prototype = {\n\n    init: function () {\n    },\n    move: function () {\n    },\n    render: function () {\n        this.move();\n        console.log(this)\n    }\n};\nvar pigPlayer=new Pig();\nsetInterval(pigPlayer.render.bind(pigPlayer),1000);\n```\n\n重写原型时会造成`Pig.prototype.constructor===Pig//false`,而像下面重写会造成`constructor`变为可枚举属性。记一下这个坑，非要爬坑详见高程P155.\n\n```js\nPig.prototype = {\n\n    constructor:Pig,\n\n    init: function () {\n    },\n    move: function () {\n    },\n    render: function () {\n        this.move();\n        console.log(this)\n    }\n};\n```\n\n### 原型链\n\n这里只说一个我第一次接触时的误区，**构造函数创建的实例中是没有`prototype`这个属性的，只有`_proto_`,所以本质上我们所说的实例的原型是构造器函数的原型**，如下\n\n```javascript\nvar Yo=function () {\n            this.name='ddd'\n        };\n        var yo=new Yo;\n        console.dir(yo);\n        //Yo  \n        //展开后    //name:'ddd'\n                //_proto_:Object\n        console.dir(Yo)\n        //function Yo()\n       //展开后  //arguments:null\n                //caller:null\n                //length:0\n                //name:\"Yo\"\n                //prototype:Object\n                //__proto__:()\n                //[[FunctionLocation]]:test.html:22\n                //[[Scopes]]:Scopes[1]\n    }\n```\n\n对于这部分更详细的内容，直接细看这一章\n\n## 方法\n\n### number<>string\n\n- parseInt（string，进制数） `parseInt（‘11dsad’，10）>>>11`\n\n- toString() Number>>>String时可传参数（进制数） `10.toString(2)>>>'1010'`\n\n### array<>string\n\n- `arr.join(param)` @param 分隔符 String格式\n- `string.split(param) @param 识别分隔符 String格式\n\n  ```javascript\n  var a='hello',b='llohe';\n     var isTrue=()=>a.split('').sort()===b.split('').sort()?true:false;\n     isTrue();// true\n  ```\n\n### for-in语句\n\n- 枚举对象属性\n\n  ```javascript\nfor(var prop in Object){\n          do something...\n     {\n  ```\n\n\n\n### switch的有趣用法\n\n\n\n  ```javascript\nvar num=25;\n     switch(true){\n          case num<0:break;\n          case num>0:break;\n          default:break;\n     }\n  ```\n\n- switch语句中 默认使用全等符 `===`\n","slug":"高程笔记","published":1,"updated":"2017-02-20T06:33:54.212Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizhru6py000oosqp9bwv0cpa","content":"<p>本文是第二遍系统的读高级程序语言设计（第三版）时的笔记，包括</p>\n<ul>\n<li>平时用的比较少，记忆不深刻的方法API</li>\n<li>结合写代码中遇到的坑与书中知识点的印证（主要是原型和构造对象模式的知识点）</li>\n<li>笔记没有追求全面，只是对于知识点查漏补缺的索引</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"Object-prop-和Object-prop的区别\"><a href=\"#Object-prop-和Object-prop的区别\" class=\"headerlink\" title=\"Object [ prop ]和Object.prop的区别\"></a>Object [ prop ]和Object.prop的区别</h2><ol>\n<li>语法方面的区别 点表示法的对象的属性名是标识符，而后者的属性名则是一个字符串。</li>\n<li>灵活性方面的区别 在JavaScript编写程序中，可以为对象创建任意数目的属性。但使用”.”运算符来存取一个对象的属性时，属性名是用标识符表示的。而在JavaScript程序中，标识符必须被逐字地输入，它们不是一种数据类型，因此程序不能对其操作。也就是说，标识符是静态的，在程序中必须对其进行硬编码。 而使用数组[]表示法来存取一个对象的属性时，属性名是用字符串表示的。字符串是JavaScript的一种数据类型，因此可以在程序运行中操作并创建它们。</li>\n<li><p>性能方面区别 数组[]表示法在存取属性值时会进行表达式运行。而点表示法是直接存取属性值，理论上执行效率会比数组表示法高。性能方面其实可以忽略。 某些场景必须用到数组表示法来动态存取属性值，这个是点表示法无法做到的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> prop=<span class=\"string\">'name'</span>,object=&#123;<span class=\"attr\">name</span>:<span class=\"string\">'dasda'</span>&#125;;</div><div class=\"line\">       <span class=\"built_in\">console</span>.log(object[prop]);  <span class=\"comment\">//dasda</span></div><div class=\"line\">       <span class=\"built_in\">console</span>.log(object.prop);   <span class=\"comment\">//undefined</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>总的来说，这两种方法区别上不大，都有对应的使用场景。点表示法一般作为静态对象使用时来存取属性。而数组表示法在动态存取属性时就非常有用。</p>\n</li>\n</ol>\n<h2 id=\"arguments和命名参数单向同步\"><a href=\"#arguments和命名参数单向同步\" class=\"headerlink\" title=\"arguments和命名参数单向同步\"></a>arguments和命名参数单向同步</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">num1,num2</span>)</span>&#123;</div><div class=\"line\">          <span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>]=<span class=\"number\">10</span>;</div><div class=\"line\">          alert(<span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]+num2);</div><div class=\"line\">     &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>执行add（）会重写第二个参数，arguments对象中的值会自动反应到命名参数，但这是单向的，也就是改变命名参数的值但是arguments对象中的值不会改变，</li>\n<li><p>严格模式中不能设置argumengts对象的值</p>\n<h3 id=\"typeof和instanceof\"><a href=\"#typeof和instanceof\" class=\"headerlink\" title=\"typeof和instanceof\"></a>typeof和instanceof</h3></li>\n<li><p>因为typeof检测引用类型值时，不同浏览器会有不同的结果，所以推荐只用typeof检测基本数据类型，检测值是否存在</p>\n</li>\n<li><p>instanceof</p>\n<ul>\n<li>语法 person instanceof Object</li>\n<li>用来检测引用类型</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Array类型的方法\"><a href=\"#Array类型的方法\" class=\"headerlink\" title=\"Array类型的方法\"></a>Array类型的方法</h2><h3 id=\"Array-isArray-方法\"><a href=\"#Array-isArray-方法\" class=\"headerlink\" title=\"Array.isArray()方法\"></a>Array.isArray()方法</h3><ul>\n<li>解决多个全局执行环境时（多个框架），Array构造函数不同，instanceof你能正确检测对象是不是数组的问题</li>\n<li>支持该方法的浏览器：IE9+、Firefox4+、Safari 5+、Opera 10.5+和Chrome</li>\n</ul>\n<h3 id=\"Array-sort\"><a href=\"#Array-sort\" class=\"headerlink\" title=\"Array.sort()\"></a>Array.sort()</h3><ul>\n<li><p>无论数组项是不是数值，都会调用每一项的tostring（）方法，然后比较字符串。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> values=[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">10</span>,<span class=\"number\">15</span>];</div><div class=\"line\">alert(values.sort()); <span class=\"comment\">//0,1,10,15,5</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>sort()方法可以传一个比较函数，比较函数接受两个参数（a，b），a&gt;b 返回1，a&lt; b,返回-1，相等返回0。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compare</span>(<span class=\"params\">a,b</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(a &gt;b )&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a &lt; b )&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"slice-方法\"><a href=\"#slice-方法\" class=\"headerlink\" title=\"slice()方法\"></a>slice()方法</h3><ul>\n<li>slice(startIndex,endIndex)</li>\n<li>返回起始到结束位置之间的项，不包括结束位置,只传入一个参数时，返回索引位置到结束的所有项</li>\n<li><p>不会影响原数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> value=[<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">3</span>,<span class=\"number\">8</span>,<span class=\"number\">2</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> value1=value.slice(<span class=\"number\">2</span>,<span class=\"number\">5</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> value2=value.slice(<span class=\"number\">2</span>);</div><div class=\"line\">alert(value1,<span class=\"string\">'$$$$$'</span>+value2);  <span class=\"comment\">//7,3,8$$$$$7,3,8,2</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"splice-方法\"><a href=\"#splice-方法\" class=\"headerlink\" title=\"splice()方法\"></a>splice()方法</h3><ul>\n<li>splice(startIndex,count,item) //(起始位置，项数，插入项）</li>\n<li><p>返回删除的项</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> value=[<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">3</span>,<span class=\"number\">8</span>,<span class=\"number\">2</span>] ;</div><div class=\"line\">alert(value.splice(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)); <span class=\"comment\">// 7</span></div><div class=\"line\">alert(value); <span class=\"comment\">// 1,5,1,2,3,3,8,2</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"indexOf-和lastIndexOf-方法\"><a href=\"#indexOf-和lastIndexOf-方法\" class=\"headerlink\" title=\"indexOf()和lastIndexOf()方法\"></a>indexOf()和lastIndexOf()方法</h3><ul>\n<li>indexof(item,startIndex)||lastIndexOf(item,startIndex) // (项的值,起始位置）</li>\n<li><p>查找比较时使用全等操作符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> value=[<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">2</span>];</div><div class=\"line\">alert(value.indexOf(<span class=\"number\">5</span>)); <span class=\"comment\">//1</span></div><div class=\"line\">alert(value.lastIndexOf(<span class=\"number\">5</span>)); <span class=\"comment\">//4</span></div><div class=\"line\">alert(value.indexOf(<span class=\"number\">5</span>,<span class=\"number\">2</span>)); <span class=\"comment\">//4</span></div><div class=\"line\">alert(value.lastIndexOf(<span class=\"number\">5</span>,<span class=\"number\">3</span>)) <span class=\"comment\">//1</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"every-和some-方法\"><a href=\"#every-和some-方法\" class=\"headerlink\" title=\"every()和some()方法\"></a>every()和some()方法</h3><ul>\n<li>every(fn)，传入函数对<strong>每一</strong>项都返回<code>true</code>，这个方法返回<code>true</code></li>\n<li>some(fn),传入函数对<strong>任一</strong>项返回<code>true</code>，这个方法就返回<code>true</code></li>\n</ul>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter()\"></a>filter()</h3><ul>\n<li>filter(fn)</li>\n<li>返回该函数会返回<code>true</code>的项组成的数组</li>\n</ul>\n<h3 id=\"forEach-和map-方法\"><a href=\"#forEach-和map-方法\" class=\"headerlink\" title=\"forEach()和map()方法\"></a>forEach()和map()方法</h3><ul>\n<li>forEach(item,index,array) || map(item,index,array)</li>\n<li><p>forEach没有返回值,map会返回一个每一项执行函数后返回的值组成的数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr1=[<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">9</span>,<span class=\"number\">43</span>,<span class=\"number\">65</span>,<span class=\"number\">7</span>];</div><div class=\"line\">  <span class=\"keyword\">var</span> arrMap=arr1.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item,index,array</span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> item*<span class=\"number\">2</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">  alert(arrMap);<span class=\"comment\">//2,10,18,86,130,14</span></div><div class=\"line\">  alert(arr1);<span class=\"comment\">//1,5,9,43,65,7</span></div><div class=\"line\">  <span class=\"keyword\">var</span> arrFor=arr1.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item,index,array</span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> item*<span class=\"number\">2</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">  alert(arrFor);<span class=\"comment\">//undefined</span></div><div class=\"line\">  alert(arr1);<span class=\"comment\">//1,5,9,43,65,7</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h2><h3 id=\"trim-、trimLeft-、trimRight-方法\"><a href=\"#trim-、trimLeft-、trimRight-方法\" class=\"headerlink\" title=\"trim()、trimLeft()、trimRight()方法\"></a>trim()、trimLeft()、trimRight()方法</h3><ul>\n<li>trim()返回删除前置和后缀空格以后的String副本，对原数据无改变</li>\n<li>trimLeft(),trimRight()分别删除前置和后缀空格</li>\n</ul>\n<h2 id=\"面向对象的程序设计\"><a href=\"#面向对象的程序设计\" class=\"headerlink\" title=\"面向对象的程序设计\"></a>面向对象的程序设计</h2><p>面向对象的程序设计中的描述符等暂时想不到哪里能用到，用到再精读。这里说一下遇到的一个，如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Pig</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\">Pig.prototype = &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">init</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">move</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.move();</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> pigPlayer=<span class=\"keyword\">new</span> Pig();</div><div class=\"line\">setInterval(pigPlayer.render.bind(pigPlayer),<span class=\"number\">1000</span>);</div></pre></td></tr></table></figure>\n<p>重写原型时会造成<code>Pig.prototype.constructor===Pig//false</code>,而像下面重写会造成<code>constructor</code>变为可枚举属性。记一下这个坑，非要爬坑详见高程P155.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Pig.prototype = &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">constructor</span>:Pig,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">init</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">move</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.move();</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h3><p>这里只说一个我第一次接触时的误区，<strong>构造函数创建的实例中是没有<code>prototype</code>这个属性的，只有<code>_proto_</code>,所以本质上我们所说的实例的原型是构造器函数的原型</strong>，如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Yo=<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.name=<span class=\"string\">'ddd'</span></div><div class=\"line\">        &#125;;</div><div class=\"line\">        <span class=\"keyword\">var</span> yo=<span class=\"keyword\">new</span> Yo;</div><div class=\"line\">        <span class=\"built_in\">console</span>.dir(yo);</div><div class=\"line\">        <span class=\"comment\">//Yo  </span></div><div class=\"line\">        <span class=\"comment\">//展开后    //name:'ddd'</span></div><div class=\"line\">                <span class=\"comment\">//_proto_:Object</span></div><div class=\"line\">        <span class=\"built_in\">console</span>.dir(Yo)</div><div class=\"line\">        <span class=\"comment\">//function Yo()</span></div><div class=\"line\">       <span class=\"comment\">//展开后  //arguments:null</span></div><div class=\"line\">                <span class=\"comment\">//caller:null</span></div><div class=\"line\">                <span class=\"comment\">//length:0</span></div><div class=\"line\">                <span class=\"comment\">//name:\"Yo\"</span></div><div class=\"line\">                <span class=\"comment\">//prototype:Object</span></div><div class=\"line\">                <span class=\"comment\">//__proto__:()</span></div><div class=\"line\">                <span class=\"comment\">//[[FunctionLocation]]:test.html:22</span></div><div class=\"line\">                <span class=\"comment\">//[[Scopes]]:Scopes[1]</span></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>对于这部分更详细的内容，直接细看这一章</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"number-lt-gt-string\"><a href=\"#number-lt-gt-string\" class=\"headerlink\" title=\"number&lt;&gt;string\"></a>number&lt;&gt;string</h3><ul>\n<li><p>parseInt（string，进制数） <code>parseInt（‘11dsad’，10）&gt;&gt;&gt;11</code></p>\n</li>\n<li><p>toString() Number&gt;&gt;&gt;String时可传参数（进制数） <code>10.toString(2)&gt;&gt;&gt;&#39;1010&#39;</code></p>\n</li>\n</ul>\n<h3 id=\"array-lt-gt-string\"><a href=\"#array-lt-gt-string\" class=\"headerlink\" title=\"array&lt;&gt;string\"></a>array&lt;&gt;string</h3><ul>\n<li><code>arr.join(param)</code> @param 分隔符 String格式</li>\n<li><p>`string.split(param) @param 识别分隔符 String格式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"string\">'hello'</span>,b=<span class=\"string\">'llohe'</span>;</div><div class=\"line\">   <span class=\"keyword\">var</span> isTrue=<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>a.split(<span class=\"string\">''</span>).sort()===b.split(<span class=\"string\">''</span>).sort()?<span class=\"literal\">true</span>:<span class=\"literal\">false</span>;</div><div class=\"line\">   isTrue();<span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"for-in语句\"><a href=\"#for-in语句\" class=\"headerlink\" title=\"for-in语句\"></a>for-in语句</h3><ul>\n<li><p>枚举对象属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> prop <span class=\"keyword\">in</span> <span class=\"built_in\">Object</span>)&#123;</div><div class=\"line\">          <span class=\"keyword\">do</span> something...</div><div class=\"line\">     &#123;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"switch的有趣用法\"><a href=\"#switch的有趣用法\" class=\"headerlink\" title=\"switch的有趣用法\"></a>switch的有趣用法</h3>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> num=<span class=\"number\">25</span>;</div><div class=\"line\">     <span class=\"keyword\">switch</span>(<span class=\"literal\">true</span>)&#123;</div><div class=\"line\">          <span class=\"keyword\">case</span> num&lt;<span class=\"number\">0</span>:<span class=\"keyword\">break</span>;</div><div class=\"line\">          <span class=\"keyword\">case</span> num&gt;<span class=\"number\">0</span>:<span class=\"keyword\">break</span>;</div><div class=\"line\">          <span class=\"keyword\">default</span>:<span class=\"keyword\">break</span>;</div><div class=\"line\">     &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>switch语句中 默认使用全等符 <code>===</code></li>\n</ul>\n","excerpt":"<p>本文是第二遍系统的读高级程序语言设计（第三版）时的笔记，包括</p>\n<ul>\n<li>平时用的比较少，记忆不深刻的方法API</li>\n<li>结合写代码中遇到的坑与书中知识点的印证（主要是原型和构造对象模式的知识点）</li>\n<li>笔记没有追求全面，只是对于知识点查漏补缺的索引</li>\n</ul>","more":"<h2 id=\"Object-prop-和Object-prop的区别\"><a href=\"#Object-prop-和Object-prop的区别\" class=\"headerlink\" title=\"Object [ prop ]和Object.prop的区别\"></a>Object [ prop ]和Object.prop的区别</h2><ol>\n<li>语法方面的区别 点表示法的对象的属性名是标识符，而后者的属性名则是一个字符串。</li>\n<li>灵活性方面的区别 在JavaScript编写程序中，可以为对象创建任意数目的属性。但使用”.”运算符来存取一个对象的属性时，属性名是用标识符表示的。而在JavaScript程序中，标识符必须被逐字地输入，它们不是一种数据类型，因此程序不能对其操作。也就是说，标识符是静态的，在程序中必须对其进行硬编码。 而使用数组[]表示法来存取一个对象的属性时，属性名是用字符串表示的。字符串是JavaScript的一种数据类型，因此可以在程序运行中操作并创建它们。</li>\n<li><p>性能方面区别 数组[]表示法在存取属性值时会进行表达式运行。而点表示法是直接存取属性值，理论上执行效率会比数组表示法高。性能方面其实可以忽略。 某些场景必须用到数组表示法来动态存取属性值，这个是点表示法无法做到的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> prop=<span class=\"string\">'name'</span>,object=&#123;<span class=\"attr\">name</span>:<span class=\"string\">'dasda'</span>&#125;;</div><div class=\"line\">       <span class=\"built_in\">console</span>.log(object[prop]);  <span class=\"comment\">//dasda</span></div><div class=\"line\">       <span class=\"built_in\">console</span>.log(object.prop);   <span class=\"comment\">//undefined</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>总的来说，这两种方法区别上不大，都有对应的使用场景。点表示法一般作为静态对象使用时来存取属性。而数组表示法在动态存取属性时就非常有用。</p>\n</li>\n</ol>\n<h2 id=\"arguments和命名参数单向同步\"><a href=\"#arguments和命名参数单向同步\" class=\"headerlink\" title=\"arguments和命名参数单向同步\"></a>arguments和命名参数单向同步</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">num1,num2</span>)</span>&#123;</div><div class=\"line\">          <span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>]=<span class=\"number\">10</span>;</div><div class=\"line\">          alert(<span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]+num2);</div><div class=\"line\">     &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>执行add（）会重写第二个参数，arguments对象中的值会自动反应到命名参数，但这是单向的，也就是改变命名参数的值但是arguments对象中的值不会改变，</li>\n<li><p>严格模式中不能设置argumengts对象的值</p>\n<h3 id=\"typeof和instanceof\"><a href=\"#typeof和instanceof\" class=\"headerlink\" title=\"typeof和instanceof\"></a>typeof和instanceof</h3></li>\n<li><p>因为typeof检测引用类型值时，不同浏览器会有不同的结果，所以推荐只用typeof检测基本数据类型，检测值是否存在</p>\n</li>\n<li><p>instanceof</p>\n<ul>\n<li>语法 person instanceof Object</li>\n<li>用来检测引用类型</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Array类型的方法\"><a href=\"#Array类型的方法\" class=\"headerlink\" title=\"Array类型的方法\"></a>Array类型的方法</h2><h3 id=\"Array-isArray-方法\"><a href=\"#Array-isArray-方法\" class=\"headerlink\" title=\"Array.isArray()方法\"></a>Array.isArray()方法</h3><ul>\n<li>解决多个全局执行环境时（多个框架），Array构造函数不同，instanceof你能正确检测对象是不是数组的问题</li>\n<li>支持该方法的浏览器：IE9+、Firefox4+、Safari 5+、Opera 10.5+和Chrome</li>\n</ul>\n<h3 id=\"Array-sort\"><a href=\"#Array-sort\" class=\"headerlink\" title=\"Array.sort()\"></a>Array.sort()</h3><ul>\n<li><p>无论数组项是不是数值，都会调用每一项的tostring（）方法，然后比较字符串。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> values=[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">10</span>,<span class=\"number\">15</span>];</div><div class=\"line\">alert(values.sort()); <span class=\"comment\">//0,1,10,15,5</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>sort()方法可以传一个比较函数，比较函数接受两个参数（a，b），a&gt;b 返回1，a&lt; b,返回-1，相等返回0。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compare</span>(<span class=\"params\">a,b</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(a &gt;b )&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a &lt; b )&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"slice-方法\"><a href=\"#slice-方法\" class=\"headerlink\" title=\"slice()方法\"></a>slice()方法</h3><ul>\n<li>slice(startIndex,endIndex)</li>\n<li>返回起始到结束位置之间的项，不包括结束位置,只传入一个参数时，返回索引位置到结束的所有项</li>\n<li><p>不会影响原数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> value=[<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">3</span>,<span class=\"number\">8</span>,<span class=\"number\">2</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> value1=value.slice(<span class=\"number\">2</span>,<span class=\"number\">5</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> value2=value.slice(<span class=\"number\">2</span>);</div><div class=\"line\">alert(value1,<span class=\"string\">'$$$$$'</span>+value2);  <span class=\"comment\">//7,3,8$$$$$7,3,8,2</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"splice-方法\"><a href=\"#splice-方法\" class=\"headerlink\" title=\"splice()方法\"></a>splice()方法</h3><ul>\n<li>splice(startIndex,count,item) //(起始位置，项数，插入项）</li>\n<li><p>返回删除的项</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> value=[<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">3</span>,<span class=\"number\">8</span>,<span class=\"number\">2</span>] ;</div><div class=\"line\">alert(value.splice(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)); <span class=\"comment\">// 7</span></div><div class=\"line\">alert(value); <span class=\"comment\">// 1,5,1,2,3,3,8,2</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"indexOf-和lastIndexOf-方法\"><a href=\"#indexOf-和lastIndexOf-方法\" class=\"headerlink\" title=\"indexOf()和lastIndexOf()方法\"></a>indexOf()和lastIndexOf()方法</h3><ul>\n<li>indexof(item,startIndex)||lastIndexOf(item,startIndex) // (项的值,起始位置）</li>\n<li><p>查找比较时使用全等操作符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> value=[<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">2</span>];</div><div class=\"line\">alert(value.indexOf(<span class=\"number\">5</span>)); <span class=\"comment\">//1</span></div><div class=\"line\">alert(value.lastIndexOf(<span class=\"number\">5</span>)); <span class=\"comment\">//4</span></div><div class=\"line\">alert(value.indexOf(<span class=\"number\">5</span>,<span class=\"number\">2</span>)); <span class=\"comment\">//4</span></div><div class=\"line\">alert(value.lastIndexOf(<span class=\"number\">5</span>,<span class=\"number\">3</span>)) <span class=\"comment\">//1</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"every-和some-方法\"><a href=\"#every-和some-方法\" class=\"headerlink\" title=\"every()和some()方法\"></a>every()和some()方法</h3><ul>\n<li>every(fn)，传入函数对<strong>每一</strong>项都返回<code>true</code>，这个方法返回<code>true</code></li>\n<li>some(fn),传入函数对<strong>任一</strong>项返回<code>true</code>，这个方法就返回<code>true</code></li>\n</ul>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter()\"></a>filter()</h3><ul>\n<li>filter(fn)</li>\n<li>返回该函数会返回<code>true</code>的项组成的数组</li>\n</ul>\n<h3 id=\"forEach-和map-方法\"><a href=\"#forEach-和map-方法\" class=\"headerlink\" title=\"forEach()和map()方法\"></a>forEach()和map()方法</h3><ul>\n<li>forEach(item,index,array) || map(item,index,array)</li>\n<li><p>forEach没有返回值,map会返回一个每一项执行函数后返回的值组成的数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr1=[<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">9</span>,<span class=\"number\">43</span>,<span class=\"number\">65</span>,<span class=\"number\">7</span>];</div><div class=\"line\">  <span class=\"keyword\">var</span> arrMap=arr1.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item,index,array</span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> item*<span class=\"number\">2</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">  alert(arrMap);<span class=\"comment\">//2,10,18,86,130,14</span></div><div class=\"line\">  alert(arr1);<span class=\"comment\">//1,5,9,43,65,7</span></div><div class=\"line\">  <span class=\"keyword\">var</span> arrFor=arr1.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item,index,array</span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> item*<span class=\"number\">2</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">  alert(arrFor);<span class=\"comment\">//undefined</span></div><div class=\"line\">  alert(arr1);<span class=\"comment\">//1,5,9,43,65,7</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h2><h3 id=\"trim-、trimLeft-、trimRight-方法\"><a href=\"#trim-、trimLeft-、trimRight-方法\" class=\"headerlink\" title=\"trim()、trimLeft()、trimRight()方法\"></a>trim()、trimLeft()、trimRight()方法</h3><ul>\n<li>trim()返回删除前置和后缀空格以后的String副本，对原数据无改变</li>\n<li>trimLeft(),trimRight()分别删除前置和后缀空格</li>\n</ul>\n<h2 id=\"面向对象的程序设计\"><a href=\"#面向对象的程序设计\" class=\"headerlink\" title=\"面向对象的程序设计\"></a>面向对象的程序设计</h2><p>面向对象的程序设计中的描述符等暂时想不到哪里能用到，用到再精读。这里说一下遇到的一个，如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Pig</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\">Pig.prototype = &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">init</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">move</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.move();</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> pigPlayer=<span class=\"keyword\">new</span> Pig();</div><div class=\"line\">setInterval(pigPlayer.render.bind(pigPlayer),<span class=\"number\">1000</span>);</div></pre></td></tr></table></figure>\n<p>重写原型时会造成<code>Pig.prototype.constructor===Pig//false</code>,而像下面重写会造成<code>constructor</code>变为可枚举属性。记一下这个坑，非要爬坑详见高程P155.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Pig.prototype = &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">constructor</span>:Pig,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">init</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">move</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.move();</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h3><p>这里只说一个我第一次接触时的误区，<strong>构造函数创建的实例中是没有<code>prototype</code>这个属性的，只有<code>_proto_</code>,所以本质上我们所说的实例的原型是构造器函数的原型</strong>，如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Yo=<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.name=<span class=\"string\">'ddd'</span></div><div class=\"line\">        &#125;;</div><div class=\"line\">        <span class=\"keyword\">var</span> yo=<span class=\"keyword\">new</span> Yo;</div><div class=\"line\">        <span class=\"built_in\">console</span>.dir(yo);</div><div class=\"line\">        <span class=\"comment\">//Yo  </span></div><div class=\"line\">        <span class=\"comment\">//展开后    //name:'ddd'</span></div><div class=\"line\">                <span class=\"comment\">//_proto_:Object</span></div><div class=\"line\">        <span class=\"built_in\">console</span>.dir(Yo)</div><div class=\"line\">        <span class=\"comment\">//function Yo()</span></div><div class=\"line\">       <span class=\"comment\">//展开后  //arguments:null</span></div><div class=\"line\">                <span class=\"comment\">//caller:null</span></div><div class=\"line\">                <span class=\"comment\">//length:0</span></div><div class=\"line\">                <span class=\"comment\">//name:\"Yo\"</span></div><div class=\"line\">                <span class=\"comment\">//prototype:Object</span></div><div class=\"line\">                <span class=\"comment\">//__proto__:()</span></div><div class=\"line\">                <span class=\"comment\">//[[FunctionLocation]]:test.html:22</span></div><div class=\"line\">                <span class=\"comment\">//[[Scopes]]:Scopes[1]</span></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>对于这部分更详细的内容，直接细看这一章</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"number-lt-gt-string\"><a href=\"#number-lt-gt-string\" class=\"headerlink\" title=\"number&lt;&gt;string\"></a>number&lt;&gt;string</h3><ul>\n<li><p>parseInt（string，进制数） <code>parseInt（‘11dsad’，10）&gt;&gt;&gt;11</code></p>\n</li>\n<li><p>toString() Number&gt;&gt;&gt;String时可传参数（进制数） <code>10.toString(2)&gt;&gt;&gt;&#39;1010&#39;</code></p>\n</li>\n</ul>\n<h3 id=\"array-lt-gt-string\"><a href=\"#array-lt-gt-string\" class=\"headerlink\" title=\"array&lt;&gt;string\"></a>array&lt;&gt;string</h3><ul>\n<li><code>arr.join(param)</code> @param 分隔符 String格式</li>\n<li><p>`string.split(param) @param 识别分隔符 String格式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"string\">'hello'</span>,b=<span class=\"string\">'llohe'</span>;</div><div class=\"line\">   <span class=\"keyword\">var</span> isTrue=<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>a.split(<span class=\"string\">''</span>).sort()===b.split(<span class=\"string\">''</span>).sort()?<span class=\"literal\">true</span>:<span class=\"literal\">false</span>;</div><div class=\"line\">   isTrue();<span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"for-in语句\"><a href=\"#for-in语句\" class=\"headerlink\" title=\"for-in语句\"></a>for-in语句</h3><ul>\n<li><p>枚举对象属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> prop <span class=\"keyword\">in</span> <span class=\"built_in\">Object</span>)&#123;</div><div class=\"line\">          <span class=\"keyword\">do</span> something...</div><div class=\"line\">     &#123;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"switch的有趣用法\"><a href=\"#switch的有趣用法\" class=\"headerlink\" title=\"switch的有趣用法\"></a>switch的有趣用法</h3>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> num=<span class=\"number\">25</span>;</div><div class=\"line\">     <span class=\"keyword\">switch</span>(<span class=\"literal\">true</span>)&#123;</div><div class=\"line\">          <span class=\"keyword\">case</span> num&lt;<span class=\"number\">0</span>:<span class=\"keyword\">break</span>;</div><div class=\"line\">          <span class=\"keyword\">case</span> num&gt;<span class=\"number\">0</span>:<span class=\"keyword\">break</span>;</div><div class=\"line\">          <span class=\"keyword\">default</span>:<span class=\"keyword\">break</span>;</div><div class=\"line\">     &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>switch语句中 默认使用全等符 <code>===</code></li>\n</ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"cizhru6op0000osqptkdot037","category_id":"cizhru6p70004osqpqtin258n","_id":"cizhru6pk000dosqpxvne6pue"},{"post_id":"cizhru6p20002osqp9fumjz2l","category_id":"cizhru6ph000aosqp8y774p2y","_id":"cizhru6pv000kosqpyrpomy61"},{"post_id":"cizhru6pb0006osqp1h54jj53","category_id":"cizhru6p70004osqpqtin258n","_id":"cizhru6q0000posqptesyunsp"},{"post_id":"cizhru6py000oosqp9bwv0cpa","category_id":"cizhru6p70004osqpqtin258n","_id":"cizhru6q3000tosqpxm3rku92"},{"post_id":"cizhru6pd0008osqp30brg7yd","category_id":"cizhru6pw000mosqp8a0biqlp","_id":"cizhru6q4000vosqp79195394"},{"post_id":"cizhru6pg0009osqprscq0z8l","category_id":"cizhru6q0000qosqpjqowskwy","_id":"cizhru6q6000yosqpbyy5syu1"},{"post_id":"cizhru6pj000cosqpbeu4g9rg","category_id":"cizhru6q4000wosqpxtkaav7p","_id":"cizhru6q70013osqplkcnrjkt"},{"post_id":"cizhru6pk000eosqp4wlstv2b","category_id":"cizhru6q60010osqp881qf6qg","_id":"cizhru6q80016osqpjupaiug8"},{"post_id":"cizhru6pq000hosqptp76bu04","category_id":"cizhru6q70015osqpu31g01sk","_id":"cizhru6q9001bosqpos2hlol3"},{"post_id":"cizhru6pt000josqph88gz4ji","category_id":"cizhru6q90018osqpi91kbjo8","_id":"cizhru6qa001eosqpp5hm4gsb"}],"PostTag":[{"post_id":"cizhru6op0000osqptkdot037","tag_id":"cizhru6pa0005osqp3dw82rw4","_id":"cizhru6ps000iosqpkodnh4w6"},{"post_id":"cizhru6op0000osqptkdot037","tag_id":"cizhru6pi000bosqpy6k31vh6","_id":"cizhru6pv000losqp4fpjbokz"},{"post_id":"cizhru6p20002osqp9fumjz2l","tag_id":"cizhru6pi000bosqpy6k31vh6","_id":"cizhru6q2000sosqp1jxpn5h4"},{"post_id":"cizhru6p20002osqp9fumjz2l","tag_id":"cizhru6pw000nosqploah08ra","_id":"cizhru6q3000uosqp4wobm6tw"},{"post_id":"cizhru6pb0006osqp1h54jj53","tag_id":"cizhru6q1000rosqpwyd6bdiw","_id":"cizhru6q70011osqpdvlegqtk"},{"post_id":"cizhru6pb0006osqp1h54jj53","tag_id":"cizhru6pi000bosqpy6k31vh6","_id":"cizhru6q70012osqpg29qyqyo"},{"post_id":"cizhru6pd0008osqp30brg7yd","tag_id":"cizhru6pi000bosqpy6k31vh6","_id":"cizhru6q90019osqpz4u9w4aw"},{"post_id":"cizhru6pd0008osqp30brg7yd","tag_id":"cizhru6q70014osqpq5fg133g","_id":"cizhru6q9001aosqpwlaczm0e"},{"post_id":"cizhru6pg0009osqprscq0z8l","tag_id":"cizhru6q80017osqprrado4po","_id":"cizhru6qa001dosqp253uek68"},{"post_id":"cizhru6pj000cosqpbeu4g9rg","tag_id":"cizhru6q9001cosqpjxspmpuh","_id":"cizhru6qc001hosqpzf86u2my"},{"post_id":"cizhru6pj000cosqpbeu4g9rg","tag_id":"cizhru6qa001fosqplp4idelo","_id":"cizhru6qc001iosqp0ysnamhm"},{"post_id":"cizhru6pj000cosqpbeu4g9rg","tag_id":"cizhru6pi000bosqpy6k31vh6","_id":"cizhru6qc001kosqpljynuypf"},{"post_id":"cizhru6pk000eosqp4wlstv2b","tag_id":"cizhru6pi000bosqpy6k31vh6","_id":"cizhru6qd001losqpumpdinwc"},{"post_id":"cizhru6pk000eosqp4wlstv2b","tag_id":"cizhru6q70014osqpq5fg133g","_id":"cizhru6qe001nosqphp1uhgby"},{"post_id":"cizhru6pq000hosqptp76bu04","tag_id":"cizhru6qc001josqpcuco73n8","_id":"cizhru6qf001sosqpd5ht46fs"},{"post_id":"cizhru6pq000hosqptp76bu04","tag_id":"cizhru6qd001mosqp9phkacew","_id":"cizhru6qf001tosqpua11kil0"},{"post_id":"cizhru6pq000hosqptp76bu04","tag_id":"cizhru6qe001oosqp3emt0zrl","_id":"cizhru6qg001vosqpnnxab9k8"},{"post_id":"cizhru6pq000hosqptp76bu04","tag_id":"cizhru6qe001posqppi7p2zbj","_id":"cizhru6qg001wosqp689lcx87"},{"post_id":"cizhru6pq000hosqptp76bu04","tag_id":"cizhru6qf001qosqpq13bqwbb","_id":"cizhru6qh001yosqppv1v0hvh"},{"post_id":"cizhru6pt000josqph88gz4ji","tag_id":"cizhru6qf001rosqpex5lijgr","_id":"cizhru6qh001zosqpfr8z29px"},{"post_id":"cizhru6pt000josqph88gz4ji","tag_id":"cizhru6qg001uosqp5u1jnn3u","_id":"cizhru6qh0020osqpn4t4mxxk"},{"post_id":"cizhru6py000oosqp9bwv0cpa","tag_id":"cizhru6pi000bosqpy6k31vh6","_id":"cizhru6qh0021osqp0l13x83e"},{"post_id":"cizhru6py000oosqp9bwv0cpa","tag_id":"cizhru6qh001xosqpc84mcemq","_id":"cizhru6qi0022osqpufijf5e5"}],"Tag":[{"name":"异步","_id":"cizhru6pa0005osqp3dw82rw4"},{"name":"JavaScript","_id":"cizhru6pi000bosqpy6k31vh6"},{"name":"数据结构和算法","_id":"cizhru6pw000nosqploah08ra"},{"name":"向下一层","_id":"cizhru6q1000rosqpwyd6bdiw"},{"name":"函数式编程","_id":"cizhru6q70014osqpq5fg133g"},{"name":"hexo","_id":"cizhru6q80017osqprrado4po"},{"name":"npm","_id":"cizhru6q9001cosqpjxspmpuh"},{"name":"node","_id":"cizhru6qa001fosqplp4idelo"},{"name":"素材资源","_id":"cizhru6qc001josqpcuco73n8"},{"name":"在线工具","_id":"cizhru6qd001mosqp9phkacew"},{"name":"Chrome插件","_id":"cizhru6qe001oosqp3emt0zrl"},{"name":"时间管理","_id":"cizhru6qe001posqppi7p2zbj"},{"name":"快乐的coding","_id":"cizhru6qf001qosqpq13bqwbb"},{"name":"video","_id":"cizhru6qf001rosqpex5lijgr"},{"name":"HTML5","_id":"cizhru6qg001uosqp5u1jnn3u"},{"name":"读书","_id":"cizhru6qh001xosqpc84mcemq"}]}}